<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Model" referent="RBX0">
		<Properties>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Tools</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="Tool" referent="RBX1">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>-0.699999988</Z>
					<R00>0</R00>
					<R01>0</R01>
					<R02>1</R02>
					<R10>1</R10>
					<R11>0</R11>
					<R12>-0</R12>
					<R20>-0</R20>
					<R21>1</R21>
					<R22>-0</R22>
				</CoordinateFrame>
				<string name="Name">WiringTool</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset?id=56954008</url></Content>
				<string name="ToolTip">Wiring Tool</string>
			</Properties>
			<Item class="Part" referent="RBX2">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>124.375</X>
						<Y>217.574951</Y>
						<Z>132.75</Z>
						<R00>-0.778526425</R00>
						<R01>0.00874528848</R01>
						<R02>0.62755084</R02>
						<R10>-0.00896868855</R10>
						<R11>-0.999955893</R11>
						<R12>0.00280860346</R12>
						<R20>0.627547741</R20>
						<R21>-0.00344173564</R21>
						<R22>0.778570473</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0.0120760305</X>
						<Y>-0.00255576265</Y>
						<Z>-0.0137164257</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0.0020385494</X>
						<Y>0.00916798413</Y>
						<Z>-0.00379409106</Z>
					</Vector3>
					<token name="formFactorRaw">2</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.800000012</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX3">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=16884681</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>0.600000024</X>
							<Y>0.600000024</Y>
							<Z>0.600000024</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=16884673</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX4">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WiringScript</string>
					<ProtectedString name="Source">function waitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
end

local Tool = script.Parent
local mouseMoveCon, mouseButtonDownCon = nil

local eventTable = {}
local receiverTable = {}
local ServiceConnections = {}
local adornmentTable = {}

local eventBadgeCount = {}
local receiverBadgeCount = {}

local root = nil

local isRestricted = (game.PlaceId == 41324860 or game.PlaceId == 129686177)

waitForChild(Tool, &quot;PlayerOwner&quot;)
local playerOwner = Tool.PlayerOwner

local CONNECT_BILLBOARD_GUI = &quot;ConnectBillboardGui&quot;
local WIRE_LASSO = &quot;WireLasso&quot;
local WIRE_TEXTURE = &quot;http://www.roblox.com/asset?id=56954045&quot;
--local WIRE_TEXTURE = &quot;rbxasset://Textures/ui/playerlist_small_hide_dn.png&quot;
local KILL_WIRE_TEXTURE = &quot;rbxasset://Textures/ui/CloseButton_dn.png&quot;
local STATIC_PLAYER_GUI = nil
local STATIC_BASE_PLATE = nil
local SELECTED_SOURCE = nil
local SELECTED_SINK = nil
local WIRE_LASSO_MAP = {}
local WIRING_PANEL_MAP = {}
local LAST_HOVERED_PART = nil
local SCREEN_MESSAGE = nil
local ANNOTATIONS = {}
local KNOWN_SOURCE_PARTS = {}
local KNOWN_SINK_PARTS = {}
local BASE_ANNOTATION_TRANSPARENCY = 0.5
local BASE_WIRE_TRANSPARENCY = 0.5
local BASE_WIRE_RADIUS = .06
local ENHANCED_WIRE_RADIUS = .12
local SOURCE_BUTTON_TEXT_COLOR = Color3.new(1, .5, 0)
local SOURCE_BUTTON_ICON_TEXTURE = &quot;http://www.roblox.com/asset?id=61334830&quot;
local SOURCE_BUTTON_ICON_HOVER_TEXTURE = &quot;http://www.roblox.com/asset?id=61335012&quot;
local SINK_BUTTON_TEXT_COLOR = Color3.new(0, 1, 0)
local SINK_BUTTON_ICON_TEXTURE = &quot;http://www.roblox.com/asset?id=60730993&quot;
local SINK_BUTTON_ICON_HOVER_TEXTURE = &quot;http://www.roblox.com/asset?id=61335025&quot;
local BUTTON_HOVER_TEXT_COLOR = Color3.new(1, 1, 1)
local BUTTON_ICON_WIDTH = 50
local DISCONNECT_ICON_HOVER_TEXTURE = &quot;http://www.roblox.com/asset?id=55130256&quot;
local DISCONNECT_SOURCE_ICON_TEXTURE = &quot;http://www.roblox.com/asset?id=55130237&quot;
local DISCONNECT_SINK_ICON_TEXTURE = &quot;http://www.roblox.com/asset?id=55130219&quot;
local TAIL_TEXTURE = &quot;http://www.roblox.com/asset?id=55134078&quot;
local USE_BILLBOARD_GUI = true
local LAST_CLICK_TIME = 0
local CLICK_HELP_TIME_DELTA = .8
local SOURCE_BADGE_TEXTURE = &quot;http://www.roblox.com/asset?id=60730993&quot;
local SINK_BADGE_TEXTURE = &quot;http://www.roblox.com/asset?id=61334830&quot;

local ALL_TEXTURES = { SOURCE_BUTTON_ICON_TEXTURE, SOURCE_BUTTON_ICON_HOVER_TEXTURE,
&#9;&#9;SINK_BUTTON_ICON_TEXTURE, SINK_BUTTON_ICON_HOVER_TEXTURE,
&#9;&#9;DISCONNECT_ICON_HOVER_TEXTURE, DISCONNECT_SOURCE_ICON_TEXTURE,
&#9;&#9;DISCONNECT_SINK_ICON_TEXTURE, TAIL_TEXTURE, WIRE_TEXTURE, SOURCE_BADGE_TEXTURE, SINK_BADGE_TEXTURE}

for idx, asset in ipairs(ALL_TEXTURES) do
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(asset)
end

function clearSelection()
&#9;SELECTED_SOURCE = nil
&#9;SELECTED_SINK = nil
&#9;getLocalLasso().From = nil
&#9;getLocalLasso().To = nil
end

function clearScreenMessage()
&#9;if SCREEN_MESSAGE ~= nil then
&#9;&#9;SCREEN_MESSAGE:Remove()
&#9;&#9;SCREEN_MESSAGE = nil
&#9;end
end

function clearHover()
&#9;if LAST_HOVERED_PART ~= nil then
&#9;&#9;local lastHover = LAST_HOVERED_PART
&#9;&#9;if not ANNOTATIONS[lastHover] then
&#9;&#9;&#9;lastHover = findModel(lastHover)
&#9;&#9;end

&#9;&#9;ANNOTATIONS[lastHover].Transparency = BASE_ANNOTATION_TRANSPARENCY
&#9;&#9;if WIRING_PANEL_MAP[lastHover] ~= nil then
&#9;&#9;&#9;WIRING_PANEL_MAP[lastHover]:Remove()
&#9;&#9;&#9;WIRING_PANEL_MAP[lastHover] = nil
&#9;&#9;end
&#9;&#9;setPartWireTransparency(LAST_HOVERED_PART, BASE_WIRE_TRANSPARENCY, BASE_WIRE_RADIUS, &quot;&quot;)
&#9;end
end

function getPlayerGui()
&#9;if STATIC_PLAYER_GUI == nil then
&#9;&#9;STATIC_PLAYER_GUI = game.Players:GetPlayerFromCharacter(Tool.Parent).PlayerGui
&#9;end
&#9;return STATIC_PLAYER_GUI
end

function findMyBasePlate()
&#9;if isRestricted then
&#9;&#9;if STATIC_BASE_PLATE == nil then
&#9;&#9;&#9;local buildingAreas = game.Workspace.BuildingAreas:GetChildren()
&#9;&#9;&#9;for i = 1, #buildingAreas do
&#9;&#9;&#9;&#9;if buildingAreas[i]:FindFirstChild(&quot;Player&quot;) then
&#9;&#9;&#9;&#9;&#9;if buildingAreas[i].Player.Value == game.Players.LocalPlayer.Name then
&#9;&#9;&#9;&#9;&#9;&#9;waitForChild(buildingAreas[i],&quot;PlayerArea&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;STATIC_BASE_PLATE = buildingAreas[i].PlayerArea
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return STATIC_BASE_PLATE
&#9;end

&#9;return nil
end

function getLocalLasso()
&#9;if not game.Players.LocalPlayer.PlayerGui:FindFirstChild(&quot;lasso&quot;) then
&#9;&#9;local lasso = Instance.new(&quot;FloorWire&quot;)
&#9;&#9;lasso.Name = &quot;lasso&quot;
&#9;&#9;lasso.Parent = game.Players.LocalPlayer.PlayerGui
&#9;&#9;lasso.Color = BrickColor.new(&quot;Really black&quot;)
&#9;end

&#9;return game.Players.LocalPlayer.PlayerGui.lasso
end

function findModel(part)
&#9;if isRestricted then
&#9;&#9;local basePlate = findMyBasePlate()
&#9;&#9;while part ~= nil do
&#9;&#9;&#9;if part.className == &quot;Model&quot; and part.Name ~= basePlate.Name and part.Name ~= &quot;GarbageParts&quot; then
&#9;&#9;&#9;&#9;return part
&#9;&#9;&#9;elseif part.Name == basePlate.Name or part.Name == &quot;GarbageParts&quot; then
&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;end
&#9;&#9;&#9;part = part.Parent
&#9;&#9;end
&#9;else
&#9;&#9;local origPart = part
&#9;&#9;while part ~= nil do
&#9;&#9;&#9;if part.className == &quot;Model&quot; then
&#9;&#9;&#9;&#9;return part
&#9;&#9;&#9;elseif part.Name == &quot;Workspace&quot; or part.Name == &quot;game&quot; then
&#9;&#9;&#9;&#9;return origPart
&#9;&#9;&#9;end
&#9;&#9;&#9;part = part.Parent
&#9;&#9;end
&#9;end

&#9;return nil
end

function createVisualAnnotation(part, guiMain)
&#9;local selection = Instance.new(&quot;SelectionBox&quot;, guiMain)
&#9;selection.Name = &quot;Annotation&quot;
&#9;selection.Color = BrickColor.new(&quot;Lime green&quot;)
&#9;selection.Transparency = BASE_ANNOTATION_TRANSPARENCY
&#9;selection.Adornee = part
&#9;return selection
end

function isInteractivePart(obj)
&#9;if obj == nil then return false end
&#9;if obj:IsA(&quot;Part&quot;) then
&#9;&#9;for idx, child in ipairs(obj:GetChildren()) do
&#9;&#9;&#9;if child:IsA(&quot;CustomEvent&quot;) or child:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function applyToConnectorsWires(sourceOrSink, fn)
&#9;if sourceOrSink:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;for idx, recv in ipairs(sourceOrSink:GetAttachedReceivers()) do
&#9;&#9;&#9;fn(WIRE_LASSO_MAP[sourceOrSink][recv])
&#9;&#9;end
&#9;else
&#9;&#9;local source = sourceOrSink.Source
&#9;&#9;if source ~= nil then
&#9;&#9;&#9;fn(WIRE_LASSO_MAP[source][sourceOrSink])
&#9;&#9;end
&#9;end
end

function warnNoWireableParts()
&#9;local topHint = nil
&#9;pcall(function() topHint = getPlayerGui().Gui.Hints.CenterHint end)
&#9;
&#9;if topHint then
&#9;&#9;topHint.Add.Label.Value = &quot;No Wiring Parts!  Add Wiring Parts using the Stamper Tool.&quot;
&#9;&#9;topHint.Add.Width.Value = 580
&#9;&#9;topHint.Add.Time.Value = 10
&#9;&#9;topHint.Add.Disabled = true  -- flip it off then on, in case it&apos;s currently running.
&#9;&#9;topHint.Add.Disabled = false
&#9;end
end

function warnNotClickingWireablePart()
&#9;if getPlayerGui():FindFirstChild(&quot;CenterHint&quot;, true) then
&#9;&#9;local topHint = getPlayerGui().Gui.Hints.CenterHint
&#9;&#9;topHint.Add.Label.Value = &quot;This part isn&apos;t wireable :(&quot;
&#9;&#9;topHint.Add.Width.Value = 580
&#9;&#9;topHint.Add.Time.Value = 2
&#9;&#9;topHint.Add.Disabled = true  -- flip it off then on, in case it&apos;s currently running.
&#9;&#9;topHint.Add.Disabled = false
&#9;end
end

--------------------------------------------------------------------------------
-- Screen messages (when source/sink is selected)

function stylizeScreenMessageLabel(label, text)
&#9;label.Text = text
&#9;label.FontSize = Enum.FontSize.Size24
&#9;label.Font = Enum.Font.ArialBold
&#9;label.BackgroundTransparency = 1
&#9;label.BorderSizePixel = 0
&#9;label.Size = UDim2.new(0, label.TextBounds.x, 0, label.TextBounds.y)
&#9;label.TextColor3 = Color3.new(1, 1, 1)
end

function createSourceIcon(parent, precedingText)
&#9;local sourceIcon = Instance.new(&quot;ImageLabel&quot;, frame)
&#9;sourceIcon.Archivable = false
&#9;sourceIcon.Image = SOURCE_BUTTON_ICON_TEXTURE
&#9;sourceIcon.Size = UDim2.new(0, 30, 0, 30)
&#9;sourceIcon.BackgroundTransparency = 1
&#9;sourceIcon.BorderSizePixel = 0
&#9;sourceIcon.Position = UDim2.new(0,
&#9;&#9;&#9;precedingText.Position.X.Offset + precedingText.TextBounds.x + 5,
&#9;&#9;&#9;0, precedingText.Position.Y.Offset +
&#9;&#9;&#9;&#9;((precedingText.Size.Y.Offset - sourceIcon.Size.Y.Offset) / 2))
&#9;return sourceIcon
end

function createSinkIcon(parent, precedingText)
&#9;local sinkIcon = Instance.new(&quot;ImageLabel&quot;, frame)
&#9;sinkIcon.Archivable = false
&#9;sinkIcon.Image = SINK_BUTTON_ICON_TEXTURE
&#9;sinkIcon.Size = UDim2.new(0, 30, 0, 30)
&#9;sinkIcon.BackgroundTransparency = 1
&#9;sinkIcon.BorderSizePixel = 0
&#9;sinkIcon.Position = UDim2.new(0,
&#9;&#9;&#9;precedingText.Position.X.Offset + precedingText.TextBounds.x + 5,
&#9;&#9;&#9;0, precedingText.Position.Y.Offset +
&#9;&#9;&#9;&#9;((precedingText.Size.Y.Offset - sinkIcon.Size.Y.Offset) / 2))
&#9;return sinkIcon
end

function addToAllXPositions(objs, offset)
&#9;for idx, obj in ipairs(objs) do
&#9;&#9;pos = obj.Position
&#9;&#9;obj.Position = UDim2.new(0, pos.X.Offset + offset, 0, pos.Y.Offset)
&#9;end
end

function showSourceScreenMessage(source)
&#9;gui = Instance.new(&quot;ScreenGui&quot;, getPlayerGui())
&#9;gui.Archivable = false
&#9;frame = Instance.new(&quot;Frame&quot;, gui)
&#9;frame.Archivable = false
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local line1part1 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;line1part1.Archivable = false
&#9;stylizeScreenMessageLabel(line1part1, &quot;Choose a&quot;)

&#9;sinkIcon = createSinkIcon(frame, line1part1)
&#9;
&#9;line1part2 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;line1part2.Archivable = false
&#9;stylizeScreenMessageLabel(line1part2, &quot;receiver to trigger when&quot;)
&#9;line1part2.Position = UDim2.new(0,
&#9;&#9;sinkIcon.Position.X.Offset + sinkIcon.Size.X.Offset + 5, 0, 0)

&#9;line1height = math.max(sinkIcon.Size.Y.Offset, line1part1.Size.Y.Offset)

&#9;line2part1 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;line2part1.Archivable = false
&#9;stylizeScreenMessageLabel(line2part1, source.Parent.Name)
&#9;line2part1.Position = UDim2.new(0, 0, 0, line1height)
&#9;
&#9;sourceIcon = createSourceIcon(frame, line2part1)

&#9;line2part2 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line2part2, &quot;signals &quot;)
&#9;line2part2.Position = UDim2.new(0,
&#9;&#9;sourceIcon.Position.X.Offset + sourceIcon.Size.X.Offset + 5,
&#9;&#9;0, line2part1.Position.Y.Offset)

&#9;line2part3 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line2part3, source.Name)
&#9;line2part3.TextColor3 = SOURCE_BUTTON_TEXT_COLOR
&#9;line2part3.Position = UDim2.new(0,
&#9;&#9;line2part2.Position.X.Offset + line2part2.Size.X.Offset,
&#9;&#9;0, line2part1.Position.Y.Offset)

&#9;-- re-center
&#9;line1width = line1part2.Position.X.Offset + line1part2.Size.X.Offset
&#9;line2width = line2part3.Position.X.Offset + line2part3.Size.X.Offset

&#9;if line1width &gt; line2width then
&#9;&#9;local halfDelta = (line1width - line2width) / 2
&#9;&#9;addToAllXPositions({line2part1, sourceIcon, line2part2, line2part3}, halfDelta)
&#9;else
&#9;&#9;local halfDelta = (line2width - line1width) / 2
&#9;&#9;addToAllXPositions({line1part1, sinkIcon, line1part2}, halfDelta)
&#9;end

&#9;frame.Size = UDim2.new(0, math.max(line1width, line2width) + 15,
&#9;&#9;&#9;0, 2 * line1height + 5)
&#9;frame.Position = UDim2.new(.5, -frame.Size.X.Offset/2, 0, 0)

&#9;clearScreenMessage()
&#9;SCREEN_MESSAGE = gui
end

function showSinkScreenMessage(sink)
&#9;gui = Instance.new(&quot;ScreenGui&quot;, getPlayerGui())
&#9;frame = Instance.new(&quot;Frame&quot;, gui)
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local line1part1 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line1part1, &quot;Choose which&quot;)

&#9;local sourceIcon = createSourceIcon(frame, line1part1)
&#9;
&#9;line1part2 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line1part2, &quot;signal will cause&quot;)
&#9;line1part2.Position = UDim2.new(0,
&#9;&#9;sourceIcon.Position.X.Offset + sourceIcon.Size.X.Offset + 5, 0, 0)

&#9;local line1height = math.max(sourceIcon.Size.Y.Offset, line1part1.Size.Y.Offset)

&#9;line2part1 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line2part1, sink.Parent.Name .. &quot; to&quot;)
&#9;line2part1.Position = UDim2.new(0, 0, 0, line1height)
&#9;
&#9;local sinkIcon = createSinkIcon(frame, line2part1)

&#9;line2part2 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line2part2, sink.Name)
&#9;line2part2.TextColor3 = SINK_BUTTON_TEXT_COLOR
&#9;line2part2.Position = UDim2.new(0,
&#9;&#9;sinkIcon.Position.X.Offset + sinkIcon.Size.X.Offset,
&#9;&#9;0, line2part1.Position.Y.Offset)

&#9;-- re-center
&#9;line1width = line1part2.Position.X.Offset + line1part2.Size.X.Offset
&#9;line2width = line2part2.Position.X.Offset + line2part2.Size.X.Offset

&#9;if line1width &gt; line2width then
&#9;&#9;local halfDelta = (line1width - line2width) / 2
&#9;&#9;addToAllXPositions({line2part1, sinkIcon, line2part2}, halfDelta)
&#9;else
&#9;&#9;local halfDelta = (line2width - line1width) / 2
&#9;&#9;addToAllXPositions({line1part1, sourceIcon, line1part2}, halfDelta)
&#9;end

&#9;frame.Size = UDim2.new(0, math.max(line1width, line2width) + 15,
&#9;&#9;&#9;0, 2 * line1height + 5)
&#9;frame.Position = UDim2.new(.5, -frame.Size.X.Offset/2, 0, 0)

&#9;clearScreenMessage()
&#9;SCREEN_MESSAGE = gui
end

--------------------------------------------------------------------------------
-- Hover

function setPartWireTransparency(part, transparency, wireRadius, texture)
&#9;for idx, child in ipairs(part:GetChildren()) do
&#9;&#9;if child:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;&#9;for idx2, recv in ipairs(child:GetAttachedReceivers()) do
&#9;&#9;&#9;&#9;addWireUiIfNotAlreadyThere(child, recv)
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[child][recv].Transparency = transparency
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[child][recv].WireRadius = wireRadius
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[child][recv].Texture = texture
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[child][recv].Color = BrickColor.new(&quot;Really black&quot;)
&#9;&#9;&#9;end
&#9;&#9;elseif child:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;local source = child.Source
&#9;&#9;&#9;if source ~= nil then
&#9;&#9;&#9;&#9;addWireUiIfNotAlreadyThere(source, child)
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[source][child].Transparency = transparency
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[source][child].WireRadius = wireRadius
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[source][child].Texture = texture
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[source][child].Color = BrickColor.new(&quot;Really black&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function canHighlight(part,model)
&#9;if (KNOWN_SOURCE_PARTS[part] and SELECTED_SOURCE == nil) or (KNOWN_SINK_PARTS[part] and SELECTED_SINK == nil) then
&#9;&#9;return true, part
&#9;elseif (KNOWN_SOURCE_PARTS[model] and SELECTED_SOURCE == nil) or (KNOWN_SINK_PARTS[model] and SELECTED_SINK == nil) then
&#9;&#9;return true, model
&#9;end

&#9;return false, nil
end

function hoverListener(mouse)
&#9;if mouse.Target == nil then return end

&#9;local part = mouse.Target
&#9;local model = findModel(part)
&#9;if LAST_HOVERED_PART ~= part and findModel(LAST_HOVERED_PART) ~= model then
&#9;&#9;clearHover()
&#9;&#9;local highlight, instance = canHighlight(part,model)
&#9;&#9;if highlight then
&#9;&#9;&#9;LAST_HOVERED_PART = part
&#9;&#9;&#9;ANNOTATIONS[model].Transparency = 0
&#9;&#9;&#9;buildScreenPanel(model, mouse.X, mouse.Y)
&#9;&#9;&#9;setPartWireTransparency(part, 0, ENHANCED_WIRE_RADIUS, &quot;&quot;)
&#9;&#9;else
&#9;&#9;&#9;LAST_HOVERED_PART = nil
&#9;&#9;end

&#9;&#9;-- Point the temporary wire to the LAST_HOVERED_PART if not nil,
&#9;&#9;-- otherwise point it at the character
&#9;&#9;local otherEndOfWire = game.Players.LocalPlayer.Character.Humanoid.Torso
&#9;&#9;if LAST_HOVERED_PART ~= nil then
&#9;&#9;&#9;otherEndOfWire = LAST_HOVERED_PART
&#9;&#9;end
&#9;&#9;if SELECTED_SOURCE ~= nil then
&#9;&#9;&#9;getLocalLasso().To = otherEndOfWire
&#9;&#9;end
&#9;&#9;if SELECTED_SINK ~= nil then
&#9;&#9;&#9;getLocalLasso().From = otherEndOfWire
&#9;&#9;end
&#9;end
end

--------------------------------------------------------------------------------
-- Connect / Disconnect dialog

function addWireUiIfNotAlreadyThere(source, sink)
&#9;if WIRE_LASSO_MAP[source] == nil then
&#9;&#9;WIRE_LASSO_MAP[source] = {}
&#9;end
&#9;if WIRE_LASSO_MAP[source][sink] ~= nil then
&#9;&#9;return
&#9;end

&#9;pairLasso = Instance.new(&quot;FloorWire&quot;, getPlayerGui())
&#9;pairLasso.From = source.Parent
&#9;pairLasso.To = sink.Parent
&#9;pairLasso.Transparency = BASE_WIRE_TRANSPARENCY
&#9;pairLasso.Texture = &quot;&quot;
&#9;pairLasso.Name = WIRE_LASSO
&#9;pairLasso.Color = BrickColor.new(&quot;Really black&quot;)
&#9;WIRE_LASSO_MAP[source][sink] = pairLasso
end

function connectHelper(source, sink)
&#9;-- clear wires coming to sink
&#9;local old_source = sink.Source
&#9;if old_source ~= nil then
&#9;&#9;wire = WIRE_LASSO_MAP[old_source][sink]
&#9;&#9;if wire ~= nil then
&#9;&#9;&#9;wire:Remove()
&#9;&#9;&#9;WIRE_LASSO_MAP[old_source][sink] = nil
&#9;&#9;end
&#9;&#9;sink.Source = nil
&#9;end

&#9;sink.Source = source
&#9;addWireUiIfNotAlreadyThere(source, sink)
end

function makeSourceConnectCallback(source)
&#9;return function()
&#9;&#9;clearHover()
&#9;&#9;if SELECTED_SINK ~= nil then
&#9;&#9;&#9;connectHelper(source, SELECTED_SINK)
&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;clearScreenMessage()
&#9;&#9;&#9;for part, val in pairs(KNOWN_SINK_PARTS) do
&#9;&#9;&#9;&#9;local model = findModel(part)
&#9;&#9;&#9;&#9;ANNOTATIONS[model].Transparency = BASE_ANNOTATION_TRANSPARENCY
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;SELECTED_SOURCE = source
&#9;&#9;&#9;getLocalLasso().From = source.Parent
&#9;&#9;&#9;getLocalLasso().To = game.Players.LocalPlayer.Character.Humanoid.Torso
&#9;&#9;&#9;showSourceScreenMessage(SELECTED_SOURCE)
&#9;&#9;&#9;for part, val in pairs(KNOWN_SOURCE_PARTS) do
&#9;&#9;&#9;&#9;if not KNOWN_SINK_PARTS[part] then
&#9;&#9;&#9;&#9;&#9;local model = findModel(part)
&#9;&#9;&#9;&#9;&#9;ANNOTATIONS[model].Transparency = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function makeSinkConnectCallback(sink)
&#9;return function()
&#9;&#9;clearHover()
&#9;&#9;if SELECTED_SOURCE ~= nil then
&#9;&#9;&#9;connectHelper(SELECTED_SOURCE, sink)
&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;clearScreenMessage()
&#9;&#9;&#9;for part, val in pairs(KNOWN_SOURCE_PARTS) do
&#9;&#9;&#9;&#9;local model = findModel(part)
&#9;&#9;&#9;&#9;ANNOTATIONS[model].Transparency = BASE_ANNOTATION_TRANSPARENCY
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;SELECTED_SINK = sink
&#9;&#9;&#9;getLocalLasso().From = game.Players.LocalPlayer.Character.Humanoid.Torso
&#9;&#9;&#9;getLocalLasso().To = sink.Parent
&#9;&#9;&#9;showSinkScreenMessage(SELECTED_SINK)
&#9;&#9;&#9;for part, val in pairs(KNOWN_SINK_PARTS) do
&#9;&#9;&#9;&#9;if not KNOWN_SOURCE_PARTS[part] then
&#9;&#9;&#9;&#9;&#9;local model = findModel(part)
&#9;&#9;&#9;&#9;&#9;ANNOTATIONS[model].Transparency = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function makeControlButton(y_position, frame, sourceOrSink, textColor, iconImage, iconHoverImage, callbackBuilder)
&#9;local button = Instance.new(&quot;TextButton&quot;, frame)
&#9;button.Position = UDim2.new(.025, 0, 0, y_position)
&#9;button.Text = sourceOrSink.Name
&#9;button.TextXAlignment = Enum.TextXAlignment.Left
&#9;button.Style = Enum.ButtonStyle.Custom
&#9;button.BorderSizePixel = 0
&#9;button.BackgroundTransparency = 1
&#9;button.BackgroundColor3 = Color3.new(0, 0 ,0)
&#9;button.TextColor3 = textColor
&#9;button.Font = Enum.Font.ArialBold
&#9;button.FontSize = Enum.FontSize.Size18
&#9;button.ZIndex = 2
&#9;button.Size = UDim2.new(.95, 0, 0, button.TextBounds.y)
&#9;
&#9;local icon = Instance.new(&quot;ImageLabel&quot;, button)
&#9;icon.Image = iconImage
&#9;icon.ZIndex = 2
&#9;icon.Position = UDim2.new(0, button.TextBounds.x + 10, 0, -8)
&#9;icon.Size = UDim2.new(0, 30, 0 , 30)
&#9;icon.BackgroundTransparency = 1

&#9;button.MouseEnter:connect(function()
&#9;&#9;applyToConnectorsWires(sourceOrSink, function(wire)
&#9;&#9;&#9;wire.Texture = WIRE_TEXTURE
&#9;&#9;&#9;wire.Velocity = 2
&#9;&#9;end)
&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;button.TextColor3 = BUTTON_HOVER_TEXT_COLOR
&#9;&#9;icon.Image = iconHoverImage
&#9;end)
&#9;local leaveCallback = function()
&#9;&#9;applyToConnectorsWires(sourceOrSink, function(wire)
&#9;&#9;&#9;wire.Texture = &quot;&quot;
&#9;&#9;end)
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.TextColor3 = textColor
&#9;&#9;icon.Image = iconImage
&#9;end
&#9;button.MouseLeave:connect(leaveCallback)
&#9;button.MouseButton1Click:connect(function()
&#9;&#9;callbackBuilder(sourceOrSink)()
&#9;&#9;leaveCallback()
&#9;end)
&#9;return button
end

function makeDisconnectCallback(source, sink)
&#9;clearHover()
&#9;sink.Source = nil
&#9;if WIRE_LASSO_MAP[source] ~= nil then
&#9;&#9;lassoUi = WIRE_LASSO_MAP[source][sink]
&#9;&#9;if lassoUi ~= nil then
&#9;&#9;&#9;lassoUi:Remove()
&#9;&#9;&#9;WIRE_LASSO_MAP[source][sink] = nil
&#9;&#9;end
&#9;end
end

function makeDisconnectButton(y_position, frame, localConnector, foreignConnector, textColor, iconImage)
&#9;local source = nil
&#9;local sink = nil
&#9;if localConnector:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;source = localConnector
&#9;&#9;sink = foreignConnector
&#9;else
&#9;&#9;source = foreignConnector
&#9;&#9;sink = localConnector
&#9;end

&#9;local button = Instance.new(&quot;TextButton&quot;, frame)
&#9;button.Position = UDim2.new(0, 17, 0, y_position)
&#9;button.Text = foreignConnector.Name .. &quot; (&quot; .. foreignConnector.Parent.Name .. &quot;)&quot; 
&#9;button.TextXAlignment = Enum.TextXAlignment.Left
&#9;button.Style = Enum.ButtonStyle.Custom
&#9;button.BackgroundTransparency = 1
&#9;button.BackgroundColor3 = Color3.new(0, 0 ,0)
&#9;button.TextColor3 = textColor
&#9;button.BorderSizePixel = 0
&#9;button.Font = Enum.Font.Arial
&#9;button.FontSize = Enum.FontSize.Size18
&#9;button.ZIndex = 3
&#9;button.Size = UDim2.new(.95, -10, 0, button.TextBounds.y + 2)
&#9;
&#9;local icon = Instance.new(&quot;ImageLabel&quot;, button)
&#9;icon.Image = iconImage
&#9;icon.Parent = button
&#9;icon.Position = UDim2.new(0, button.TextBounds.x + 10, 0, 2)
&#9;icon.Size = UDim2.new(0, 15, 0 , 15)
&#9;icon.BackgroundTransparency = 1

&#9;local buttonCons = {}

&#9;table.insert(buttonCons,
&#9;&#9;button.MouseButton1Click:connect(function() 
&#9;&#9;&#9;makeDisconnectCallback(source, sink)
&#9;&#9;end)
&#9;)
&#9;table.insert(buttonCons,
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;button.TextColor3 = BUTTON_HOVER_TEXT_COLOR
&#9;&#9;&#9;icon.Image = DISCONNECT_ICON_HOVER_TEXTURE
&#9;&#9;&#9;WIRE_LASSO_MAP[source][sink].Color = BrickColor.new(&quot;Really red&quot;)
&#9;&#9;end)
&#9;)
&#9;table.insert(buttonCons,
&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.TextColor3 = textColor
&#9;&#9;icon.Image = iconImage
&#9;&#9;WIRE_LASSO_MAP[source][sink].Color = BrickColor.new(&quot;Really black&quot;)
&#9;end)
&#9;)

&#9;table.insert(buttonCons,
&#9;&#9;button.AncestryChanged:connect(function(child,parent)
&#9;&#9;&#9;if parent == nil then
&#9;&#9;&#9;&#9;for i = 1, #buttonCons do
&#9;&#9;&#9;&#9;&#9;buttonCons[i]:disconnect()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;)

&#9;return button
end

function getPartSourcesAndSinks(part, sources,sinks)
&#9;for idx, child in ipairs(part:GetChildren()) do
&#9;&#9;if child:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;&#9;table.insert(sources, child)
&#9;&#9;elseif child:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;table.insert(sinks, child)
&#9;&#9;end
&#9;end
end

function getSourcesAndSinks(instance,sources,sinks)
&#9;if instance:IsA(&quot;BasePart&quot;) then
&#9;&#9;getPartSourcesAndSinks(instance, sources,sinks)
&#9;elseif instance:IsA(&quot;Model&quot;) then
&#9;&#9;local modelChildren = instance:GetChildren()
&#9;&#9;for i = 1, #modelChildren do
&#9;&#9;&#9;if modelChildren[i]:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;&#9;getPartSourcesAndSinks(modelChildren[i],sources,sinks)
&#9;&#9;&#9;elseif modelChildren[i]:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;&#9;getSourcesAndSinks(modelChildren[i],sources,sinks)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function findFirstConnector(node)
&#9;if node:IsA(&quot;BasePart&quot;) then
&#9;&#9;for idx, child in ipairs(node:GetChildren()) do
&#9;&#9;&#9;if connector == nil and (child:IsA(&quot;CustomEvent&quot;) or child:IsA(&quot;CustomEventReceiver&quot;)) then
&#9;&#9;&#9;&#9;return child
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;local children = node:GetChildren()
&#9;&#9;if #children == 0 then
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;local subConnector = findFirstConnector(children[i])
&#9;&#9;&#9;if subConnector then return subConnector end
&#9;&#9;end
&#9;end
end

function buildScreenPanel(part, x, y)
&#9;sources = {}
&#9;sinks = {}
&#9;getSourcesAndSinks(part,sources,sinks)

&#9;local gui = nil
&#9;local mouseFrame = nil
&#9;if USE_BILLBOARD_GUI then
&#9;&#9;gui = Instance.new(&quot;BillboardGui&quot;, getPlayerGui())
&#9;&#9;gui.Name = &quot;WiringGui&quot;
&#9;&#9;gui.StudsOffset = Vector3.new(0, 1.5, 0)
&#9;&#9;gui.ExtentsOffset = Vector3.new(0,0, 0)
&#9;&#9;gui.Adornee = part
&#9;&#9;gui.Active = true
&#9;&#9;gui.AlwaysOnTop = true
&#9;else 
&#9;&#9;gui = Instance.new(&quot;ScreenGui&quot;, getPlayerGui())
&#9;end

&#9;frame = Instance.new(&quot;Frame&quot;, gui)
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.ZIndex = 1
&#9;frame.Active = true

&#9;local maxWidth = 0
&#9;local y_position = 5

&#9;if SELECTED_SOURCE == nil then
&#9;&#9;for idx, source in ipairs(sources) do
&#9;&#9;&#9;local button = makeControlButton(y_position, frame, source, SOURCE_BUTTON_TEXT_COLOR,
&#9;&#9;&#9;&#9;&#9;SOURCE_BUTTON_ICON_TEXTURE, SOURCE_BUTTON_ICON_HOVER_TEXTURE,
&#9;&#9;&#9;&#9;&#9;makeSourceConnectCallback)
&#9;&#9;&#9;maxWidth = math.max(1.25 * (button.TextBounds.x + BUTTON_ICON_WIDTH), maxWidth)
&#9;&#9;&#9;y_position = y_position + button.TextBounds.y

&#9;&#9;&#9;receivers = source:GetAttachedReceivers()
&#9;&#9;&#9;for sub_idx, receiver in ipairs(receivers) do
&#9;&#9;&#9;&#9;y_position = y_position + 2
&#9;&#9;&#9;&#9;addWireUiIfNotAlreadyThere(source, receiver)
&#9;&#9;&#9;&#9;local button = makeDisconnectButton(y_position, frame, source, receiver,
&#9;&#9;&#9;&#9;&#9;SINK_BUTTON_TEXT_COLOR, DISCONNECT_SINK_ICON_TEXTURE)
&#9;&#9;&#9;&#9;y_position = y_position + button.TextBounds.y
&#9;&#9;&#9;&#9;maxWidth = math.max(1.15 * (button.TextBounds.x + 17 + 25), maxWidth)
&#9;&#9;&#9;end
&#9;&#9;&#9;y_position = y_position + 5
&#9;&#9;end
&#9;end

&#9;if SELECTED_SINK == nil then
&#9;&#9;for idx, sink in ipairs(sinks) do
&#9;&#9;&#9;local button = makeControlButton(y_position, frame, sink, SINK_BUTTON_TEXT_COLOR,
&#9;&#9;&#9;&#9;&#9;SINK_BUTTON_ICON_TEXTURE, SINK_BUTTON_ICON_HOVER_TEXTURE,
&#9;&#9;&#9;&#9;&#9;makeSinkConnectCallback)
&#9;&#9;&#9;maxWidth = math.max(1.25 * (button.TextBounds.x + BUTTON_ICON_WIDTH), maxWidth)
&#9;&#9;&#9;y_position = y_position + button.TextBounds.y

&#9;&#9;&#9;local sender = sink.Source
&#9;&#9;&#9;if sender ~= nil then
&#9;&#9;&#9;&#9;y_position = y_position + 2
&#9;&#9;&#9;&#9;-- addWire takes source first
&#9;&#9;&#9;&#9;addWireUiIfNotAlreadyThere(sender, sink)
&#9;&#9;&#9;&#9;local button = makeDisconnectButton(y_position, frame, sink, sender,
&#9;&#9;&#9;&#9;&#9;SOURCE_BUTTON_TEXT_COLOR, DISCONNECT_SOURCE_ICON_TEXTURE)
&#9;&#9;&#9;&#9;y_position = y_position + button.TextBounds.y
&#9;&#9;&#9;&#9;maxWidth = math.max(1.15 * (button.TextBounds.x + 17 + 25), maxWidth)
&#9;&#9;&#9;end
&#9;&#9;&#9;y_position = y_position + 5
&#9;&#9;end
&#9;end

&#9;-- set size and position
&#9;if not getPlayerGui():FindFirstChild(&quot;ScreenGui&quot;) then
&#9;&#9;local screenGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;screenGui.Parent = getPlayerGui()
&#9;end

&#9;local screenSize = getPlayerGui().ScreenGui.AbsoluteSize
&#9;local menuWidth = maxWidth
&#9;local menuHeight = y_position + 17.5
&#9;if USE_BILLBOARD_GUI then

&#9;&#9;
&#9;&#9;local size = Vector3.new(0,0,0)
&#9;&#9;if gui.Adornee:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;size = gui.Adornee.Size
&#9;&#9;elseif gui.Adornee:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;size = gui.Adornee:GetModelSize()
&#9;&#9;end

&#9;&#9;local xSize= size.X
&#9;&#9;if size.Y &gt; xSize then
&#9;&#9;&#9;xSize = size.Y
&#9;&#9;end

&#9;&#9;gui.Size = UDim2.new(0, menuWidth,0,menuHeight + 150)
&#9;&#9;gui.SizeOffset = Vector2.new(0, -50.0 / (menuHeight + 150));
&#9;&#9;
&#9;&#9;local tail = Instance.new(&quot;ImageLabel&quot;, frame)
&#9;&#9;tail.Size = UDim2.new(0, 32, 0, 32)
&#9;&#9;tail.Position = UDim2.new(.5, -16, 1, 8)
&#9;&#9;tail.Image = TAIL_TEXTURE
&#9;&#9;tail.BackgroundTransparency = 1
&#9;&#9;tail.Visible = true

&#9;&#9;f = Instance.new(&quot;Frame&quot;, gui)
&#9;&#9;f.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;f.BackgroundTransparency = 1
&#9;&#9;f.ZIndex = 1
&#9;&#9;f.Active = true
&#9;&#9;b = Instance.new(&quot;TextButton&quot;, f)
&#9;&#9;b.ZIndex = 1
&#9;&#9;b.BackgroundTransparency = 1
&#9;&#9;b.Text = &quot;&quot;
&#9;&#9;b.BorderSizePixel = 0
&#9;&#9;b.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;b.MouseButton1Click:connect(function()
&#9;&#9;&#9;local foundConnector = findFirstConnector(findModel(LAST_HOVERED_PART))
&#9;&#9;&#9;if foundConnector ~= nil and foundConnector:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;&#9;&#9;makeSourceConnectCallback(foundConnector)()
&#9;&#9;&#9;elseif foundConnector ~= nil and foundConnector:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;&#9;makeSinkConnectCallback(foundConnector)()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;else
&#9;&#9;x = math.min(x - 9, screenSize.x - menuWidth) 
&#9;&#9;y = math.min(y - 9, screenSize.y - menuHeight)
&#9;&#9;frame.Position = UDim2.new(0, x, 0, y)
&#9;end

&#9;frame.Size = UDim2.new(0, menuWidth, 0, menuHeight)
&#9;frame.Position = UDim2.new(0.5,-menuWidth/2,0.05,0)
&#9;WIRING_PANEL_MAP[part] = gui
end

function inBaseplate(instance)
&#9;if instance == STATIC_BASE_PLATE then return true end

&#9;local instanceCopy = instance

&#9;while instanceCopy and (instanceCopy.Parent ~= nil or instanceCopy.Parent ~= game.Workspace) do
&#9;&#9;if instanceCopy.Parent == STATIC_BASE_PLATE then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;instanceCopy = instanceCopy.Parent
&#9;end

&#9;return false
end

--------------------------------------------------------------------------------
-- Tool.Equipped/Unequipped

Tool.Equipped:connect(function(mouse)
&#9;local player = game.Players:getPlayerFromCharacter(Tool.Parent)
&#9;if not player then return end

&#9;if playerOwner.Value and playerOwner.Value ~= player then return end
&#9;playerOwner.Value = player

&#9;playerGui = getPlayerGui()
&#9;LAST_HOVERED_PART = nil

&#9;if isRestricted then
&#9;&#9;root = findMyBasePlate()
&#9;else
&#9;&#9;root = game.Workspace
&#9;end

&#9;local interactiveCount = setUpConfigurationService()

&#9;if not interactiveCount or interactiveCount == 0 then
&#9;&#9;warnNoWireableParts()
&#9;end

&#9;getLocalLasso().Texture = WIRE_TEXTURE
&#9;getLocalLasso().WireRadius = ENHANCED_WIRE_RADIUS
&#9;clearSelection()

&#9;mouse.Icon = &quot;http://www.roblox.com/asset?id=66887773&quot;
&#9;mouseMoveCon = mouse.Move:connect(function() hoverListener(mouse) end)
&#9;mouseButtonDownCon = mouse.Button1Down:connect(function()
&#9;&#9;if LAST_HOVERED_PART ~= nil then return end

&#9;&#9;clearSelection()
&#9;&#9;clearScreenMessage()
&#9;&#9;clearHover()
&#9;&#9;local annotationCount = 0
&#9;&#9;for part, annotation in pairs(ANNOTATIONS) do
&#9;&#9;&#9;annotation.Transparency = BASE_ANNOTATION_TRANSPARENCY
&#9;&#9;&#9;annotationCount = annotationCount + 1
&#9;&#9;end
&#9;&#9;if annotationCount == 0 then
&#9;&#9;&#9;warnNoWireableParts()
&#9;&#9;elseif time() - LAST_CLICK_TIME &lt; CLICK_HELP_TIME_DELTA then
&#9;&#9;&#9;warnNotClickingWireablePart()
&#9;&#9;end
&#9;&#9;LAST_CLICK_TIME = time()
&#9;end)
&#9;-- TODO: onkeydown/onmouse2down, prevent hover from triggering
&#9;-- until the up event comes
end)

Tool.Unequipped:connect(function()
&#9;playerGui = getPlayerGui()

&#9;destroyConfigurationService()

&#9;if mouseMoveCon then mouseMoveCon:disconnect() end
&#9;if mouseButtonDownCon then mouseButtonDownCon:disconnect() end

&#9;if playerGui:FindFirstChild(&quot;CenterHint&quot;, true) then
&#9;&#9;local centerHint = getPlayerGui().Gui.Hints.CenterHint
&#9;&#9;centerHint.Delete.Disabled = false
&#9;end

&#9;-- TODO: simplify these side effects
&#9;-- call clearHover before removing annotations, because
&#9;-- clear hover resets annotation boxes. Also before clearing
&#9;-- lassos because this may create lassos
&#9;clearHover()

&#9;for part, gui in pairs(WIRING_PANEL_MAP) do
&#9;&#9;if gui then gui:Remove() end
&#9;end
&#9;WIRING_PANEL_MAP = {}

&#9;for source, submap in pairs(WIRE_LASSO_MAP) do
&#9;&#9;for sink, wire in pairs(submap) do
&#9;&#9;&#9;wire:Remove()
&#9;&#9;end
&#9;end
&#9;WIRE_LASSO_MAP = {}

&#9;for k,box in pairs(ANNOTATIONS) do
&#9;&#9;box:Remove()
&#9;end
&#9;ANNOTATIONS = {}

&#9;KNOWN_SOURCE_PARTS = {}
&#9;KNOWN_SINK_PARTS = {}

&#9;clearSelection()
&#9;clearScreenMessage()
&#9;LAST_HOVERED_PART = nil
end)

function findBillboard(guiTable)
&#9;if not guiTable then return end

&#9;for i = 1, #guiTable do
&#9;&#9;if guiTable[i] and guiTable[i]:IsA(&quot;BillboardGui&quot;) then
&#9;&#9;&#9;return guiTable[i]
&#9;&#9;end
&#9;end
end

function getBillboard(adornee)
&#9;local guiKey = adornee

&#9;
&#9;local billboard = findBillboard(adornmentTable[guiKey])
&#9;if not billboard then
&#9;&#9;local screen = Instance.new(&quot;BillboardGui&quot;)
&#9;&#9;screen.Name = adornee.Name .. &quot;BadgeGUI&quot;
&#9;&#9;screen.Size = UDim2.new(1.5,0,1.5,0)
&#9;&#9;screen.Enabled = true
&#9;&#9;screen.Active = true
&#9;&#9;screen.AlwaysOnTop = true
&#9;&#9;screen.ExtentsOffset = Vector3.new(0,0,0)
&#9;&#9;screen.Adornee = adornee
&#9;&#9;screen.Parent = game.Players.LocalPlayer.PlayerGui

&#9;&#9;if not adornmentTable[guiKey] then return end
&#9;&#9;table.insert(adornmentTable[guiKey],screen)

&#9;&#9;local badgeFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;badgeFrame.Name = &quot;BadgeFrame&quot;
&#9;&#9;badgeFrame.Size = UDim2.new(2,0,1,0)
&#9;&#9;badgeFrame.Position = UDim2.new(-0.5,0,0,0)
&#9;&#9;badgeFrame.BackgroundTransparency = 1
&#9;&#9;badgeFrame.Parent = screen

&#9;&#9;return screen
&#9;end

&#9;return billboard
end

function repositionBadges(badgeFrame)
&#9;local badges = badgeFrame:GetChildren()
&#9;if #badges == 1 then
&#9;&#9;badges[1].Position = UDim2.new(0.25,0,0,0)
&#9;elseif #badges == 2 then
&#9;&#9;badges[1].Position = UDim2.new(0,0,0,0)
&#9;&#9;badges[2].Position = UDim2.new(0.5,0,0)
&#9;end
end

function hasBadge(adornee, type)
&#9;local screen = getBillboard(adornee)
&#9;return screen:FindFirstChild(type .. &quot;Badge&quot;,true)
end

function removeBadge(adornee, type)
&#9;local screen = getBillboard(adornee)
&#9;local badge = screen:FindFirstChild(type .. &quot;Badge&quot;,true)
&#9;if badge then badge:remove() end
end

function createBadge(adornee,type)
&#9;local screen = getBillboard(adornee)

&#9;local wiringBadge = Instance.new(&quot;ImageLabel&quot;)
&#9;wiringBadge.Name = type .. &quot;Badge&quot;
&#9;wiringBadge.BackgroundTransparency = 1
&#9;if type == &quot;Receiver&quot; then
&#9;&#9;wiringBadge.Image = SOURCE_BADGE_TEXTURE
&#9;else
&#9;&#9;wiringBadge.Image = SINK_BADGE_TEXTURE
&#9;end

&#9;wiringBadge.Position = UDim2.new(0.25,0,0,0)
&#9;wiringBadge.Size = UDim2.new(0.5,0,1,0)
&#9;wiringBadge.Parent = screen.BadgeFrame
&#9;wiringBadge.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if wiringBadge.AbsoluteSize.X &lt; 10 then
&#9;&#9;&#9;&#9;wiringBadge.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;wiringBadge.Visible = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)

&#9;repositionBadges(screen.BadgeFrame)
end

function upAdorneeCount(adornee,type)
&#9;local typeLower = string.lower(type)
&#9;if typeLower == &quot;receiver&quot; then
&#9;&#9;if not receiverBadgeCount[adornee] then
&#9;&#9;&#9;receiverBadgeCount[adornee] = 1
&#9;&#9;else
&#9;&#9;&#9;receiverBadgeCount[adornee] = receiverBadgeCount[adornee] + 1
&#9;&#9;end
&#9;elseif typeLower == &quot;event&quot; then
&#9;&#9;if not eventBadgeCount[adornee] then
&#9;&#9;&#9;eventBadgeCount[adornee] = 1
&#9;&#9;else
&#9;&#9;&#9;eventBadgeCount[adornee] = eventBadgeCount[adornee] + 1
&#9;&#9;end
&#9;end
end

function downAdorneeCount(adornee,type)
&#9;local typeLower = string.lower(type)
&#9;if typeLower == &quot;receiver&quot; then
&#9;&#9;if receiverBadgeCount[adornee] then
&#9;&#9;&#9;receiverBadgeCount[adornee] = receiverBadgeCount[adornee] - 1
&#9;&#9;&#9;if receiverBadgeCount[adornee] &lt; 1 then
&#9;&#9;&#9;&#9;receiverBadgeCount[adornee] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;elseif typeLower == &quot;event&quot; then
&#9;&#9;if eventBadgeCount[adornee] then
&#9;&#9;&#9;eventBadgeCount[adornee] = eventBadgeCount[adornee] - 1
&#9;&#9;&#9;if eventBadgeCount[adornee] &lt; 1 then
&#9;&#9;&#9;&#9;eventBadgeCount[adornee] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function createAdornment(adornee,adornColor,type)
&#9;upAdorneeCount(adornee,type)

&#9;if receiverBadgeCount[adornee] == 1 or eventBadgeCount[adornee] == 1 then
&#9;&#9;local box = Instance.new(&quot;SelectionBox&quot;)
&#9;&#9;box.Color = adornColor
&#9;&#9;box.Name = adornee.Name .. &quot;Selection&quot; .. tostring(type)
&#9;&#9;box.Adornee = adornee
&#9;&#9;box.Transparency = 0.5
&#9;&#9;box.Parent = game.Players.LocalPlayer.PlayerGui
&#9;&#9;if not adornmentTable[adornee] then
&#9;&#9;&#9;adornmentTable[adornee] = {}
&#9;&#9;end

&#9;&#9;ANNOTATIONS[adornee] = box
&#9;&#9;table.insert(adornmentTable[adornee],box)

&#9;&#9;if not hasBadge(adornee,type) then
&#9;&#9;&#9;createBadge(adornee,type)
&#9;&#9;end
&#9;end
end

function doRemoveAdornment(adornee, type)
&#9;local key = adornee
&#9;if not adornmentTable[key] then return end
&#9;for i = 1, #adornmentTable[key] do
&#9;&#9;if adornmentTable[key] and adornmentTable[key][i] then
&#9;&#9;&#9;if string.find(adornmentTable[key][i].Name,type) then
&#9;&#9;&#9;&#9;adornmentTable[key][i]:remove()
&#9;&#9;&#9;&#9;adornmentTable[key][i] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function removeAdornment(adornee, type)
&#9;downAdorneeCount(adornee,type)

&#9;if type == &quot;Receiver&quot; then
&#9;&#9;if not receiverBadgeCount[adornee]then
&#9;&#9;&#9;removeBadge(adornee, type)
&#9;&#9;&#9;doRemoveAdornment(adornee, type)
&#9;&#9;end
&#9;elseif type == &quot;Event&quot; then
&#9;&#9;if not eventBadgeCount[adornee] then
&#9;&#9;&#9;removeBadge(adornee, type)
&#9;&#9;&#9;doRemoveAdornment(adornee, type)
&#9;&#9;end
&#9;end
end

function eventReceiverAdded(receiver,wirePartCount)
&#9;if isRestricted then
&#9;&#9;if not inBaseplate(receiver) then return wirePartCount end
&#9;end
&#9;receiverTable[receiver] = findModel(receiver.Parent)
&#9;createAdornment(receiverTable[receiver], BrickColor.new(&quot;Lime green&quot;), &quot;Receiver&quot;)
&#9;setPartWireTransparency(receiver.Parent, BASE_WIRE_TRANSPARENCY, BASE_WIRE_RADIUS, &quot;&quot;)

&#9;KNOWN_SINK_PARTS[receiver.Parent] = true
&#9;KNOWN_SINK_PARTS[receiverTable[receiver]]= true

&#9;if wirePartCount then
&#9;&#9;return wirePartCount + 1
&#9;else
&#9;&#9;return 0
&#9;end

end

function eventAdded(event,wirePartCount)
&#9;if isRestricted then
&#9;&#9;if not inBaseplate(event) then return wirePartCount end
&#9;end
&#9;eventTable[event] = findModel(event.Parent)
&#9;createAdornment(eventTable[event], BrickColor.new(&quot;Bright orange&quot;), &quot;Event&quot;)
&#9;setPartWireTransparency(event.Parent, BASE_WIRE_TRANSPARENCY, BASE_WIRE_RADIUS, &quot;&quot;)

&#9;KNOWN_SOURCE_PARTS[event.Parent] = true
&#9;KNOWN_SOURCE_PARTS[eventTable[event]]= true

&#9;if wirePartCount then
&#9;&#9;return wirePartCount + 1
&#9;else
&#9;&#9;return 0
&#9;end
end

function eventReceiverRemoved(receiver)
&#9;if not receiverTable[receiver] then return end

&#9;KNOWN_SINK_PARTS[receiver.Parent] = false
&#9;KNOWN_SINK_PARTS[receiverTable[receiver]]= false

&#9;removeAdornment(receiverTable[receiver],&quot;Receiver&quot;)
&#9;receiverTable[receiver] = nil
end

function eventRemoved(event)
&#9;if not eventTable[event] then return end

&#9;KNOWN_SOURCE_PARTS[event.Parent] = false
&#9;KNOWN_SOURCE_PARTS[eventTable[event]]= false

&#9;removeAdornment(eventTable[event], &quot;Event&quot;)
&#9;eventTable[event] = nil
end

function setUpConfigurationService()
&#9;local wirePartCount = 0
&#9;ServiceConnections = {}
&#9;local collectionService = game:GetService(&quot;CollectionService&quot;)

&#9;-- first lets check if anything already exists
&#9;local receivers = collectionService:GetCollection(&quot;CustomEventReceiver&quot;)
&#9;if receivers then
&#9;&#9;for pos, receiver in pairs(receivers) do
&#9;&#9;&#9;wirePartCount = eventReceiverAdded(receiver, wirePartCount)
&#9;&#9;end
&#9;end

&#9;local events = collectionService:GetCollection(&quot;CustomEvent&quot;)
&#9;if events then
&#9;&#9;for pos, event in pairs(events) do
&#9;&#9;&#9;wirePartCount = eventAdded(event, wirePartCount)
&#9;&#9;end
&#9;end

&#9;-- Now lets listen for any future additions/removals
&#9;ServiceConnections[#ServiceConnections+1] = collectionService.ItemAdded:connect(function(instance)
&#9;&#9;if instance:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;eventReceiverAdded(instance)
&#9;&#9;elseif instance:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;&#9;eventAdded(instance)
&#9;&#9;end 
&#9;end)
&#9;ServiceConnections[#ServiceConnections+1] = collectionService.ItemRemoved:connect(function(instance)
&#9;&#9;if instance:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;eventReceiverRemoved(instance)
&#9;&#9;elseif instance:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;&#9;eventRemoved(instance)
&#9;&#9;end
&#9;end)

&#9;return wirePartCount
end

function destroyConfigurationService()
&#9;-- first lets destroy the collection service
&#9;for index, connection in pairs(ServiceConnections) do
&#9;&#9;connection:disconnect()
&#9;end
&#9;ServiceConnections = {}

&#9;-- now lets remove all of our collection service objects that were generated
&#9;for event, object in pairs(eventTable) do
&#9;&#9;eventRemoved(event)
&#9;end
&#9;for eventReceiver, object in pairs(receiverTable) do
&#9;&#9;eventReceiverRemoved(eventReceiver)
&#9;end
end

</ProtectedString>
				</Properties>
			</Item>
			<Item class="ObjectValue" referent="RBX5">
				<Properties>
					<string name="Name">PlayerOwner</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX6">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>0.349999994</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">StamperTool</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset/?id=59102781</url></Content>
				<string name="ToolTip"></string>
			</Properties>
			<Item class="Part" referent="RBX7">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">194</int>
					<CoordinateFrame name="CFrame">
						<X>108.625</X>
						<Y>217.387451</Y>
						<Z>174.375</Z>
						<R00>0.965850174</R00>
						<R01>-0.00282251695</R01>
						<R02>0.259085894</R02>
						<R10>0.00292619411</R10>
						<R11>0.999995708</R11>
						<R12>-1.45127997e-005</R12>
						<R20>-0.259084761</R20>
						<R21>0.000772152911</R21>
						<R22>0.965854287</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0.0115669128</X>
						<Y>0.000200518931</Y>
						<Z>0.00293493667</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0.000638026104</X>
						<Y>-0.00653974386</Y>
						<Z>-0.00109542918</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.400000006</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX8">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=42163552</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>0.899999976</X>
							<Y>0.899999976</Y>
							<Z>0.899999976</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=42163513</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="ObjectValue" referent="RBX9">
				<Properties>
					<string name="Name">PlayerOwner</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="ObjectValue" referent="RBX10">
				<Properties>
					<string name="Name">SavedState</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX11">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">LuaGlobalVariables</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Model" referent="RBX12">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">InsertAsset</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="StringValue" referent="RBX13">
						<Properties>
							<string name="Name">AssetName</string>
							<string name="Value"></string>
						</Properties>
					</Item>
					<Item class="IntValue" referent="RBX14">
						<Properties>
							<string name="Name">AssetId</string>
							<int name="Value">0</int>
						</Properties>
					</Item>
					<Item class="StringValue" referent="RBX15">
						<Properties>
							<string name="Name">Image</string>
							<string name="Value"></string>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX16">
						<Properties>
							<string name="Name">StampMode</string>
							<bool name="Value">true</bool>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX17">
						<Properties>
							<string name="Name">Updated</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
				</Item>
				<Item class="BoolValue" referent="RBX18">
					<Properties>
						<string name="Name">SwitchLoaderToDialog</string>
						<bool name="Value">false</bool>
					</Properties>
					<Item class="StringValue" referent="RBX19">
						<Properties>
							<string name="Name">DialogType</string>
							<string name="Value">Stamp</string>
						</Properties>
					</Item>
					<Item class="StringValue" referent="RBX20">
						<Properties>
							<string name="Name">AssetImage</string>
							<string name="Value">nil</string>
						</Properties>
					</Item>
				</Item>
				<Item class="BoolValue" referent="RBX21">
					<Properties>
						<string name="Name">ShowInvalidPlacement</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX22">
					<Properties>
						<string name="Name">ShowMaxedOut</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX23">
					<Properties>
						<string name="Name">SwitchMode</string>
						<bool name="Value">false</bool>
					</Properties>
					<Item class="StringValue" referent="RBX24">
						<Properties>
							<string name="Name">Mode</string>
							<string name="Value"></string>
						</Properties>
					</Item>
				</Item>
				<Item class="BoolValue" referent="RBX25">
					<Properties>
						<string name="Name">Stamped</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX26">
					<Properties>
						<string name="Name">Moving</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX27">
					<Properties>
						<string name="Name">ShowAdminCategories</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX28">
					<Properties>
						<string name="Name">userIDs</string>
						<int name="Value">6</int>
					</Properties>
					<Item class="IntValue" referent="RBX29">
						<Properties>
							<string name="Name">userID</string>
							<int name="Value">11744447</int>
						</Properties>
					</Item>
					<Item class="IntValue" referent="RBX30">
						<Properties>
							<string name="Name">userID</string>
							<int name="Value">18881789</int>
						</Properties>
					</Item>
					<Item class="IntValue" referent="RBX31">
						<Properties>
							<string name="Name">userID</string>
							<int name="Value">18881808</int>
						</Properties>
					</Item>
					<Item class="IntValue" referent="RBX32">
						<Properties>
							<string name="Name">userID</string>
							<int name="Value">18881829</int>
						</Properties>
					</Item>
					<Item class="IntValue" referent="RBX33">
						<Properties>
							<string name="Name">userID</string>
							<int name="Value">18881853</int>
						</Properties>
					</Item>
					<Item class="IntValue" referent="RBX34">
						<Properties>
							<string name="Name">userID</string>
							<int name="Value">18881866</int>
						</Properties>
					</Item>
				</Item>
				<Item class="BoolValue" referent="RBX35">
					<Properties>
						<string name="Name">ReloadCurrentAsset</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX36">
					<Properties>
						<string name="Name">ReloadCurrentAsset</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX37">
					<Properties>
						<string name="Name">MouseClick</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX38">
					<Properties>
						<string name="Name">IsRestricted</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX39">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BasePlateGuide</string>
					<ProtectedString name="Source">local pointDirection = nil

local tailLength = 2 -- 2 or 7
--local dSize = -.05  -- .01 or .005
local dSize = 0 -- because we want the targets to all be the same size (tail isn&apos;t larger anymore; just &quot;ghost&quot; effect)
local dTime = .04 --.025

-- old targetLock pic (square): 48972746

local targetLockSize = .2
local arrowSize = .1

local arrowScreenProportionSize = .95
local arrowMoveFactor = .025

local targetMoveFactor = targetLockSize / 2 - .025

local halfDSize = dSize / 2

local r = game:service(&quot;RunService&quot;)

local vChar = script.Parent
if vChar == nil then script.Parent = nil end

local vPlay = game.Players:GetPlayerFromCharacter(vChar)
if vPlay == nil then script.Parent = nil end

local arrowGui = vPlay.PlayerGui:FindFirstChild(&quot;GuideArrowGui&quot;)
if arrowGui == nil then
&#9;arrowGui = script.GuideArrowGui
&#9;arrowGui.Parent = vPlay.PlayerGui
else
&#9;script.GuideArrowGui:remove()
end

local upArrow = arrowGui.UpArrow
local downArrow = arrowGui.DownArrow
local leftArrow = arrowGui.LeftArrow
local rightArrow = arrowGui.RightArrow
local targetLock = arrowGui.TargetLock
local arrowList = {upArrow, downArrow, leftArrow, rightArrow, targetLock}

local goAway = arrowGui.GoAwayButton
goAway.Visible = true
goAway.Active = true
local keepShowing = true
goAway.MouseButton1Click:connect(function () keepShowing = false end)


local arrowHeightAugment = 0.0
local arrowWidthAugment = 0.0
local targetHeightAugment = 0.0
local targetWidthAugment = 0.0


local targetLockList = {targetLock}
for i = 1, tailLength do table.insert(targetLockList, targetLock:Clone()) end

targetLockList[1].Size = UDim2.new(targetLockSize, 0, targetLockSize, 0)
for i = 1, #targetLockList-1 do
&#9;targetLockList[i+1].Parent = arrowGui
&#9;--targetLockList[i+1].Size = UDim2.new(targetLockSize-i*dSize, 0, targetLockSize-i*dSize, 0)
end
-- switching over to a &quot;ghost-like&quot; transparency effect, but this means we have to upload separate images :(
-- if our tail is turned on, manually apply the ghosting to the next two images
if tailLength &gt; 0 then targetLockList[2].Image = &quot;http://www.roblox.com/asset/?id=49324811&quot; end
if tailLength &gt; 1 then targetLockList[3].Image = &quot;http://www.roblox.com/asset/?id=49324846&quot; end


function onResize() -- force arrows into a square resolution
&#9;xSize = arrowGui.AbsoluteSize.X
&#9;ySize = arrowGui.AbsoluteSize.Y

&#9;if xSize &gt;= ySize then
&#9;&#9;arrowHeightAugment = 0.0

&#9;&#9;-- calculate arrowWidthAugment and new arrow ratio here
&#9;&#9;newArrowUDim = UDim2.new(ySize / xSize * arrowSize, 0, arrowSize, 0)
&#9;&#9;rightArrow.Size = newArrowUDim 
&#9;&#9;leftArrow.Size = newArrowUDim 
&#9;&#9;upArrow.Size = newArrowUDim 
&#9;&#9;downArrow.Size = newArrowUDim

&#9;&#9;for tli = 1, #targetLockList do
&#9;&#9;&#9;targetLockList[tli].Size = UDim2.new(ySize / xSize * (targetLockSize-tli*dSize), 0, targetLockSize-tli*dSize, 0)
&#9;&#9;end

&#9;&#9;arrowWidthAugment = (xSize - ySize)*arrowSize*.5 / xSize
&#9;else
&#9;&#9;arrowWidthAugment = 0.0

&#9;&#9;-- calculate arrowHeightAugment here
&#9;&#9;newArrowUDim = UDim2.new(arrowSize, 0, xSize / ySize * arrowSize, 0)
&#9;&#9;rightArrow.Size = newArrowUDim
&#9;&#9;leftArrow.Size = newArrowUDim
&#9;&#9;upArrow.Size = newArrowUDim
&#9;&#9;downArrow.Size = newArrowUDim

&#9;&#9;for tli = 1, #targetLockList do
&#9;&#9;&#9;targetLockList[tli].Size = UDim2.new(targetLockSize-tli*dSize, 0, xSize / ySize * (targetLockSize-tli*dSize), 0)
&#9;&#9;end

&#9;&#9;arrowHeightAugment = (ySize - xSize)*arrowSize*.5 / ySize
&#9;end

&#9;targetWidthAugment = targetLock.Size.X.Scale / 2 - .025
&#9;targetHeightAugment = targetLock.Size.Y.Scale / 2 - .025
end

arrowGui.Changed:connect(onResize) -- dynamically resize the arrows on screen resize

function findMyBasePlate()
&#9;--if true then return game.Workspace.Base end -- for testing purposes

&#9;local buildingAreas = game.Workspace.BuildingAreas:GetChildren()
&#9;for i = 1, #buildingAreas do
&#9;&#9;if buildingAreas[i].Player.Value == script.Parent.Name then
&#9;&#9;&#9;return buildingAreas[i]:FindFirstChild(&quot;BasePlate&quot;) or buildingAreas[i].PlayerArea:FindFirstChild(&quot;BasePlate&quot;)
&#9;&#9;end
&#9;end
end

local myBase = findMyBasePlate()
if myBase == nil then
&#9;print(&quot;BasePlateGuide script error: no base plate found!&quot;)
&#9;-- abort if no BasePlate found
&#9;arrowGui:remove()
&#9;script:remove()
end

function setVisible(whichArrow)
&#9;for i = 1, #arrowList do
&#9;&#9;if arrowList[i] == whichArrow then
&#9;&#9;&#9;arrowList[i].Visible = true
&#9;&#9;else
&#9;&#9;&#9;arrowList[i].Visible = false
&#9;&#9;end
&#9;end
end

function truncate(number, augmentation)
&#9;if number+augmentation &lt; 0 then return 0 
   elseif number &gt; (1 - arrowSize)+augmentation then return (1 - arrowSize)+2*augmentation -- furthest extent we want the arrows to reach is .95 - arrowSize
&#9;else return number+augmentation end
end


function notInBasePlate(myPos, base)
&#9;local corner1 = base.Position - base.Size/2
&#9;local corner2 = base.Position + base.Size/2
&#9;if myPos.X &gt; corner1.X and myPos.Y &gt; corner1.Y and myPos.Z &gt; corner1.Z and myPos.X &lt; corner2.X and myPos.Z &lt; corner2.Z then -- we only care they&apos;re somewhere above baseplate
&#9;&#9;return false
&#9;else
&#9;&#9;return true
&#9;end
end

local lastTime = 0
local camera = game.Workspace.CurrentCamera
while notInBasePlate(script.Parent.Torso.Position, myBase) and keepShowing do
&#9;--pointDirection = (myBase.Position - script.Parent.Torso.Position) * Vector3.new(1, 0, 1)
&#9;camFrame = camera.CoordinateFrame
&#9;pointDirection = camFrame:vectorToObjectSpace(myBase.Position - camFrame.p)
&#9;camZ = pointDirection.Z
&#9;camX = pointDirection.X/math.abs(camZ)
&#9;camY = pointDirection.Y/math.abs(camZ)
&#9;--print(camX, camY, camZ)

&#9;-- was .55 for 610 (Y) and 1.15 for 1286 (X), so seems like scaling factor is universally 1114 on both axes&#9;
&#9;-- nvm:  at 1662 x 666, we have ... and .55, so seems like .55 always for Y, then X is scaled according to its proportion to Y

&#9;local xThreshold = arrowGui.AbsoluteSize.X / arrowGui.AbsoluteSize.Y * .55
&#9;local yThreshold = .55

&#9;local nCamX = camX / xThreshold
&#9;local nCamY = camY / yThreshold

&#9;if (math.abs(nCamX) &gt; 1 or math.abs(nCamY) &gt; 1) or (camZ &gt; 0) then -- camZ test makes sure we only lock on if facing right direction
&#9;&#9;for j = 2, #targetLockList do
&#9;&#9;&#9;targetLockList[j].Visible = false
&#9;&#9;end
&#9;
&#9;&#9;if math.abs(nCamX) &gt; math.abs(nCamY) then
&#9;&#9;&#9;--if nCamY &gt; 1 then nCamY = 1
&#9;&#9;&#9;--elseif nCamY &lt; -1 then nCamY = -1 end

&#9;&#9;&#9;if camX &gt; 0 then
&#9;&#9;&#9;&#9;-- should go right
&#9;&#9;&#9;&#9;rightArrow.Position = UDim2.new(arrowScreenProportionSize - arrowMoveFactor - .025 + 2*arrowWidthAugment, 0, truncate(arrowScreenProportionSize*(1-nCamY)/2 - arrowMoveFactor, arrowHeightAugment), 0)
&#9;&#9;&#9;&#9;setVisible(rightArrow)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;-- should go left
&#9;&#9;&#9;&#9;leftArrow.Position = UDim2.new(0, 0, truncate(arrowScreenProportionSize*(1-nCamY)/2 - arrowMoveFactor, arrowHeightAugment), 0)
&#9;&#9;&#9;&#9;setVisible(leftArrow)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--if nCamX &gt; 1 then nCamX = 1
&#9;&#9;&#9;--elseif nCamX &lt; -1 then nCamX = -1 end

&#9;&#9;&#9;if camY &gt; 0 then
&#9;&#9;&#9;&#9;-- should go up
&#9;&#9;&#9;&#9;upArrow.Position = UDim2.new(truncate(arrowScreenProportionSize*(nCamX+1)/2 - arrowMoveFactor, arrowWidthAugment), 0, 0, 0)
&#9;&#9;&#9;&#9;setVisible(upArrow)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;-- should go down
&#9;&#9;&#9;&#9;downArrow.Position = UDim2.new(truncate(arrowScreenProportionSize*(nCamX+1)/2 - arrowMoveFactor, arrowWidthAugment), 0, arrowScreenProportionSize - arrowMoveFactor -.025 + 2*arrowHeightAugment, 0)
&#9;&#9;&#9;&#9;setVisible(downArrow)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;-- locked on target
&#9;&#9;--for j = 2, #targetLockList do
&#9;&#9;&#9;--targetLockList[j].Visible = true
&#9;&#9;--end
&#9;&#9;--targetLock.Position = UDim2.new(.95*(nCamX+1)/2 - targetMoveFactor, 0, .95*(1-nCamY)/2 - targetMoveFactor, 0)
&#9;&#9;targetLock.Position = UDim2.new(.95*(nCamX+1)/2 - targetWidthAugment, 0, .95*(1-nCamY)/2 - targetHeightAugment, 0)
&#9;&#9;setVisible(targetLock)
&#9;end

&#9;--wait()
&#9;
&#9;-- update every dTime seconds

&#9;-- ok to do it this way instead of a ring array, because even though it&apos;s less efficient, it&apos;s less efficient by only one or two commands [since only have 2 &quot;tails&quot;]

&#9;local t = r.Stepped:wait()
&#9;if t - lastTime &gt; dTime then
&#9;&#9;lastTime = t
&#9;&#9;for j = #targetLockList, 2, -1 do
&#9;&#9;&#9;targetLockList[j].Position = targetLockList[j-1].Position + UDim2.new(halfDSize, 0, halfDSize, 0)
&#9;&#9;&#9;targetLockList[j].Visible = targetLockList[j-1].Visible
&#9;&#9;end
&#9;end
end

--[[setVisible(nil)
for j = 2, #targetLockList do
&#9;targetLockList[j].Visible = false
end
goAway.Visible = false
goAway.Active = false
]]--
arrowGui:remove()
script:remove()</ProtectedString>
				</Properties>
				<Item class="ScreenGui" referent="RBX40">
					<Properties>
						<string name="Name">GuideArrowGui</string>
					</Properties>
					<Item class="ImageLabel" referent="RBX41">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=48972729 </url></Content>
							<string name="Name">UpArrow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX42">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=48972703</url></Content>
							<string name="Name">RightArrow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX43">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=48972653</url></Content>
							<string name="Name">DownArrow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX44">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=48972682</url></Content>
							<string name="Name">LeftArrow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX45">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset/?id=49321779</url></Content>
							<string name="Name">TargetLock</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX46">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4278255360</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">0</token>
							<bool name="Modal">false</bool>
							<string name="Name">GoAwayButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>20</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>150</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<string name="Text">Hide Guide Arrows</string>
							<Color3 name="TextColor3">4279970357</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ScreenGui" referent="RBX47">
				<Properties>
					<string name="Name">StampGUI</string>
				</Properties>
				<Item class="Frame" referent="RBX48">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">InsertPanel</string>
						<UDim2 name="Position">
							<XS>0.200000003</XS>
							<XO>2</XO>
							<YS>0.100000001</YS>
							<YO>24</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.600000024</XS>
							<XO>-20</XO>
							<YS>0.639999986</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">3</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX49">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ItemsFrame</string>
							<UDim2 name="Position">
								<XS>0.239999995</XS>
								<XO>0</XO>
								<YS>0.0850000009</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.540000021</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX50">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4294112243</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">InsertAssetButtonExample</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>128</XO>
									<YS>0</YS>
									<YO>64</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>64</XO>
									<YS>0</YS>
									<YO>64</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextButton" referent="RBX51">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">true</bool>
									<Color3 name="BackgroundColor3">4282861383</Color3>
									<float name="BackgroundTransparency">0.100000001</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">0</token>
									<token name="FontSize">0</token>
									<bool name="Modal">false</bool>
									<string name="Name">Button</string>
									<UDim2 name="Position">
										<XS>0.0250000004</XS>
										<XO>0</XO>
										<YS>0.0250000004</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>0.949999988</XS>
										<XO>0</XO>
										<YS>0.949999988</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">2</token>
									<string name="Text"></string>
									<Color3 name="TextColor3">4279970357</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX52">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><null></null></Content>
										<string name="Name">ButtonImage</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-8</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>16</XO>
											<YS>1</YS>
											<YO>16</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
							</Item>
							<Item class="IntValue" referent="RBX53">
								<Properties>
									<string name="Name">AssetId</string>
									<int name="Value">209411115</int>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX54">
								<Properties>
									<string name="Name">AssetName</string>
									<string name="Value">Roof - Outer Corner</string>
								</Properties>
							</Item>
							<Item class="ImageLabel" referent="RBX55">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4278190080</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://www.roblox.com/asset?id=54140547</url></Content>
									<string name="Name">ConfigIcon</string>
									<UDim2 name="Position">
										<XS>1</XS>
										<XO>-23</XO>
										<YS>1</YS>
										<YO>-24</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>16</XO>
										<YS>0</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX56">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<bool name="Modal">false</bool>
							<string name="Name">CancelButton</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-32</XO>
								<YS>0</YS>
								<YO>-2</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>34</XO>
								<YS>0</YS>
								<YO>34</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">1</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX57">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset?id=54135717</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>16</XO>
									<YS>0</YS>
									<YO>16</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX58">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">5</token>
							<bool name="Modal">false</bool>
							<string name="Name">SelectSetButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.200000003</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">1</token>
							<string name="Text">Select Set</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX59">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">PagingControls</string>
							<UDim2 name="Position">
								<XS>0.239999995</XS>
								<XO>0</XO>
								<YS>0.899999976</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.540000021</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextButton" referent="RBX60">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<bool name="Modal">false</bool>
								<string name="Name">PreviousPageButton</string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>-95</XO>
									<YS>0.5</YS>
									<YO>-20</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>60</XO>
									<YS>0</YS>
									<YO>40</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX61">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://www.roblox.com/asset?id=54138586</url></Content>
									<string name="Name">ImageLabel</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>8</XO>
										<YS>0</YS>
										<YO>-1</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>18</XO>
										<YS>0</YS>
										<YO>18</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBX62">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4284874854</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<string name="Name">PageText</string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>-30</XO>
									<YS>0.5</YS>
									<YO>-20</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>60</XO>
									<YS>0</YS>
									<YO>40</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">1 / 3</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextButton" referent="RBX63">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<bool name="Modal">false</bool>
								<string name="Name">NextPageButton</string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>35</XO>
									<YS>0.5</YS>
									<YO>-20</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>60</XO>
									<YS>0</YS>
									<YO>40</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX64">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://www.roblox.com/asset?id=54138563</url></Content>
									<string name="Name">ImageLabel</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>10</XO>
										<YS>0</YS>
										<YO>-1</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>18</XO>
										<YS>0</YS>
										<YO>18</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX65">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294901862</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">Sets</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>5</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.230000004</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-5</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX66">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4294967295</Color3>
								<float name="BackgroundTransparency">0.699999988</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Line</string>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>-3</XO>
									<YS>0.0599999987</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>3</XO>
									<YS>0.899999976</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX67">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<string name="Name">SetsHeader</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>47</XO>
									<YS>0</YS>
									<YO>24</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">Sets</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX68">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4291559577</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">SetsLists</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0.0599999987</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-6</XO>
									<YS>0.939999998</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextButton" referent="RBX69">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">false</bool>
									<Color3 name="BackgroundColor3">4294967295</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">1</token>
									<token name="FontSize">6</token>
									<bool name="Modal">false</bool>
									<string name="Name">SetButtonExample</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>5</XO>
										<YS>0</YS>
										<YO>18</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>-5</XO>
										<YS>0</YS>
										<YO>18</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">0</token>
									<string name="Text">House Decorations</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX70">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4284874803</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ItemPreview</string>
							<UDim2 name="Position">
								<XS>0.790000021</XS>
								<XO>0</XO>
								<YS>0.0850000009</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.209999993</XS>
								<XO>0</XO>
								<YS>0.899999976</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX71">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><null></null></Content>
								<string name="Name">LargePreview</string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>4</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX72">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4286578816</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">TextPanel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>4</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>-4</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX73">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4291624857</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">7</token>
									<string name="Name">RolloverText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Window - Diagonal</string>
									<Color3 name="TextColor3">4294112243</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="Frame" referent="RBX74">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<string name="Name">ConfigureText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>-48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">0</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="TextLabel" referent="RBX75">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4294901862</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">2</token>
										<token name="FontSize">5</token>
										<string name="Name">Configure</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>14</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">Configure:</string>
										<Color3 name="TextColor3">4294112243</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX76">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">1</token>
										<token name="FontSize">5</token>
										<string name="Name">Configure1</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>14</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>14</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">Speed</string>
										<Color3 name="TextColor3">4294112243</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX77">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">1</token>
										<token name="FontSize">5</token>
										<string name="Name">Configure2</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>28</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>14</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">Damage</string>
										<Color3 name="TextColor3">4294112243</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX78">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">1</token>
										<token name="FontSize">5</token>
										<string name="Name">Configure3</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>42</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>14</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">Delay</string>
										<Color3 name="TextColor3">4294112243</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX79">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">StamperPanel</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-175</XO>
							<YS>1</YS>
							<YO>-135</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>350</XO>
							<YS>0</YS>
							<YO>48</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">3</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="TextButton" referent="RBX80">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<bool name="Modal">false</bool>
							<string name="Name">MinimizeButton</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-32</XO>
								<YS>0</YS>
								<YO>-2</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>34</XO>
								<YS>0</YS>
								<YO>34</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">1</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX81">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset?id=54932670</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-3</XO>
									<YS>0</YS>
									<YO>-4</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>16</XO>
									<YS>0</YS>
									<YO>20</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">4</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX82">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">StamperButtons</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX83">
							<Properties>
								<bool name="Active">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">RecentFrame</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>103</XO>
									<YS>0</YS>
									<YO>-6</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>192</XO>
									<YS>0</YS>
									<YO>44</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
							<Item class="TextButton" referent="RBX84">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">true</bool>
									<Color3 name="BackgroundColor3">4282861383</Color3>
									<float name="BackgroundTransparency">0.100000001</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">0</token>
									<token name="FontSize">0</token>
									<bool name="Modal">false</bool>
									<string name="Name">Button1</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>-2</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>48</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">2</token>
									<string name="Text"></string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">4</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX85">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>http://gametest.roblox.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
										<string name="Name">ButtonImage</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-8</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>16</XO>
											<YS>1</YS>
											<YO>16</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX86">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">2</token>
										<token name="FontSize">5</token>
										<string name="Name">ShortcutText</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-7</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>7</XO>
											<YS>0</YS>
											<YO>12</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">F</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBX87">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">true</bool>
									<Color3 name="BackgroundColor3">4282861383</Color3>
									<float name="BackgroundTransparency">0.100000001</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">0</token>
									<token name="FontSize">0</token>
									<bool name="Modal">false</bool>
									<string name="Name">Button2</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>48</XO>
										<YS>0</YS>
										<YO>-2</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>48</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">2</token>
									<string name="Text"></string>
									<Color3 name="TextColor3">4279970357</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">4</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX88">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>http://gametest.roblox.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
										<string name="Name">ButtonImage</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-8</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>16</XO>
											<YS>1</YS>
											<YO>16</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX89">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">2</token>
										<token name="FontSize">5</token>
										<string name="Name">ShortcutText</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-7</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>7</XO>
											<YS>0</YS>
											<YO>12</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">G</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBX90">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">true</bool>
									<Color3 name="BackgroundColor3">4282861383</Color3>
									<float name="BackgroundTransparency">0.100000001</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">0</token>
									<token name="FontSize">0</token>
									<bool name="Modal">false</bool>
									<string name="Name">Button3</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>95</XO>
										<YS>0</YS>
										<YO>-3</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>48</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">2</token>
									<string name="Text"></string>
									<Color3 name="TextColor3">4279970357</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">4</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX91">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>http://gametest.roblox.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
										<string name="Name">ButtonImage</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-8</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>16</XO>
											<YS>1</YS>
											<YO>16</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX92">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">2</token>
										<token name="FontSize">5</token>
										<string name="Name">ShortcutText</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-7</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>7</XO>
											<YS>0</YS>
											<YO>12</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">H</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBX93">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">true</bool>
									<Color3 name="BackgroundColor3">4282861383</Color3>
									<float name="BackgroundTransparency">0.100000001</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">0</token>
									<token name="FontSize">0</token>
									<bool name="Modal">false</bool>
									<string name="Name">Button4</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>142</XO>
										<YS>0</YS>
										<YO>-3</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>48</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">2</token>
									<string name="Text"></string>
									<Color3 name="TextColor3">4279970357</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">4</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX94">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>http://gametest.roblox.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
										<string name="Name">ButtonImage</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-8</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>16</XO>
											<YS>1</YS>
											<YO>16</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX95">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">2</token>
										<token name="FontSize">5</token>
										<string name="Name">ShortcutText</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-7</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>7</XO>
											<YS>0</YS>
											<YO>12</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">J</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX96">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">5</token>
								<bool name="Modal">false</bool>
								<string name="Name">CloneButton</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>-6</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>45</XO>
									<YS>0</YS>
									<YO>45</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX97">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://www.roblox.com/asset?id=51641555</url></Content>
									<string name="Name">ImageLabel</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-7</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>14</XO>
										<YS>1</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">4</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX98">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">CloneShortcut</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>8</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">E</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX99">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">5</token>
								<bool name="Modal">false</bool>
								<string name="Name">PartsButton</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>45</XO>
									<YS>0</YS>
									<YO>-6</YO>
								</UDim2>
								<bool name="Selected">true</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>45</XO>
									<YS>0</YS>
									<YO>45</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX100">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://www.roblox.com/asset?id=54966682</url></Content>
									<string name="Name">ImageLabel</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-7</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>14</XO>
										<YS>1</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">4</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX101">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">PartsShortcut</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>8</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Q</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">0</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Frame" referent="RBX102">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">ClonePanel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>-8</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>80</XO>
									<YS>1</YS>
									<YO>16</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX103">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">ClonePanelText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-6</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>12</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Click on a part to clone it</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX104">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<bool name="Modal">false</bool>
							<string name="Name">RestoreButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-25</XO>
								<YS>0</YS>
								<YO>-20</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>50</XO>
								<YS>0</YS>
								<YO>25</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">1</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX105">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset?id=54933540</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-4</XO>
									<YS>0</YS>
									<YO>-4</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>8</XO>
									<YS>1</YS>
									<YO>8</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">4</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX106">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StampGuiController</string>
						<ProtectedString name="Source">local stampGui = script.Parent
local insertPanel = stampGui.InsertPanel
local stamperPanel = stampGui.StamperPanel

local itemPreview = insertPanel.ItemPreview

function handleResize()
&#9;wait() -- neccessary to insure heartbeat happened
&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
end

stampGui.Changed:connect(function(prop)
&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;handleResize()
&#9;end
end)

handleResize()</ProtectedString>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX107">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">LoadDialog</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-175</XO>
							<YS>0.5</YS>
							<YO>-25</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>350</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">1</token>
						<token name="Style">3</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextLabel" referent="RBX108">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">LoadLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>-8</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>155</XO>
								<YS>0.5</YS>
								<YO>36</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Loading...</string>
							<Color3 name="TextColor3">4294506744</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="SelectionBox" referent="RBX109">
				<Properties>
					<Ref name="Adornee">null</Ref>
					<int name="Color">21</int>
					<string name="Name">ErrorBox</string>
					<float name="Transparency">0</float>
					<bool name="Visible">false</bool>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX110">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GuiScript</string>
					<ProtectedString name="Source">-- This script is responsible for working the gui

-- basic functions
function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

function waitForProperty(instance, name)
&#9;while not instance[name] do
&#9;&#9;instance.Changed:wait()
&#9;end
end


-- Locals
local Tool = script.Parent

waitForChild(Tool, &quot;LuaGlobalVariables&quot;)
local variables = Tool.LuaGlobalVariables
waitForChild(variables, &quot;InsertAsset&quot;)
local insertAsset = variables.InsertAsset
waitForChild(variables, &quot;SwitchMode&quot;)
local switchMode = variables.SwitchMode
waitForChild(variables, &quot;ShowAdminCategories&quot;)
local showAdminCategories = variables.ShowAdminCategories

waitForChild(variables, &quot;ReloadCurrentAsset&quot;)
waitForChild(variables,&quot;userIDs&quot;)

game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=42163425&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=42563487&quot;)

local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl

local buttonHeight = 64
local buttonWidth = buttonHeight

local waypointShowing = false
local showingPartPicker = true
local firstEquip = true

local Window
local Data
local loading = false

local startTime = 0

local SetCache = {}

local lastEnter = nil

-- For Restricting Stamper Tool
local buildingPlate
local partModel

-- wait for all of our set ids to load
local userIdsForStamperParts = variables.userIDs -- 7502714 This is UsabilityMan (on gametest)

function giveNewUserId(id)
&#9;local newUserId = Instance.new(&quot;IntValue&quot;)
&#9;newUserId.Name = &quot;userID&quot;
&#9;newUserId.Value = id
&#9;newUserId.Parent = userIdsForStamperParts
&#9;userIdsForStamperParts.Value = userIdsForStamperParts.Value + 1
end

BaseUrl = BaseUrl:lower()

local isRestricted = Instance.new(&quot;BoolValue&quot;)
isRestricted.Name = &quot;IsRestricted&quot;
isRestricted.Value = false

function isLocalWTRB()
&#9;waitForChild(game,&quot;StarterGui&quot;)
&#9;if game.StarterGui:FindFirstChild(&quot;VersionGui&quot;) then
&#9;&#9;if game.StarterGui.VersionGui:FindFirstChild(&quot;VersionText&quot;, true) then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end
&#9;return false
end

waitForProperty(game,&quot;PlaceId&quot;)
if game.PlaceId == 41324860 or isLocalWTRB() then
&#9;isRestricted.Value = true
end
isRestricted.Parent = variables

giveNewUserId(18881789)
giveNewUserId(18881808)
if not isRestricted.Value then
&#9;giveNewUserId(18881829)
&#9;giveNewUserId(18881853)
&#9;giveNewUserId(18881866)
else
&#9;giveNewUserId(2409156)
&#9;giveNewUserId(19238067)
&#9;giveNewUserId(19238114)
end

while #userIdsForStamperParts:GetChildren() &lt; userIdsForStamperParts.Value do userIdsForStamperParts.ChildAdded:wait() end
userIdsForStamperParts = userIdsForStamperParts:GetChildren()

local useAssetVersionId = false
local LargeThumbnailUrl
local SmallThumbnailUrl

local InsertRows = 0
local InsertColumns = 0
local insertButtons = {}

local CancelDuringLoad

local prevPart = {AssetNameValue = &quot;&quot;,AssetIdValue = 0 ,InsertFrameButtonImage = &quot;&quot;}
local recentPartStack = {}

-- Connection Managers
local guiChangedCon = nil
local cloneButtonCon = nil
local partListClickCon = nil
local itemFrameChangedCon = nil
local setsNextPageCon = nil
local setsPrevPageCon = nil
local insertPanelCloseCon = nil
local minimizeCon = nil
local restoreCon = nil
local setButtonCons = {}
local insertButtonCons = {}
local recentPartStackCons = {}

local Mouse = nil
local currSetPage = 1

local mode = 0 -- 0 = main dialog, 1 = stamper, 2 = eyedropper

waitForChild(script.Parent,&quot;StampGUI&quot;)
local stamperGui = script.Parent.StampGUI
waitForChild(stamperGui,&quot;InsertPanel&quot;)
waitForChild(stamperGui.InsertPanel, &quot;CancelButton&quot;)
local currStampGui = nil

local maxRecentParts = 4
for i = 1, maxRecentParts do
&#9;recentPartStack[i] = {AssetNameValue,AssetIdValue,InsertFrameButtonImage}
&#9;recentPartStack[i].AssetNameValue = &quot;&quot;
&#9;recentPartStack[i].AssetIdValue = &quot;&quot;
&#9;recentPartStack[i].InsertFrameButtonImage = &quot;&quot;
end
----------------------------------------------------------------------------------------


-- functions
function showBaseplateGuideArrows()
&#9;playerCharacter = Tool.Parent
&#9;if playerCharacter:FindFirstChild(&quot;Humanoid&quot;) and not playerCharacter:FindFirstChild(&quot;BasePlateGuide&quot;) then
&#9;&#9;newGuide = Tool.BasePlateGuide:Clone()
&#9;&#9;newGuide.Parent = playerCharacter
&#9;&#9;newGuide.Disabled = false
&#9;end
end

function setAssetUrls()
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
end

function signalSwitchMode(mode)
&#9;switchMode.Mode.Value = mode
&#9;switchMode.Value = true
end

function goToClone()
&#9;cancelLoadingWindow()
&#9;closeInsertPanel()
&#9;cancelAssetPlacement()

&#9;mode = 2
&#9;--signalStamperScript(&quot;&quot;,0,&quot;&quot;,&quot;&quot;,false)
&#9;signalSwitchMode(&quot;Clone&quot;)

&#9;currStampGui.StamperPanel.StamperButtons.ClonePanel.Visible = true
&#9;currStampGui.StamperPanel.StamperButtons.CloneButton.Selected = true
&#9;if currStampGui.Parent ~= nil then
&#9;&#9;currStampGui.StamperPanel.StamperButtons.ClonePanel:TweenPosition(UDim2.new(0, -88, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
&#9;&#9;delay(0.3,function() currStampGui.StamperPanel.StamperButtons.ClonePanel.ClonePanelText.Visible = true end)
&#9;end
end

function goToStamp()
&#9;mode = 1
&#9;cancelLoadingWindow()
&#9;closeInsertPanel()
&#9;closeClonePanel()
end

function goToInsertPanel()
&#9;cancelLoadingWindow()
&#9;closeClonePanel()
&#9;pcall(function() currStampGui.InsertPanel.CancelButton.Modal = true end)
&#9;currStampGui.StamperPanel.StamperButtons.PartsButton.Selected = true

&#9;if not showingPartPicker then
&#9;&#9;showingPartPicker = true
&#9;&#9;if currStampGui.Parent ~= nil then
&#9;&#9;&#9;currStampGui.InsertPanel:TweenPosition(UDim2.new(0.2, 2, 0.1, 24),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
&#9;&#9;end
&#9;else
&#9;&#9;closeInsertPanel()
&#9;&#9;reloadCurrentAsset()
&#9;end
end

function closeInsertPanel()
&#9;pcall(function() currStampGui.InsertPanel.CancelButton.Modal = false end)
&#9;currStampGui.StamperPanel.StamperButtons.PartsButton.Selected = false

&#9;showingPartPicker = false
&#9;if currStampGui.Parent ~= nil then
&#9;&#9;currStampGui.InsertPanel:TweenPosition(UDim2.new(0.2, 2, 1, 24),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
&#9;end
end

function closeClonePanel()
&#9;currStampGui.StamperPanel.StamperButtons.ClonePanel.ClonePanelText.Visible = false
&#9;currStampGui.StamperPanel.StamperButtons.CloneButton.Selected = false
&#9;if currStampGui.Parent ~= nil then
&#9;&#9;currStampGui.StamperPanel.StamperButtons.ClonePanel:TweenPosition(UDim2.new(0, 0, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
&#9;&#9;delay(0.3,function() currStampGui.StamperPanel.StamperButtons.ClonePanel.Visible = false end)
&#9;end
end

function cancelAssetPlacement()
&#9;gInitial90DegreeRotations = 0
&#9;Data.Stamp.Cancelled = true
&#9;Data.Stamp.Dragger = nil
&#9;if Data.Stamp.Model then
&#9;&#9;Data.Stamp.Model:Remove()
&#9;&#9;Data.Stamp.Model = nil
&#9;end
&#9;if Data.Stamp.CurrentParts then
&#9;&#9;for index, object in pairs(Data.Stamp.CurrentParts) do
&#9;&#9;&#9;object:Remove()
&#9;&#9;end
&#9;&#9;Data.Stamp.CurrentParts = nil
&#9;end

&#9;if Mouse then
&#9;&#9;Mouse.Icon =&quot;rbxasset://textures\\ArrowCursor.png&quot;
&#9;end
&#9;game.JointsService:ClearJoinAfterMoveJoints()

end

function hint(label)

&#9;-- Pass in a string, it shows a top hint.  (Replaces previous hint, if exists)
&#9;_player = game.Players:GetPlayerFromCharacter(Tool.Parent)
&#9;if(_player.PlayerGui:FindFirstChild(&quot;topHint&quot;)~=nil) then
&#9;&#9;local topHint = _player.PlayerGui.topHint
&#9;&#9;topHint.Add.Label.Value = label
&#9;&#9;topHint.Add.Width.Value = 3 -- widest width
&#9;&#9;topHint.Add.Time.Value = 5
&#9;&#9;topHint.Add.Disabled = true
&#9;&#9;topHint.Add.Disabled = false
&#9;end

end

function getPlayer()
&#9;return game.Players:GetPlayerFromCharacter(script.Parent.Parent)
end

function getHumanoid()
&#9;local player = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
&#9;if player then
&#9;&#9;waitForProperty(player,&quot;Character&quot;)
&#9;&#9;waitForChild(player.Character,&quot;Humanoid&quot;)
&#9;&#9;return player.Character.Humanoid
&#9;else
&#9;&#9;return nil
&#9;end
end

function buildSetButton(name, setId, setImageId, i,  count)

&#9;local button = currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample:Clone()
&#9;button.Text = name
&#9;button.Name = &quot;SetButton&quot;
&#9;button.Visible = true

&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;setValue.Name = &quot;SetId&quot;
&#9;setValue.Value = setId
&#9;setValue.Parent = button

&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;setName.Name = &quot;SetName&quot;
&#9;setName.Value = name
&#9;setName.Parent = button

&#9;return button
end


function previousSetPage()
&#9;local newIndex = math.max(0, Data.Category[Data.CurrentCategory].Index - (InsertRows * InsertColumns))
&#9;setSetIndex(newIndex)
end


function nextSetPage()
&#9;local newIndex = math.max(0, Data.Category[Data.CurrentCategory].Index + (InsertRows * InsertColumns))
&#9;setSetIndex(newIndex)
end

function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;if visible then
&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;beginInsertAssetGui(insertFrame.AssetName.Value, insertFrame.AssetId.Value, insertFrame.Button.ButtonImage.Image, 1)
&#9;&#9;&#9;end)
&#9;&#9;)
&#9;&#9;insertFrame.Visible = true
&#9;else
&#9;&#9;insertFrame.Visible = false
&#9;end
end

function setSetIndex(dataOffset)

&#9;Data.Category[Data.CurrentCategory].Index = dataOffset

&#9;InsertRows = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;InsertColumns = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;local PageSize = InsertRows * InsertColumns
&#9;local contents = Data.Category[Data.CurrentCategory].Contents
&#9;if contents then
&#9;&#9;
&#9;&#9;local numOfPages = math.ceil((#contents)/(PageSize))
&#9;&#9;local currPage = math.ceil((dataOffset/PageSize) + 1)
&#9;&#9;currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currPage) .. &quot;/&quot; .. tostring(numOfPages)
&#9;&#9;currStampGui.InsertPanel.PagingControls.PageText.Visible = (numOfPages &gt; 1)

      currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = (numOfPages &gt; 1) and dataOffset &gt; 1
&#9;&#9;currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = (numOfPages &gt; 1) and ((dataOffset - 1) + PageSize) &lt; (#contents)

&#9;&#9;-- remove our buttons and their connections
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;end
&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;pcall(function() insertButtonCons[i]:disconnect() end)
&#9;&#9;end

&#9;&#9;insertButtonCons = {}
&#9;&#9;insertButtons = {}
&#9;&#9;local arrayPosition = 1
&#9;&#9;for y = 1, InsertRows do
&#9;&#9;&#9;for x = 1, InsertColumns do
&#9;&#9;&#9;&#9;local buttonPosition = UDim2.new(0,(buttonWidth)*(x-1),0, (buttonHeight)*(y-1))

&#9;&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton(buttonPosition)
&#9;&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;&#9;insertButtons[arrayPosition].Parent = currStampGui.InsertPanel.ItemsFrame
&#9;&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;Data.InsertButtons = insertButtons

&#9;&#9;for index = 1, PageSize do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index + dataOffset] then
&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index + dataOffset].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index + dataOffset].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index + dataOffset].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], false)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = false
&#9;&#9;currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = false
&#9;end

end

function moveLoadingLeft()
&#9;if (tick() - startTime &gt; 5) and (currStampGui.Parent ~= nil) then
&#9;&#9;loading = false
&#9;&#9;cancelAssetPlacement()
&#9;&#9;goToInsertPanel()
&#9;end
&#9;if loading then
&#9;&#9;currStampGui.LoadDialog.LoadLabel:TweenPosition(UDim2.new(0, 0, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.7,true,function() moveLoadingRight() end)
&#9;end
end

function moveLoadingRight()
&#9;if (tick() - startTime &gt; 5) and (currStampGui.Parent ~= nil) then
&#9;&#9;loading = false
&#9;&#9;cancelAssetPlacement()
&#9;&#9;goToInsertPanel()
&#9;end
&#9;if loading then
&#9;&#9;currStampGui.LoadDialog.LoadLabel:TweenPosition(UDim2.new(0, 180, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.7,true,function() moveLoadingLeft() end)
&#9;end
end

function moveLoadingWindow()
&#9;startTime = tick()
&#9;currStampGui.LoadDialog.Visible = true
&#9;loading = true
&#9;moveLoadingRight()
end

function cancelLoadingWindow()
&#9;currStampGui.LoadDialog.Visible = false
&#9;loading = false
end


function selectCategoryPage(buttons, page)

&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;end
&#9;&#9;if Data.Main.FrameHeight then
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetIndex then
&#9;&#9;&#9;&#9;layoutSetButtons(Data.Main.FrameHeight, Data.Category[Data.CurrentCategory].SetIndex)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;layoutSetButtons(Data.Main.FrameHeight, 1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

end

function selectSet(button, setName, setId, setIndex)

&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;end
&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;end
&#9;&#9;setSetIndex(setIndex)
&#9;end

end


function selectCategory(button, category)
&#9;selectCategoryPage(category, 0)
end


function processCategory(sets, setPanel)
&#9;local setButtons = {}
&#9;local numSkipped = 0
&#9;for index, object in pairs(sets) do
&#9;&#9;if not showAdminCategories.Value and object.Name == &quot;Beta&quot; then
&#9;&#9;&#9;-- skip this if not an admin
&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;else
&#9;&#9;&#9;setButtons[index - numSkipped] = buildSetButton(object.Name, object.CategoryId, object.ImageAssetId, index - numSkipped, #sets)
&#9;&#9;&#9;setButtons[index - numSkipped].Parent = setPanel
&#9;&#9;end
&#9;end
&#9;return setButtons
end


function setsNextPageClick(totalSetPages, gridSize)
&#9;-- set our logic/gui correctly
&#9;if currSetPage &gt;= totalSetPages then return end

&#9;currSetPage = currSetPage + 1
&#9;currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currSetPage) .. &quot;/&quot; .. tostring(totalSetPages)
&#9;if currSetPage == totalSetPages then
&#9;&#9;currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = false
&#9;&#9;currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = true
&#9;else
&#9;&#9;Window.Sets.PagingControls.NextPageButton.Visible = true
&#9;end
&#9;
&#9;-- actually update the items
&#9;makeCurrentSetsPageVisible(gridSize)
end

function setsPrevPageClick(totalSetPages, gridSize)
&#9;-- set our logic/gui correctly
&#9;if currSetPage &lt;= 1 then return end

&#9;currSetPage = currSetPage - 1
&#9;currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currSetPage) .. &quot;/&quot; .. tostring(totalSetPages)
&#9;if currSetPage == 1 then
&#9;&#9;currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = true
&#9;&#9;currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = false
&#9;else
&#9;&#9;currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = true
&#9;end

&#9;-- actually update the items
&#9;makeCurrentSetsPageVisible(gridSize)
end

function resetAllSetButtonSelection()
&#9;local setButtons = Window.Sets.SetsLists:GetChildren()
&#9;for i = 1, #setButtons do
&#9;&#9;setButtons[i].Selected = false
&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;end
end

function populateSetsFrame()
&#9;local categories = #Data.UserCategoryButtons
&#9;local robloxMaxCat = categories
&#9;
&#9;-- don&apos;t do anything until window is visible (otherwise we won&apos;t layout anything!)
&#9;while Window.Sets.SetsLists.AbsoluteSize.X &lt;= 0 do
&#9;&#9;Window.Sets.SetsLists.Changed:wait()
&#9;end
&#9;while Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.X &lt;= 0 do
&#9;&#9;Window.Sets.SetsLists.SetButtonExample.Changed:wait()
&#9;end

&#9;local totalColumns = math.floor(Window.Sets.SetsLists.AbsoluteSize.X/Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.X)
&#9;local totalRows = math.floor(Window.Sets.SetsLists.AbsoluteSize.Y/Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.Y)
&#9;
&#9;local currRow = 0
&#9;local buttonVisible = true

&#9;local masterCategory = 1
&#9;for i = 1, categories do
&#9;&#9;local userCategory = masterCategory -- needed to maintain local scope for categories in event listeners below
&#9;&#9;local button = Window.Sets.SetsLists.SetButtonExample:clone()

&#9;&#9;button.Name = &quot;Set&quot; .. tostring(Data.UserCategoryButtons[userCategory].SetName.Value) .. &quot;Button&quot;
&#9;&#9;button.Parent = Window.Sets.SetsLists
&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.AbsoluteSize.Y)
&#9;&#9;button.Visible = buttonVisible
&#9;&#9;button.Text =  tostring(Data.UserCategoryButtons[userCategory].SetName.Value)

&#9;&#9;if i == 1 then
&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end

&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;setButtonCons[i] = button.MouseButton1Click:connect(function()
&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BackgroundTransparency = 0

&#9;&#9;&#9;selectSet(button, button.Text, Data.UserCategoryButtons[userCategory].SetId.Value, 0)
&#9;&#9;end)
&#9;&#9;
&#9;&#9;masterCategory = masterCategory + 1

&#9;&#9;currRow = currRow + 1
&#9;end
&#9;
&#9;-- don&apos;t use example button as the first set!
&#9;local example = currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample
&#9;currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample.Parent = nil
&#9;local buttons =  currStampGui.InsertPanel.Sets.SetsLists:GetChildren()
&#9;example.Parent = currStampGui.InsertPanel.Sets.SetsLists

&#9;-- set first category as loaded for default
&#9;selectSet(buttons[1], buttons[1].Text, Data.UserCategoryButtons[1].SetId.Value, 0)
&#9;selectCategory(buttons[1], Data.UserCategoryButtons)
end


function layoutSetButtons(frameHeight, setIndex)
&#9;Data.Main.FrameHeight = frameHeight
&#9;Data.Main.InsertSets = math.floor(frameHeight / (height*2))
&#9;if #Data.CurrentCategory &gt; Data.Main.InsertSets then
&#9;&#9;--Steal one entry since we have too many things
&#9;&#9;Data.Main.InsertSets = Data.Main.InsertSets - 1
&#9;end

&#9;Data.Category[Data.CurrentCategory].SetIndex = setIndex
end


function showLargePreview(insertButton)
&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;delay(0,function()
&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;currStampGui.InsertPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;end)
&#9;end
&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;currStampGui.InsertPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;end
end


function buildInsertButton(buttonPosition)
&#9;local insertButton = currStampGui.InsertPanel.ItemsFrame.InsertAssetButtonExample:clone()
&#9;insertButton.Position = buttonPosition
&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;insertButton.Visible = true

&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;lastEnter = insertButton
&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end)
&#9;return insertButton, mouseEnterCon
end

function minimizeStamperPanel()
&#9;currStampGui.StamperPanel.StamperButtons.Visible = false
&#9;currStampGui.StamperPanel.MinimizeButton.Visible = false
&#9;if currStampGui.Parent ~= nil then
&#9;&#9;currStampGui.StamperPanel:TweenSizeAndPosition(UDim2.new(0,0,0,0), UDim2.new(0.5,0,1,-92),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.5,true)
&#9;&#9;delay(0.5,function()
&#9;&#9;&#9;currStampGui.StamperPanel.RestoreButton.Visible = true
&#9;&#9;end)
&#9;end
end

function restoreStamperPanel()
&#9;currStampGui.StamperPanel.RestoreButton.Visible = false
&#9;if currStampGui.Parent ~= nil then
&#9;&#9;currStampGui.StamperPanel:TweenSizeAndPosition(UDim2.new(0,350,0,48), UDim2.new(0.5,-175,1,-135), Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.5,true)
&#9;&#9;delay(0.5,function()
&#9;&#9;&#9;currStampGui.StamperPanel.StamperButtons.Visible = true
&#9;&#9;&#9;currStampGui.StamperPanel.MinimizeButton.Visible = true
&#9;&#9;end)
&#9;end
end

function setUpStamperGui()
&#9;pcall(function() currStampGui.InsertPanel.CancelButton.Modal = true end)
&#9;Window.Sets = currStampGui.InsertPanel.Sets

&#9;cloneButtonCon = currStampGui.StamperPanel.StamperButtons.CloneButton.MouseButton1Click:connect(goToClone)
&#9;partListClickCon = currStampGui.StamperPanel.StamperButtons.PartsButton.MouseButton1Click:connect(goToInsertPanel)

&#9;Data.Main = {}
&#9;Data.Category = {}
&#9;Data.Stamp = {}

&#9;Data.BaseCategoryButtons = {}
&#9;local userData = {}
&#9;for id = 1, #userIdsForStamperParts do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserCategories(userIdsForStamperParts[id].Value)
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if userData then
&#9;&#9;Data.UserCategoryButtons = processCategory(userData, setPanel)
&#9;end

&#9;guiChangedCon = currStampGui.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;setSetIndex(0)
&#9;&#9;end
&#9;end)

&#9;InsertRows = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;InsertColumns = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;setsPrevPageCon = currStampGui.InsertPanel.PagingControls.PreviousPageButton.MouseButton1Click:connect(function() previousSetPage() end)
&#9;setsNextPageCon = currStampGui.InsertPanel.PagingControls.NextPageButton.MouseButton1Click:connect(function() nextSetPage() end)

&#9;insertPanelCloseCon = currStampGui.InsertPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;closeInsertPanel()
&#9;&#9;closeClonePanel()
&#9;&#9;reloadCurrentAsset()
&#9;end)

&#9;minimizeCon = currStampGui.StamperPanel.MinimizeButton.MouseButton1Click:connect(function() minimizeStamperPanel() end)
&#9;restoreCon = currStampGui.StamperPanel.RestoreButton.MouseButton1Click:connect(function() restoreStamperPanel() end)
end

-- signal to scripts we are ready to start manipulating objects
function signalStamperScript(assetName, assetId, image, stampMode)
&#9;insertAsset.AssetName.Value = assetName
&#9;insertAsset.AssetId.Value = assetId
&#9;insertAsset.Image.Value = image
&#9;insertAsset.StampMode.Value = stampMode
&#9;insertAsset.Updated.Value = true
end

function reloadCurrentAsset()
&#9;variables.ReloadCurrentAsset.Value = true
end


function beginInsertAssetGui(assetName, assetId, image, stampMode)
&#9;Data.Stamp.StampMode = stampMode
&#9;closeInsertPanel()
&#9;signalStamperScript(&quot;&quot;,0,&quot;&quot;,&quot;&quot;,false)
&#9;moveLoadingWindow()
&#9;cancelAssetPlacement()
&#9;signalStamperScript(assetName, assetId, image, stampMode)
end


function cancelAssetLoad()
&#9;Data.Loading.Cancelled = true
&#9;insertComplete()
&#9;gInitial90DegreeRotations = 0
end

function inBounds2(part)
&#9;-- part must have a position property
&#9;local xOne= buildingPlate.Position.x + buildingPlate.Size.x/2
&#9;local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
&#9;local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
&#9;local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2
&#9;if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
&#9;if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end
&#9;return true
end


-- For Restricting Stamper Tool (isRestricted)
function showHelp_pointToBuildingplate()

&#9;if(buildingPlate==nil) then
&#9;&#9;hint(&quot;All building areas are taken. If you want to build, leave and join again.&quot;)
&#9;else
&#9;&#9;-- only show one waypoint at a time (because kids will click a million times outside their plate)
&#9;&#9;hint(&quot;Stamper Tool only works in your area.&quot;)
&#9;&#9;if(not waypointShowing) then
&#9;&#9;&#9;waypointShowing = true
&#9;&#9;&#9;local _character = Tool.Parent
&#9;&#9;&#9;waitForChild(_character, &quot;Torso&quot;)
&#9;&#9;&#9;_player = game.Players:GetPlayerFromCharacter(_character)
&#9;&#9;&#9;_player.PlayerGui.showBaseplateWaypoint.target.Value = buildingPlate
&#9;&#9;&#9;_player.PlayerGui.showBaseplateWaypoint.Disabled = true
&#9;&#9;&#9;_player.PlayerGui.showBaseplateWaypoint.Disabled = false
&#9;&#9;&#9;-- Wait until character moves in bounds (check every 2 seconds)
&#9;&#9;&#9;while(not inBounds2(_character.Torso) and isEquipped) do&#9;wait(2) end
&#9;&#9;&#9;-- Then hide the waypoint
&#9;&#9;&#9;hideHelp_pointToBuildingplate()
&#9;&#9;end
&#9;end

end


function showHelp_tooManyParts()
&#9;hint(&quot;You have reached maximum number of parts! Delete some to put more down.&quot;)
end


function hideHelp_pointToBuildingplate()
&#9;waypointShowing = false
&#9;_player.PlayerGui.hideBaseplateWaypoint.Disabled = true
&#9;_player.PlayerGui.hideBaseplateWaypoint.Disabled = false&#9;&#9;
end


function setUpRestrictions()
&#9;playerModel = game.Workspace.ActiveParts:FindFirstChild(player.Name .. &quot;&apos;s parts&quot;)

&#9;local takenAreas = game.Workspace.BuildingAreas:GetChildren()

&#9;waitForChild(player, &quot;playerNumber&quot;)
&#9;&#9;
&#9;if(player.playerNumber.Value == 0) then
&#9;  buildingPlate = nil
&#9;  partModel = nil
&#9;else
&#9;  waitForChild(game.Workspace, &quot;BuildingAreas&quot;)
&#9;  local buildingAreas = game.Workspace.BuildingAreas
&#9;  waitForChild(buildingAreas, &quot;Area&quot;..tostring(player.playerNumber.Value))
&#9;  local targetArea = buildingAreas:FindFirstChild(&quot;Area&quot;..tostring(player.playerNumber.Value))
&#9;  waitForChild(targetArea, &quot;PlayerArea&quot;)
&#9;  waitForChild(targetArea.PlayerArea, &quot;BasePlate&quot;)

&#9;  buildingPlate = targetArea.PlayerArea.BasePlate
&#9;  partModel = targetArea.PlayerArea
&#9;&#9;&#9;
&#9;end

&#9;-- Check if player is standing in bounds, if not show error
&#9;local _character = Tool.Parent
&#9;waitForChild(_character, &quot;Torso&quot;)
&#9;_player = game.Players:GetPlayerFromCharacter(_character)
&#9;if(buildingPlate~=nil) then
&#9;&#9;if(not inBounds2(_character.Torso)) then
&#9;&#9;&#9;showHelp_pointToBuildingplate()
&#9;&#9;end
&#9;else
&#9;&#9;-- You have no building plate.
&#9;&#9;hint(&quot;All building areas are taken. If you want to build, leave and join again.&quot;)
&#9;end
end

function onInsertKeyDown(key)
&#9;if loading then return end -- don&apos;t try to switch while we&apos;re loading

&#9;key = string.lower(key)

&#9;-- go to mru buttons
&#9;if key == &apos;f&apos; then
&#9;&#9;mruButtonClick(1)
&#9;elseif key == &apos;g&apos; then
&#9;&#9;mruButtonClick(2)
&#9;elseif key == &apos;h&apos; then
&#9;&#9;mruButtonClick(3)
&#9;elseif key == &apos;j&apos; then
&#9;&#9;mruButtonClick(4)
&#9;end

end

function onEquippedLocal(mouse)
&#9;player = getPlayer()
&#9;if not player then 
&#9;&#9;return 
&#9;end
&#9;if Tool.PlayerOwner.Value and Tool.PlayerOwner.Value ~= player then return end 

&#9;-- For Restricting Stamper Tool
&#9;if isRestricted.Value then
&#9;&#9;setUpRestrictions()
&#9;end

&#9;Mouse = mouse
&#9;if not firstEquip and currStampGui and Tool.SavedState.Value and Tool.PlayerOwner.Value == getPlayer() and Data and Data.FullyLoaded then

&#9;&#9;currStampGui.Parent = getPlayer().PlayerGui

&#9;&#9;if mode == 1 then -- if we were stamping, keep going
&#9;&#9;&#9;-- if we signal a negative asset, then that means keep going using whatever was in recent memory [don&apos;t reload from insert service]
&#9;&#9;&#9;signalStamperScript(insertAsset.AssetName.Value, -1, insertAsset.Image.Value, true)&#9;&#9;&#9;
&#9;&#9;elseif mode == 2 then -- time to clone
&#9;&#9;&#9;goToClone()
&#9;&#9;end

&#9;else
&#9;&#9;if firstEquip then
&#9;&#9;&#9;Tool.PlayerOwner.Value = player
&#9;&#9;&#9;firstEquip = false
&#9;&#9;end
&#9;&#9;CancelDuringLoad = false
&#9;&#9;resetCons()

&#9;&#9;Data = {}
&#9;&#9;Data.FullyLoaded = false
&#9;&#9;&#9;&#9;
&#9;&#9;Window = {}
&#9;&#9;Window.Sets = {}

&#9;&#9;currStampGui = stamperGui:clone()
&#9;&#9;currStampGui.Parent = getPlayer().PlayerGui
&#9;&#9;wait()
&#9;&#9;setUpStamperGui()

&#9;&#9;if not(CancelDuringLoad) then
&#9;&#9;&#9;currStampGui.Parent = getPlayer().PlayerGui
&#9;&#9;&#9;Tool.SavedState.Value = currStampGui
&#9;&#9;end

&#9;&#9;Data.FullyLoaded = true
&#9;end

&#9;Mouse.KeyDown:connect(onInsertKeyDown)
end


function onUnequippedLocal()
&#9;if currStampGui then
&#9;&#9;Tool.SavedState.Value = currStampGui
&#9;&#9;currStampGui.Parent = nil
&#9;end
&#9;
&#9;pcall(function()
&#9;&#9;cancelAssetPlacement()
&#9;&#9;Data.Loading.Cancelled = true
&#9;end)
&#9;CancelDuringLoad = true
end


function killConnection(connection)
&#9;if connection then connection:disconnect() end
end


function resetCons()
&#9;killConnection(guiChangedCon)
&#9;killConnection(cloneButtonCon)
&#9;killConnection(partListClickCon)
&#9;killConnection(itemFrameChangedCon)
&#9;killConnection(setsPrevPageCon)
&#9;killConnection(setsNextPageCon)
&#9;killConnection(insertPanelCloseCon)
&#9;killConnection(minimizeCon)
&#9;killConnection(restoreCon)
end


function onAncestryChanged(child,parent)
&#9;if Tool.PlayerOwner.Value and not Tool:IsDescendantOf(Tool.PlayerOwner.Value) and not Tool:IsDescendantOf(Tool.PlayerOwner.Value.Character) then
&#9;&#9;--Tool was dropped in some way, so we need to nuke our external state
&#9;&#9;Tool.SavedState.Value = nil
&#9;&#9;resetCons()
&#9;end
end


function getMaxNumOfRecentParts()
&#9;return maxRecentParts
end


function pushRecentStackBack()
&#9;for i = getMaxNumOfRecentParts() - 1, 1, -1 do
&#9;&#9;recentPartStack[i + 1].AssetNameValue = recentPartStack[i].AssetNameValue
&#9;&#9;recentPartStack[i + 1].AssetIdValue = recentPartStack[i].AssetIdValue
&#9;&#9;recentPartStack[i + 1].InsertFrameButtonImage = recentPartStack[i].InsertFrameButtonImage
&#9;end
end


function clearMRUList()
&#9;local buttons = currStampGui.StamperPanel.StamperButtons.RecentFrame:GetChildren()
&#9;for i = 1, #buttons do
&#9;&#9;if recentPartStackCons[i] then recentPartStackCons[i]:disconnect() end
&#9;&#9;buttons[i].Visible = false
&#9;end
end


function mruButtonClick(position)
&#9;if recentPartStack[position].AssetIdValue == insertAsset.AssetId.Value then return end -- already stamping part
&#9;-- get rid of old part
&#9;signalStamperScript(&quot;&quot;,0,&quot;&quot;,&quot;&quot;,false)

&#9;--Show the dialog window
&#9;moveLoadingWindow()
&#9;signalStamperScript(recentPartStack[position].AssetNameValue, recentPartStack[position].AssetIdValue, recentPartStack[position].InsertFrameButtonImage, true)
end


function insertMRUButton(position)
&#9;local mruButton = currStampGui.StamperPanel.StamperButtons.RecentFrame:FindFirstChild(&quot;Button&quot; .. tostring(position))
&#9;mruButton.ButtonImage.Image = recentPartStack[position].InsertFrameButtonImage
&#9;if mruButton.ButtonImage.Image == &quot;&quot; then
&#9;&#9;mruButton.Text = recentPartStack[position].AssetNameValue
&#9;end

&#9;if recentPartStackCons[position] then pcall(function() recentPartStackCons[position]:Disconnect() end) end
&#9;recentPartStackCons[position] = mruButton.MouseButton1Click:connect(function() mruButtonClick(position) end)
&#9;mruButton.Visible = true
end


function refreshRecentParts()
&#9;if insertAsset.Image.Value == &quot;&quot; then return end -- we don&apos;t have an asset, get out of here
&#9;if not recentPartStack then return end -- if somehow not created yet (recentPartStack[i] calls below were nil somehow)
&#9;
&#9;local numOfRecentParts = getMaxNumOfRecentParts()

&#9;for i = 1,numOfRecentParts do
&#9;&#9;if insertAsset.AssetId and recentPartStack[i] and insertAsset.AssetId.Value == recentPartStack[i].AssetIdValue then -- already have part, don&apos;t push back
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end

&#9;pushRecentStackBack()

&#9;-- update our stack to show previously allocated part
&#9;recentPartStack[1].AssetNameValue = insertAsset.AssetName.Value
&#9;recentPartStack[1].AssetIdValue = insertAsset.AssetId.Value
&#9;recentPartStack[1].InsertFrameButtonImage =  insertAsset.Image.Value

&#9;clearMRUList()

&#9;for i = 1, numOfRecentParts do
&#9;&#9;if recentPartStack[i] and recentPartStack[i].AssetIdValue ~= &quot;&quot; then
&#9;&#9;&#9;insertMRUButton(i)
&#9;&#9;end
&#9;end
end


function updateGui(type)
&#9;if type == &quot;Main&quot; then
&#9;&#9;goToInsertPanel()
&#9;elseif type == &quot;EyeDropper&quot; then
&#9;&#9;goToClone()
&#9;elseif type == &quot;SideDialog&quot; then
&#9;&#9;goToStamp()
&#9;end
end
----------------------------------------------------------------------------------------



-- Lua Start Execution
setAssetUrls()

Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)
Tool.AncestryChanged:connect(onAncestryChanged)

waitForChild(variables, &quot;SwitchLoaderToDialog&quot;)
variables.SwitchLoaderToDialog.Changed:connect(function(prop)
&#9;if variables.SwitchLoaderToDialog.Value == true then
&#9;&#9;updateGui(variables.SwitchLoaderToDialog.DialogType.Value)
&#9;&#9;variables.SwitchLoaderToDialog.Value = false
&#9;end

end)

waitForChild(variables, &quot;ShowInvalidPlacement&quot;)
variables.ShowInvalidPlacement.Changed:connect(function(prop)
&#9;if variables.ShowInvalidPlacement.Value == true then
&#9;&#9;showHelp_pointToBuildingplate()
&#9;&#9;showBaseplateGuideArrows()
&#9;&#9;variables.ShowInvalidPlacement.Value = false
&#9;end
end)

waitForChild(variables, &quot;ShowMaxedOut&quot;)
variables.ShowMaxedOut.Changed:connect(function(prop)
&#9;if variables.ShowMaxedOut.Value == true then
&#9;&#9;showHelp_tooManyParts()
&#9;&#9;variables.ShowMaxedOut.Value = false
&#9;end
end)

waitForChild(variables, &quot;Stamped&quot;)
variables.Stamped.Changed:connect(function()
&#9;if variables.Stamped.Value == true then
&#9;&#9;refreshRecentParts()
&#9;end
end)
----------------------------------------------------------------------------------------</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX111">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Readme</string>
					<ProtectedString name="Source">--[[ 
&#9;Stamper Tool v1.0.0
&#9;

&#9;Welcome to the stamper tool readme!
&#9;Currently, this doc only exists to show the Stamper Tool Version!

]] </ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX112">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StampScript</string>
					<ProtectedString name="Source">-- basic functions

function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
----------------------------------------------------------------------------------------

-- Locals

local Tool = script.Parent

local Mouse
local mouseMoveCon
local mouseButton1DownCon
local mouseButton1UpCon
local cameraChangeCon

local walking = false

local pressedEsc = false

local billBoardOwnerGui = nil

local cluster = game.Workspace:FindFirstChild(&quot;Terrain&quot;)

local gInitial90DegreeRotations = 0
local gStaticTrans = 1
local gDesiredTrans = 0.7
local transFadeInTime = 0.5
local fadeInDelayTime = 0.5
local eyedropperOffGridTolerance = 0.01

local insertBoundingBoxOverlapVector = Vector3.new(1, 1, 1) -- we can still stamp if our character extrudes into the target stamping space by 1 or fewer units

local useAssetVersionId = false


-- for high-scalability display
local adornPart = Instance.new(&quot;Part&quot;)
adornPart.Parent = nil
adornPart.formFactor = &quot;Custom&quot;
adornPart.Size = Vector3.new(4, 4, 4)
adornPart.CFrame = CFrame.new()

local adorn = Instance.new(&quot;SelectionBox&quot;)
adorn.Color = BrickColor.new(&quot;Toothpaste&quot;)
adorn.Adornee = adornPart
adorn.Visible = true
adorn.Transparency = 0
adorn.Name = &quot;HighScalabilityStamperLine&quot;
adorn.Parent = nil

local terrainSelectionBox = Instance.new(&quot;Part&quot;)
terrainSelectionBox.Parent = nil
terrainSelectionBox.formFactor = &quot;Custom&quot;
terrainSelectionBox.Size = Vector3.new(4, 4, 4)
terrainSelectionBox.CFrame = CFrame.new()

local HighScalabilityLine = {}
HighScalabilityLine.Start = nil
HighScalabilityLine.End = nil
HighScalabilityLine.Adorn = adorn
HighScalabilityLine.AdornPart = adornPart
HighScalabilityLine.InternalLine = nil
HighScalabilityLine.NewHint = true

-- for higher dimensional megacluster part stamping
HighScalabilityLine.MorePoints = {nil, nil}
HighScalabilityLine.MoreLines = {nil, nil}
HighScalabilityLine.Dimensions = 1

waitForChild(Tool,&quot;LuaGlobalVariables&quot;)
local variables = Tool.LuaGlobalVariables
waitForChild(variables,&quot;ShowInvalidPlacement&quot;)
waitForChild(variables, &quot;Stamped&quot;)
waitForChild(Tool,&quot;ErrorBox&quot;)
waitForChild(variables, &quot;ShowAdminCategories&quot;)
local errorBox = Tool.ErrorBox

waitForChild(variables, &quot;IsRestricted&quot;)
waitForChild(variables, &quot;MouseClick&quot;)
click = variables.MouseClick

local Data = {}
Data.Stamp = {}
Data.Loading = {}

local guiScriptIsLoadingSomething = false
local unstampableSurface = false

local eyeDropperConnection, eyeDropperMoveConnection

local playerModel
local player

local lastTargetCFrame = nil
local lastTargetTerrainOrientation = 0

-- For Restricting Stamper Tool
local isRestricted = variables.IsRestricted.Value
local adminAccess = variables.ShowAdminCategories.Value

-- For Delete highlighting
local selectionBox
local currentSelection
local currentSelectionColors = {}

if isRestricted then waitForChild(game.Workspace, &quot;BaseplateBumpers&quot;) end
----------------------------------------------------------------------------------------

-- Functions
function hint(label)
&#9;-- Pass in a string, it shows a top hint.  (Replaces previous hint, if exists)
&#9;_player = game.Players:GetPlayerFromCharacter(Tool.Parent)
&#9;if(_player.PlayerGui:FindFirstChild(&quot;topHint&quot;)~=nil) then
&#9;&#9;local topHint = _player.PlayerGui.topHint
&#9;&#9;topHint.Add.Label.Value = label
&#9;&#9;topHint.Add.Width.Value = 3 -- widest width
&#9;&#9;topHint.Add.Time.Value = 5
&#9;&#9;topHint.Add.Disabled = true
&#9;&#9;topHint.Add.Disabled = false
&#9;end
end


function getClosestColorToTerrainMaterial(terrainValue)
&#9;if terrainValue == 1 then
&#9;&#9;return BrickColor.new(&quot;Bright green&quot;)
&#9;elseif terrainValue == 2 then
&#9;&#9;return BrickColor.new(&quot;Bright yellow&quot;)
&#9;elseif terrainValue == 3 then
&#9;&#9;return BrickColor.new(&quot;Bright red&quot;)
&#9;elseif terrainValue == 4 then
&#9;&#9;return BrickColor.new(&quot;Medium stone grey&quot;)
&#9;else
&#9;&#9;return BrickColor.new(&quot;Bright green&quot;)
&#9;end
end


local manualWeldTable = {}
local manualWeldParentTable = {}
function saveTheWelds(object)
&#9;if object:IsA(&quot;ManualWeld&quot;) or object:IsA(&quot;Rotate&quot;) then
&#9;&#9;table.insert(manualWeldTable, object)
&#9;&#9;table.insert(manualWeldParentTable, object.Parent)
&#9;else
&#9;&#9;local children = object:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;saveTheWelds(children[i])
&#9;&#9;end
&#9;end
end

function restoreTheWelds()
&#9;for i = 1, #manualWeldTable do
&#9;&#9;manualWeldTable[i].Parent = manualWeldParentTable[i]
&#9;end
end


function findSeatsInModel(parent, seatTable)
&#9;if not parent then return end

&#9;if parent.className == &quot;Seat&quot; or parent.className == &quot;VehicleSeat&quot; then
&#9;&#9;table.insert(seatTable, parent)
&#9;end
&#9;local myChildren = parent:GetChildren()
&#9;for j = 1, #myChildren do
&#9;&#9;findSeatsInModel(myChildren[j], seatTable)
&#9;end
end

function setSeatEnabledStatus(model, isEnabled)
&#9;local seatList = {}
&#9;findSeatsInModel(model, seatList)

&#9;if isEnabled then
&#9;&#9;-- remove any welds called &quot;SeatWeld&quot; in seats
&#9;&#9;for i = 1, #seatList do
&#9;&#9;&#9;local nextSeat = seatList[i]:FindFirstChild(&quot;SeatWeld&quot;)
&#9;&#9;&#9;while nextSeat do nextSeat:Remove() nextSeat = seatList[i]:FindFirstChild(&quot;SeatWeld&quot;) end
&#9;&#9;end
&#9;else
&#9;&#9;-- put a weld called &quot;SeatWeld&quot; in every seat
&#9;&#9;--   this tricks it into thinking there&apos;s already someone sitting there, and it won&apos;t make you sit XD
&#9;&#9;for i = 1, #seatList do
&#9;&#9;&#9;local fakeWeld = Instance.new(&quot;Weld&quot;)
&#9;&#9;&#9;fakeWeld.Name = &quot;SeatWeld&quot;
&#9;&#9;&#9;fakeWeld.Parent = seatList[i]
&#9;&#9;end
&#9;end
end


function UnlockInstances(object)

&#9;if object:IsA(&quot;BasePart&quot;) then
&#9;&#9;object.Locked = false
&#9;end
&#9;for index,child in pairs(object:GetChildren()) do
&#9;&#9;UnlockInstances(child)
&#9;end

end

function generateOwnerGui(playerName)
&#9;local gui = Instance.new(&quot;BillboardGui&quot;)
&#9;gui.Name = &quot;PlayerStamperTagGui&quot;
&#9;gui.StudsOffset = Vector3.new(0,1,0)
&#9;gui.ExtentsOffset = Vector3.new(0,1,0)
&#9;gui.Size = UDim2.new(5,0,2,0)
&#9;pcall(function() gui.PlayerToHideFrom = game.Players.LocalPlayer end)

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.BackgroundTransparency = 0.5
&#9;frame.Name = &quot;OwnerFrame&quot;
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;frame.Parent = gui
&#9;
&#9;local ownerName = Instance.new(&quot;TextLabel&quot;)
&#9;ownerName.Name = &quot;OwnerName&quot;
&#9;ownerName.Size = UDim2.new(1,0,1,0)
&#9;ownerName.Text = playerName
&#9;ownerName.Font = Enum.Font.ArialBold
&#9;ownerName.FontSize = Enum.FontSize.Size14
&#9;ownerName.TextWrap = true
&#9;ownerName.TextColor3 = Color3.new(1,1,1)
&#9;ownerName.TextStrokeTransparency = 0
&#9;ownerName.BackgroundTransparency = 1
&#9;ownerName.Parent = frame

&#9;return gui
end



function getPlayer()
&#9;return game.Players:GetPlayerFromCharacter(script.Parent.Parent)
end

function beginInsertAssetStamp(assetName, assetId, image, stampMode)
&#9;-- trying to stop assets, gone back to Main Stamp Dialog
&#9;if assetId == 0 then
&#9;&#9;guiScriptIsLoadingSomething = true
&#9;&#9;cancelAssetPlacement()
&#9;&#9;return
&#9;end
&#9;if assetId &lt; 0 then
&#9;&#9;guiScriptIsLoadingSomething = true
&#9;&#9;cancelAssetPlacement()
&#9;&#9;setupDraggableClone()
&#9;&#9;wait() -- need this so onInsertMouseMove() can sync up with setupDraggableClone()
&#9;&#9;onInsertMouseMove()
&#9;&#9;guiScriptIsLoadingSomething = false
&#9;&#9;return
&#9;end
&#9;-- This call will cause a &quot;wait&quot; until the data comes back
&#9;-- below we wait a max of 8 seconds before deciding to bail out on loading
&#9;local root
&#9;local loader
&#9;loading = true
&#9;if useAssetVersionId then
&#9;&#9;loader = coroutine.create(function()&#9;
&#9;&#9;&#9;root = game:GetService(&quot;InsertService&quot;):LoadAssetVersion(assetId)
&#9;&#9;&#9;loading = false
&#9;&#9;end)
&#9;&#9;coroutine.resume(loader)
&#9;else
&#9;&#9;loader = coroutine.create(function()&#9;
&#9;&#9;&#9;root = game:GetService(&quot;InsertService&quot;):LoadAsset(assetId)
&#9;&#9;&#9;loading = false
&#9;&#9;end)
&#9;&#9;coroutine.resume(loader)
&#9;end

&#9;local lastGameTime = 0
&#9;local totalTime = 0
&#9;local maxWait = 8
&#9;while loading and totalTime &lt; maxWait do
&#9;&#9;lastGameTime = tick()
&#9;&#9;wait(1)
&#9;&#9;totalTime = totalTime + tick() - lastGameTime
&#9;end
&#9;loading = false

&#9;if totalTime &gt;= maxWait or pressedEsc then
&#9;&#9;Data.Loading.Cancelled = true
&#9;&#9;pressedEsc = false
&#9;else
&#9;&#9;Data.Loading.Cancelled = false
&#9;end


&#9;if Data.Loading.Cancelled then
&#9;&#9;--The user got bored and wandered off
&#9;&#9;--Just delete the model from the world... a shame we loaded it when they got bored
&#9;&#9;-- 12/28/2010: Putting this inside a pcall (on gametest, first time equipping stamper, this was being called with root=nil.) (Jahr)
&#9;&#9;pcall(function() root:Remove() end)
&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;else
&#9;&#9;if root == nil then
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if not root:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local instances = root:GetChildren()
&#9;&#9;if #instances == 0 then
&#9;&#9;&#9;root:Remove()
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;--Unlock all parts that are inserted, to make sure they are editable
&#9;&#9;UnlockInstances(root)

&#9;&#9;--Continue the insert process
&#9;&#9;root.Name = &quot;InsertedObject&quot; .. assetId

&#9;&#9;--Examine the contents and decide what it looks like
&#9;&#9;for pos, instance in pairs(instances) do
&#9;&#9;&#9;--Single instance objects might be treated special, decals/skyboxes
&#9;&#9;&#9;if instance:IsA(&quot;Decal&quot;) then
&#9;&#9;&#9;&#9;--Current system here stops after finding one Decal (and gives you Decal tool)
&#9;&#9;&#9;&#9;--We should do the same (probably)
&#9;&#9;&#9;&#9;beginInsertDecal(instance)
&#9;&#9;&#9;&#9;root:Remove()

&#9;&#9;&#9;&#9;Window.Stamp.Frame.Visible = true
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;elseif instance:IsA(&quot;Team&quot;) then
&#9;&#9;&#9;&#9;instance.Parent = game:GetService(&quot;Teams&quot;)
&#9;&#9;&#9;elseif instance:IsA(&quot;SpawnLocation&quot;) then
&#9;&#9;&#9;&#9;-- uh.............
&#9;&#9;&#9;elseif instance:IsA(&quot;HopperBin&quot;) then
&#9;&#9;&#9;&#9;-- Must go into the starterPack, prompt user?
&#9;&#9;&#9;elseif instance:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;-- Ask them if it should go in StarterPack?
&#9;&#9;&#9;elseif instance:IsA(&quot;Sky&quot;) then
&#9;&#9;&#9;&#9;local lightingService = game:GetService(&quot;Lighting&quot;)
&#9;&#9;&#9;&#9;for index,child in pairs(lightingService:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;Sky&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;child:Remove();
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;instance.Parent = lightingService
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;else

&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if #root:GetChildren() == 0 then
&#9;&#9;&#9;root:Remove()
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;signalInsertComplete(&quot;SideDialog&quot;)
&#9;&#9;
&#9;&#9;cancelAssetPlacement()
&#9;&#9;Data.Stamp.Model = root
&#9;&#9;setupDraggableClone()
&#9;&#9;guiScriptIsLoadingSomething = false
&#9;end

end

function beginInsertDecal(decal)

&#9;Data.Stamp.DecalSelection = Instance.new(&quot;SurfaceSelection&quot;)
&#9;Data.Stamp.DecalSelection.Color = BrickColor.new(&quot;Bright orange&quot;)
&#9;Data.Stamp.DecalSelection.archivable = false
&#9;Data.Stamp.DecalSelection.Parent = getPlayer().PlayerGui

&#9;--Save the decal in our Lua code for later use
&#9;Data.Stamp.Decal = decal
&#9;Data.Stamp.Decal.Parent = nil

end


-- signal to gui to switch frames
function signalInsertComplete(type)

&#9;if type == &quot;SideDialog&quot; then
&#9;&#9;variables.SwitchLoaderToDialog.DialogType.Value = &quot;SideDialog&quot;
&#9;&#9;variables.SwitchLoaderToDialog.Value = true
&#9;elseif type == &quot;Main&quot; then
&#9;&#9;variables.SwitchLoaderToDialog.DialogType.Value = &quot;Main&quot;
&#9;&#9;variables.SwitchLoaderToDialog.Value = true
&#9;elseif type == &quot;EyeDropper&quot; then
&#9;&#9;variables.SwitchLoaderToDialog.DialogType.Value = &quot;EyeDropper&quot;
&#9;&#9;variables.SwitchLoaderToDialog.Value = true
&#9;end

&#9;-- needed to make sure we disconnect eyedroper handler
&#9;if type ~= &quot;EyeDropper&quot; then
&#9;&#9;if eyeDropperConnection then
&#9;&#9;&#9;eyeDropperConnection:disconnect()
&#9;&#9;&#9;eyeDropperConnection = nil
&#9;&#9;end
&#9;&#9;if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end

&#9;&#9;if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end
&#9;end
&#9;clearSelection()

end


function p(assetName, assetId, image, stampMode)
&#9;-- trying to stop assets, gone back to Main Stamp Dialog
&#9;if assetId == 0 then
&#9;&#9;cancelAssetPlacement()
&#9;&#9;return
&#9;end

&#9;-- This call will cause a &quot;wait&quot; until the data comes back
&#9;-- below we wait a max of 8 seconds before deciding to bail out on loading
&#9;local root
&#9;local loader
&#9;loading = true
&#9;if useAssetVersionId then
&#9;&#9;loader = coroutine.create(function()
&#9;&#9;&#9;root = game:GetService(&quot;InsertService&quot;):LoadAssetVersion(assetId)
&#9;&#9;&#9;loading = false
&#9;&#9;end)
&#9;&#9;coroutine.resume(loader)
&#9;else
&#9;&#9;loader = coroutine.create(function()&#9;
&#9;&#9;&#9;root = game:GetService(&quot;InsertService&quot;):LoadAsset(assetId)
&#9;&#9;&#9;loading = false
&#9;&#9;end)
&#9;&#9;coroutine.resume(loader)
&#9;end

&#9;local lastGameTime = 0
&#9;local totalTime = 0
&#9;local maxWait = 8
&#9;while loading and totalTime &lt; maxWait do
&#9;&#9;lastGameTime = tick()
&#9;&#9;wait(1)
&#9;&#9;totalTime = totalTime + tick() - lastGameTime
&#9;end
&#9;loading = false

&#9;if totalTime &gt;= maxWait or pressedEsc then
&#9;&#9;Data.Loading.Cancelled = true
&#9;&#9;pressedEsc = false
&#9;else
&#9;&#9;Data.Loading.Cancelled = false
&#9;end


&#9;if Data.Loading.Cancelled then
&#9;&#9;--The user got bored and wandered off
&#9;&#9;--Just delete the model from the world... a shame we loaded it when they got bored
&#9;&#9;-- 12/28/2010: Putting this inside a pcall (on gametest, first time equipping stamper, this was being called with root=nil.) (Jahr)
&#9;&#9;pcall(function() root:Remove() end)
&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;else
&#9;&#9;local instances = root:GetChildren()
&#9;&#9;if #instances == 0 then
&#9;&#9;&#9;root:Remove()
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;--Unlock all parts that are inserted, to make sure they are editable
&#9;&#9;UnlockInstances(root)

&#9;&#9;--Continue the insert process
&#9;&#9;root.Name = &quot;InsertedObject&quot; .. assetId

&#9;&#9;--Examine the contents and decide what it looks like
&#9;&#9;for pos, instance in pairs(instances) do
&#9;&#9;&#9;--Single instance objects might be treated special, decals/skyboxes
&#9;&#9;&#9;if instance:IsA(&quot;Decal&quot;) then
&#9;&#9;&#9;&#9;--Current system here stops after finding one Decal (and gives you Decal tool)
&#9;&#9;&#9;&#9;--We should do the same (probably)
&#9;&#9;&#9;&#9;beginInsertDecal(instance)
&#9;&#9;&#9;&#9;root:Remove()

&#9;&#9;&#9;&#9;Window.Stamp.Frame.Visible = true
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;elseif instance:IsA(&quot;Team&quot;) then
&#9;&#9;&#9;&#9;instance.Parent = game:GetService(&quot;Teams&quot;)
&#9;&#9;&#9;elseif instance:IsA(&quot;SpawnLocation&quot;) then
&#9;&#9;&#9;&#9;-- uh.............
&#9;&#9;&#9;elseif instance:IsA(&quot;HopperBin&quot;) then
&#9;&#9;&#9;&#9;-- Must go into the starterPack, prompt user?
&#9;&#9;&#9;elseif instance:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;-- Ask them if it should go in StarterPack?
&#9;&#9;&#9;elseif instance:IsA(&quot;Sky&quot;) then
&#9;&#9;&#9;&#9;local lightingService = game:GetService(&quot;Lighting&quot;)
&#9;&#9;&#9;&#9;for index,child in pairs(lightingService:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;Sky&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;child:Remove();
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;instance.Parent = lightingService
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;else

&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if #root:GetChildren() == 0 then
&#9;&#9;&#9;root:Remove()
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;signalInsertComplete(&quot;SideDialog&quot;)
&#9;&#9;
&#9;&#9;cancelAssetPlacement()
&#9;&#9;Data.Stamp.Model = root
&#9;&#9;setupDraggableClone()
&#9;end

end


function positionPartsAtCFrame3(partOrModel, aCFrame)

&#9;local insertCFrame
&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;--insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[1].CFrame
&#9;&#9;-- we assume model has at least one part in it; need to find first part
&#9;&#9;i = 1
&#9;&#9;while (i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;Part&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;TrussPart&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;WedgePart&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;CornerWedgePart&quot;)) do
&#9;&#9;&#9;i = i + 1
&#9;&#9;end
&#9;&#9;insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame

&#9;&#9;for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
&#9;&#9;&#9;if object:IsA(&quot;Flag&quot;) then object = object.Handle end
&#9;&#9;&#9;if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;)) then
&#9;&#9;&#9;&#9;local posPartInWorld = object.Position
&#9;&#9;&#9;&#9;local posPart1InWorld = insertCFrame.p
&#9;&#9;&#9;&#9;local newPosPartInWorld = posPartInWorld - posPart1InWorld + aCFrame.p
&#9;
&#9;&#9;&#9;&#9;local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = object.CFrame:components()
&#9;&#9;&#9;&#9;object.CFrame = CFrame.new(newPosPartInWorld.x, newPosPartInWorld.y, newPosPartInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;else
&#9;&#9;Data.Stamp.CurrentParts[1].CFrame = aCFrame
&#9;end

end


-- For Restricting Stamper Tool (isRestricted)
function inBounds(object)

&#9;for part, transparency in pairs(object) do
&#9;&#9;if part:IsA(&quot;Part&quot;) or part:IsA(&quot;WedgePart&quot;) or part:IsA(&quot;CornerWedgePart&quot;) or part:IsA(&quot;TrussPart&quot;) then
&#9;&#9;&#9;if not partInBounds(part) then return false end
&#9;&#9;elseif part:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;local primPart = object.PrimaryPart
&#9;&#9;&#9;if not partInBounds(primPart) then return false end
&#9;&#9;end
&#9;end
&#9;return true

end

function partInBounds(part)

&#9;if part == nil then return false end

&#9;local xOne= buildingPlate.Position.x + buildingPlate.Size.x/2
&#9;local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
&#9;local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
&#9;local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2

&#9;if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
&#9;if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end

&#9;return true

end



function canSelectObject(part)
&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function canEyeDropperObject(part)
&#9;local stamperTag = part.Parent:FindFirstChild(&quot;RobloxStamper&quot;)
&#9;if stamperTag == nil then stamperTag = part:FindFirstChild(&quot;RobloxStamper&quot;) end

&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60 and stamperTag ~= nil
end

function isOnGrid(partOrModel)
&#9;-- first check to see if off-grid, and if so, prevent eyedropperage
&#9;&#9;local modelExtentsInWorldCoords
&#9;&#9;if partOrModel:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;modelExtentsInWorldCoords = partOrModel:GetModelCFrame():vectorToWorldSpace(partOrModel:GetModelSize())
&#9;&#9;else
&#9;&#9;&#9;modelExtentsInWorldCoords = partOrModel.CFrame:vectorToWorldSpace(partOrModel.Size)
&#9;&#9;end

&#9;&#9;-- we now simply check to see if the above property fits in a 4x4x4 gridspace
&#9;&#9;offX = math.fmod(math.abs(modelExtentsInWorldCoords.X), 4)
&#9;&#9;offY = math.fmod(math.abs(modelExtentsInWorldCoords.Y), 4)
&#9;&#9;offZ = math.fmod(math.abs(modelExtentsInWorldCoords.Z), 4)

&#9;&#9;local numberOfAxesOffGrid = 0
&#9;&#9;if math.min(offX, 4 - offX) &gt; eyedropperOffGridTolerance then numberOfAxesOffGrid = numberOfAxesOffGrid + 1 end
&#9;&#9;if math.min(offY, 4 - offY) &gt; eyedropperOffGridTolerance then numberOfAxesOffGrid = numberOfAxesOffGrid + 1 end
&#9;&#9;if math.min(offZ, 4 - offZ) &gt; eyedropperOffGridTolerance then numberOfAxesOffGrid = numberOfAxesOffGrid + 1 end

&#9;&#9;if numberOfAxesOffGrid &gt; 1 then return false -- we allow one axis to be not fit to grid, since any rotation must necessarily affect &gt;= 2 axes (some of the models are like 4x4x6 :(  ).
&#9;&#9;else return true end
end


-- below is a helper function to help get the model surface instead of the part surface [for allowing a side to elect out of making joints automatically]
function calcRayHitTime(rayStart, raySlope, intersectionPlane)
&#9;if math.abs(raySlope) &lt; .01 then return 0 end -- 0 slope --&gt;  we just say intersection time is 0, and sidestep this dimension
&#9;-- rayStart + t*raySlope = intersectionPlane, so t = (intersectionPlane - rayStart) / raySlope
&#9;return (intersectionPlane - rayStart) / raySlope
end


function modelTargetSurface(partOrModel, rayStart, rayEnd)
&#9;if not partOrModel then
&#9;&#9;return 0
&#9;end

&#9;local modelCFrame = nil
&#9;local modelSize = nil
&#9;if partOrModel:IsA(&quot;Model&quot;) then
&#9;&#9;modelCFrame = partOrModel:GetModelCFrame()
&#9;&#9;modelSize = partOrModel:GetModelSize()
&#9;else
&#9;&#9;modelCFrame = partOrModel.CFrame
&#9;&#9;modelSize = partOrModel.Size
&#9;end

&#9;local mouseRayStart = modelCFrame:pointToObjectSpace(rayStart)
&#9;local mouseRayEnd = modelCFrame:pointToObjectSpace(rayEnd)
&#9;local mouseSlope = mouseRayEnd - mouseRayStart

&#9;local xPositive = 1
&#9;local yPositive = 1
&#9;local zPositive = 1
&#9;if mouseSlope.X &gt; 0 then xPositive = -1 end
&#9;if mouseSlope.Y &gt; 0 then yPositive = -1 end
&#9;if mouseSlope.Z &gt; 0 then zPositive = -1 end

&#9;-- find which surface the transformed mouse ray hits (using modelSize):
&#9;local xHitTime = calcRayHitTime(mouseRayStart.X, mouseSlope.X, modelSize.X/2 * xPositive)
&#9;local yHitTime = calcRayHitTime(mouseRayStart.Y, mouseSlope.Y, modelSize.Y/2 * yPositive)
&#9;local zHitTime = calcRayHitTime(mouseRayStart.Z, mouseSlope.Z, modelSize.Z/2 * zPositive)

&#9;local hitFace = 0

&#9;--if xHitTime &gt;= 0 and yHitTime &gt;= 0 and zHitTime &gt;= 0 then
&#9;if xHitTime &gt; yHitTime then
&#9;&#9;if xHitTime &gt; zHitTime then
&#9;&#9;&#9;-- xFace is hit
&#9;&#9;&#9;hitFace = 1*xPositive
&#9;&#9;else
&#9;&#9;&#9;-- zFace is hit
&#9;&#9;&#9;hitFace = 3*zPositive
&#9;&#9;end
&#9;else
&#9;&#9;if yHitTime &gt; zHitTime then
&#9;&#9;&#9;-- yFace is hit
&#9;&#9;&#9;hitFace = 2*yPositive
&#9;&#9;else
&#9;&#9;&#9;-- zFace is hit
&#9;&#9;&#9;hitFace = 3*zPositive
&#9;&#9;end
&#9;end

&#9;return hitFace
end


-- helper function for truncating to 45-degree angles on a 2D plane
function truncateToCircleEighth(bigValue, littleValue)
&#9;local big = math.abs(bigValue)
&#9;local little = math.abs(littleValue)
&#9;local hypotenuse = math.sqrt(big*big + little*little)
&#9;local frac = little / hypotenuse

&#9;local bigSign = 1
&#9;local littleSign = 1
&#9;if bigValue &lt; 0 then bigSign = -1 end
&#9;if littleValue &lt; 0 then littleSign = -1 end

&#9;if frac &gt; .382683432 then
&#9;&#9;-- between 22.5 and 45 degrees, so truncate to 45-degree tilt
&#9;&#9;return .707106781 * hypotenuse * bigSign, .707106781 * hypotenuse * littleSign
&#9;else 
&#9;&#9;-- between 0 and 22.5 degrees, so truncate to 0-degree tilt
&#9;&#9;return hypotenuse * bigSign, 0
&#9;end
end

function onInsertMouseMove()

&#9;if Data.Stamp.MovingLock then
&#9;&#9;return
&#9;end

&#9;-- check to see if mouse is still active, and return otherwise!
&#9;if not pcall(function () if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;) == nil then return true else return false end end) then print(&quot;ERRORED OUT&quot;) game.JointsService:SetJoinAfterMoveTarget(nil) Mouse = nil return end

&#9;if isRestricted and Mouse then
&#9;&#9;Mouse.TargetFilter = game.Workspace.BaseplateBumpers
&#9;end

&#9;Data.Stamp.MovingLock = true
&#9;if Data.Stamp.Dragger == nil then
&#9;&#9;if Data.Stamp.Model ~= nil then
&#9;&#9;&#9;if isRestricted then
&#9;&#9;&#9;&#9;if checkPartLimit() then
&#9;&#9;&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;variables.ShowMaxedOut.Value = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;-- REM TL: Data.Stamp.Dragger:MouseMove(Mouse.UnitRay)
&#9;&#9;-- don&apos;t move with dragger - will move in one step on mouse down
&#9;&#9;-- draw ghost at acceptable positions
&#9;&#9;configFound, targetCFrame, targetSurface = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
&#9;&#9;if configFound then

&#9;&#9;&#9;&#9;if autoAlignToFace() and targetSurface ~= 1 and targetSurface ~= 4 then
&#9;&#9;&#9;&#9;-- pre-rotate the flag or portrait so it&apos;s aligned correctly
&#9;&#9;&#9;&#9;--local currCFrame
&#9;&#9;&#9;&#9;--if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then currCFrame = Data.Stamp.CurrentParts[1]:GetModelCFrame()
&#9;&#9;&#9;&#9;--else currCFrame = Data.Stamp.CurrentParts[1].CFrame end

&#9;&#9;&#9;&#9;local numRotations = 0 -- update this according to how many rotations you need to get it to target surface
&#9;&#9;&#9;&#9;if targetSurface == 3 then numRotations = 0 - gInitial90DegreeRotations + autoAlignToFace()
&#9;&#9;&#9;&#9;elseif targetSurface == 0 then numRotations = 2 - gInitial90DegreeRotations + autoAlignToFace()
&#9;&#9;&#9;&#9;elseif targetSurface == 5 then numRotations = 3 - gInitial90DegreeRotations + autoAlignToFace()
&#9;&#9;&#9;&#9;elseif targetSurface == 2 then numRotations = 1 - gInitial90DegreeRotations + autoAlignToFace() end
&#9;&#9;&#9;&#9;

&#9;&#9;&#9;&#9;local ry = math.pi/2
&#9;&#9;&#9;&#9;local rotCF = CFrame.fromEulerAnglesXYZ(0, ry*numRotations, 0)
&#9;&#9;&#9;&#9;gInitial90DegreeRotations = gInitial90DegreeRotations + numRotations
&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;&#9;for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;&#9;if object:IsA(&quot;Flag&quot;) then object = object.Handle end
&#9;&#9;&#9;&#9;&#9;&#9;if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;object.CFrame = rotCF * object.CFrame
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end



&#9;&#9;&#9;-- CODE TO CHECK FOR DRAGGING GHOST PART INTO A COLLIDING STATE
&#9;&#9;&#9;local minBB, maxBB = getBoundingBoxInWorldCoordinates(Data.Stamp.CurrentParts[1])
&#9;
&#9;&#9;&#9;-- need to offset by distance to be dragged
&#9;&#9;&#9;local currModelCFrame
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;&#9;-- we assume model has at least one part in it; need to find first part
&#9;&#9;&#9;&#9;i = 1
&#9;&#9;&#9;&#9;while i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;BasePart&quot;) do
&#9;&#9;&#9;&#9;&#9;i = i + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;currModelCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame
&#9;&#9;&#9;else currModelCFrame = Data.Stamp.CurrentParts[1].CFrame end
&#9;&#9;&#9;minBB = minBB + targetCFrame.p - currModelCFrame.p
&#9;&#9;&#9;maxBB = maxBB + targetCFrame.p - currModelCFrame.p

&#9;&#9;&#9;-- don&apos;t drag into terrain
&#9;&#9;&#9;if clusterPartsInRegion(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector) then 
&#9;&#9;&#9;&#9;if lastTargetCFrame then 
&#9;&#9;&#9;&#9;&#9;positionPartsAtCFrame3(thingToDrag, lastTargetCFrame) 
&#9;&#9;&#9;&#9;&#9;if (Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot;) and (Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;ClusterMaterial&quot;)) and (Data.Stamp.CurrentParts[1].ClusterMaterial:IsA(&quot;Vector3Value&quot;)) then 
&#9;&#9;&#9;&#9;&#9;&#9;local clusterMat = Data.Stamp.CurrentParts[1].ClusterMaterial
&#9;&#9;&#9;&#9;&#9;&#9;clusterMat.Value = Vector3.new(clusterMat.Value.X, clusterMat.Value.Y, lastTargetTerrainOrientation)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Stamp.MovingLock = false
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector), currentSelection, 100)
&#9;&#9;&#9;for b = 1, #blockingParts do
&#9;&#9;&#9;&#9;-- put code back here if we want to prevent stamper from dragging ghost parts into other stamped models (once Region3 fix goes out)
&#9;&#9;&#9;end

&#9;&#9;&#9;positionPartsAtCFrame3(Data.Stamp.CurrentParts[1], targetCFrame)
&#9;&#9;&#9;lastTargetCFrame = targetCFrame  -- successful positioning, so update &apos;dat cframe
&#9;&#9;&#9;if (Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot;) and (Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;ClusterMaterial&quot;)) and (Data.Stamp.CurrentParts[1].ClusterMaterial:IsA(&quot;Vector3Value&quot;)) then lastTargetTerrainOrientation = Data.Stamp.CurrentParts[1].ClusterMaterial.Value.Z end


&#9;&#9;&#9;-- auto break joints code
&#9;&#9;&#9;if Mouse and Mouse.Target and Mouse.Target.Parent then
&#9;&#9;&#9;&#9;local modelInfo = Mouse.Target:FindFirstChild(&quot;RobloxModel&quot;)
&#9;&#9;&#9;&#9;if not modelInfo then modelInfo = Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;) end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local myModelInfo = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;UnstampableFaces&quot;)

&#9;&#9;&#9;&#9;--if (modelInfo and modelInfo.Parent:FindFirstChild(&quot;UnstampableFaces&quot;)) or (modelInfo and myModelInfo) then  -- need better targetSurface calcs
&#9;&#9;&#9;&#9;if (true) then
&#9;&#9;&#9;&#9;&#9;local breakingFaces = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;local myBreakingFaces = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;if modelInfo and modelInfo.Parent:FindFirstChild(&quot;UnstampableFaces&quot;) then breakingFaces = modelInfo.Parent.UnstampableFaces.Value end
&#9;&#9;&#9;&#9;&#9;if myModelInfo then myBreakingFaces = myModelInfo.Value end
&#9;&#9;&#9;&#9;&#9;local hitFace = 0

&#9;&#9;&#9;&#9;&#9;if modelInfo then hitFace = modelTargetSurface(modelInfo.Parent, game.Workspace.CurrentCamera.CoordinateFrame.p, Mouse.Hit.p) end

&#9;&#9;&#9;&#9;&#9;-- are we stamping TO an unstampable surface?
&#9;&#9;&#9;&#9;&#9;for bf in string.gmatch(breakingFaces, &quot;[^,]+&quot;) do
&#9;&#9;&#9;&#9;&#9;&#9;if hitFace == tonumber(bf) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- return before we hit the JointsService code below!
&#9;&#9;&#9;&#9;&#9;&#9;&#9;unstampableSurface = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;game.JointsService:ClearJoinAfterMoveJoints() -- clear the JointsService cache
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Data.Stamp.MovingLock = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;-- now we have to cast the ray back in the other direction to find the surface we&apos;re stamping FROM
&#9;&#9;&#9;&#9;&#9;hitFace = modelTargetSurface(Data.Stamp.CurrentParts[1], Mouse.Hit.p, game.Workspace.CurrentCamera.CoordinateFrame.p)

&#9;&#9;&#9;&#9;&#9;-- are we stamping WITH an unstampable surface?
&#9;&#9;&#9;&#9;&#9;for bf in string.gmatch(myBreakingFaces, &quot;[^,]+&quot;) do
&#9;&#9;&#9;&#9;&#9;&#9;if hitFace == tonumber(bf) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;unstampableSurface = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;game.JointsService:ClearJoinAfterMoveJoints() -- clear the JointsService cache
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Data.Stamp.MovingLock = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;-- just need to match breakingFace against targetSurface using rotation supplied by modelCFrame
&#9;&#9;&#9;&#9;&#9;-- targetSurface: 1 is top, 4 is bottom, 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;end

&#9;&#9;-- to show joints during the mouse move
&#9;&#9;unstampableSurface = false
      game.JointsService:SetJoinAfterMoveInstance(Data.Stamp.CurrentParts[1])

&#9;&#9;-- most common mouse inactive error occurs here, so check mouse active one more time in a pcall
&#9;&#9;if not pcall(function () if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;) == nil then return true else return false end end) then print(&quot;ERRORED OUT&quot;) game.JointsService:ClearJoinAfterMoveJoints() Mouse = nil Data.Stamp.MovingLock = false return end

      if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;) == nil then
&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveTarget(Mouse.Target)
      else
&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveTarget(nil)
      end
      game.JointsService:ShowPermissibleJoints()

&#9;&#9;-- here we allow for a line of high-scalability parts
&#9;&#9;if (Data.Stamp.CurrentParts[1] and Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot;) and HighScalabilityLine.Start then
&#9;&#9;&#9;HighScalabilityLine.End = Data.Stamp.CurrentParts[1].CFrame.p

&#9;&#9;&#9;local line
&#9;&#9;&#9;local line2 = Vector3.new(0, 0, 0)
&#9;&#9;&#9;local line3 = Vector3.new(0, 0, 0)

&#9;&#9;&#9;if HighScalabilityLine.Dimensions == 1 then
&#9;&#9;&#9;&#9;-- extract the line from these positions and limit to a 2D plane made from 2 of the world axes
&#9;&#9;&#9;&#9;--   then use dominating axis to limit line to be at 45-degree intervals
&#9;&#9;&#9;&#9;--   will use this internal representation of the line for the actual stamping
&#9;&#9;&#9;&#9;line = (HighScalabilityLine.End - HighScalabilityLine.Start)

&#9;&#9;&#9;&#9;if math.abs(line.X) &lt; math.abs(line.Y) then
&#9;&#9;&#9;&#9;&#9;if math.abs(line.X) &lt; math.abs(line.Z) then
&#9;&#9;&#9;&#9;&#9;&#9;-- limit to Y/Z plane, domination unknown
&#9;&#9;&#9;&#9;&#9;&#9;local newY, newZ
&#9;&#9;&#9;&#9;&#9;&#9;if (math.abs(line.Y) &gt; math.abs(line.Z)) then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newY, newZ = truncateToCircleEighth(line.Y, line.Z)
&#9;&#9;&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newZ, newY = truncateToCircleEighth(line.Z, line.Y)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;line = Vector3.new(0, newY, newZ)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;-- limit to X/Y plane, with Y dominating
&#9;&#9;&#9;&#9;&#9;&#9;local newY, newX = truncateToCircleEighth(line.Y, line.X)
&#9;&#9;&#9;&#9;&#9;&#9;line = Vector3.new(newX, newY, 0)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;if math.abs(line.Y) &lt; math.abs(line.Z) then
&#9;&#9;&#9;&#9;&#9;&#9;-- limit to X/Z plane, domination unknown
&#9;&#9;&#9;&#9;&#9;&#9;local newX, newZ
&#9;&#9;&#9;&#9;&#9;&#9;if math.abs(line.X) &gt; math.abs(line.Z) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newX, newZ = truncateToCircleEighth(line.X, line.Z)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newZ, newX = truncateToCircleEighth(line.Z, line.X)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;line = Vector3.new(newX, 0, newZ)
&#9;&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;&#9;-- limit to X/Y plane, with X dominating
&#9;&#9;&#9;&#9;&#9;&#9;local newX, newY = truncateToCircleEighth(line.X, line.Y)
&#9;&#9;&#9;&#9;&#9;&#9;line = Vector3.new(newX, newY, 0)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;HighScalabilityLine.InternalLine = line

&#9;&#9;&#9;elseif HighScalabilityLine.Dimensions == 2 then
&#9;&#9;&#9;&#9;line = HighScalabilityLine.MoreLines[1]
&#9;&#9;&#9;&#9;line2 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[1]
&#9;&#9;
&#9;&#9;&#9;&#9;-- take out any component of line2 along line1, so you get perpendicular to line1 component
&#9;&#9;&#9;&#9;line2 = line2 - line.unit*line.unit:Dot(line2)

&#9;&#9;&#9;&#9;tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)

&#9;&#9;&#9;&#9;-- then zero out whichever is the smaller component
&#9;&#9;&#9;&#9;local yAxis = tempCFrame:vectorToWorldSpace(Vector3.new(0, 1, 0))
&#9;&#9;&#9;&#9;local xAxis = tempCFrame:vectorToWorldSpace(Vector3.new(1, 0, 0))
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local xComp = xAxis:Dot(line2)
&#9;&#9;&#9;&#9;local yComp = yAxis:Dot(line2)

&#9;&#9;&#9;&#9;if math.abs(yComp) &gt; math.abs(xComp) then
&#9;&#9;&#9;&#9;&#9;line2 = line2 - xAxis*xComp
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;line2 = line2 - yAxis*yComp
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;HighScalabilityLine.InternalLine = line2
&#9;&#9;&#9;elseif HighScalabilityLine.Dimensions == 3 then
&#9;&#9;&#9;&#9;line = HighScalabilityLine.MoreLines[1]
&#9;&#9;&#9;&#9;line2 = HighScalabilityLine.MoreLines[2]
&#9;&#9;&#9;&#9;line3 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[2]

&#9;&#9;&#9;&#9;-- zero out all components of previous lines
&#9;&#9;&#9;&#9;line3 = line3 - line.unit*line.unit:Dot(line3)
&#9;&#9;&#9;&#9;line3 = line3 - line2.unit*line2.unit:Dot(line3)

&#9;&#9;&#9;&#9;HighScalabilityLine.InternalLine = line3
&#9;&#9;&#9;end

&#9;&#9;&#9;-- resize the &quot;line&quot; graphic to be the correct size and orientation
&#9;&#9;&#9;tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)
&#9;&#9;&#9;
&#9;&#9;&#9;if HighScalabilityLine.Dimensions == 1 then  -- faster calculation for line
&#9;&#9;&#9;&#9;HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, line.magnitude + 4)
&#9;&#9;&#9;&#9;HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(Vector3.new(2, 2, 2) - HighScalabilityLine.AdornPart.Size/2)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;local boxSize = tempCFrame:vectorToObjectSpace(line + line2 + line3)
&#9;&#9;&#9;&#9;HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, 4) + Vector3.new(math.abs(boxSize.X), math.abs(boxSize.Y), math.abs(boxSize.Z))
&#9;&#9;&#9;&#9;HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(boxSize/2)
&#9;&#9;&#9;end

&#9;&#9;&#9;-- make player able to see this ish
&#9;&#9;&#9;if player then HighScalabilityLine.Adorn.Parent = player.PlayerGui end
&#9;&#9;&#9;if HighScalabilityLine.NewHint then 
&#9;&#9;&#9;&#9;if HighScalabilityLine.Dimensions == 1 and line and (line.magnitude &gt; 4) then hint(&quot;Press C to stamp in 2D&quot;) HighScalabilityLine.NewHint = false  
&#9;&#9;&#9;&#9;elseif HighScalabilityLine.Dimensions == 2 and line2 and (line2.magnitude &gt; 4) then hint(&quot;Press C again to stamp in 3D&quot;) HighScalabilityLine.NewHint = false 
&#9;&#9;&#9;&#9;elseif HighScalabilityLine.Dimensions == 3 then HighScalabilityLine.NewHint = false end  -- if we do cyclic, then let them know they&apos;re going back to line stamping
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;Data.Stamp.MovingLock = false

end


function onInsertMouseButton1Down()

&#9;if Data.Stamp.Dragger or Data.Stamp.Decal then
&#9;&#9;Data.Stamp.MouseDown = true
&#9;end

&#9;if (Data.Stamp.CurrentParts and Data.Stamp.CurrentParts[1] and Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot;) and not eyeDropperConnection then
&#9;&#9;&#9;-- only let them drag if they start dragging on the cluster!
&#9;&#9;&#9;if Mouse and Mouse.Target and Mouse.Target:IsA(&quot;Terrain&quot;) then
&#9;&#9;&#9;&#9;HighScalabilityLine.Dimensions = 1
&#9;&#9;&#9;&#9;HighScalabilityLine.Start = Data.Stamp.CurrentParts[1].CFrame.p
&#9;&#9;&#9;end
&#9;end
end


function cancelAssetPlacement()
&#9;HighScalabilityLine.Start = nil
&#9;HighScalabilityLine.Adorn.Parent = nil

&#9;gInitial90DegreeRotations = 0
&#9;Data.Stamp.Cancelled = true

&#9;if Data.Stamp[&quot;Model&quot;] then
&#9;&#9;Data.Stamp.Model.Parent = nil
&#9;end

&#9;if Data.Stamp.CurrentParts then
&#9;&#9;for index, object in pairs(Data.Stamp.CurrentParts) do
&#9;&#9;&#9;object.Parent = nil
&#9;&#9;end
&#9;
&#9;&#9;Data.Stamp.CurrentParts.Parent = nil
&#9;end

&#9;if Data.Stamp.DecalSelection then
&#9;&#9;Data.Stamp.DecalSelection:Remove()
&#9;&#9;Data.Stamp.DecalSelection = nil
&#9;end
&#9;if Data.Stamp.Decal then
&#9;&#9;Data.Stamp.Decal:Remove()
&#9;&#9;Data.Stamp.Decal = nil
&#9;end

&#9;if Mouse then
&#9;&#9;Mouse.Icon = &quot;http://www.roblox.com/asset?id=66887745&quot;
&#9;end
&#9;game.JointsService:ClearJoinAfterMoveJoints()

end


function collectParts(object, baseParts, scripts, decals)

&#9;if object:IsA(&quot;BasePart&quot;) then
&#9;&#9;baseParts[#baseParts+1] = object
&#9;elseif object:IsA(&quot;Script&quot;) then
&#9;&#9;scripts[#scripts+1] = object
&#9;elseif object:IsA(&quot;Decal&quot;) then
&#9;&#9;decals[#decals+1] = object
&#9;end

&#9;for index,child in pairs(object:GetChildren()) do
&#9;&#9;collectParts(child, baseParts, scripts, decals)
&#9;end

end

function getTargetPartBoundingBox(targetPart)

&#9;if targetPart.Parent:FindFirstChild(&quot;RobloxModel&quot;) ~= nil then
&#9;&#9;return getBoundingBox2(targetPart.Parent)
&#9;else
&#9;&#9;return getBoundingBox2(targetPart)
&#9;end

end


function getBoundingBox2(partOrModel)

-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
-- relative to the first part&apos;s coordinate frame.

&#9;local minVec = Vector3.new(math.huge, math.huge, math.huge)
&#9;local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

&#9;if partOrModel:IsA(&quot;Part&quot;) or partOrModel:IsA(&quot;WedgePart&quot;) or partOrModel:IsA(&quot;CornerWedgePart&quot;) or partOrModel:IsA(&quot;TrussPart&quot;)then
&#9;&#9;minVec = -0.5 * partOrModel.Size
&#9;&#9;maxVec = -minVec
&#9;elseif partOrModel:IsA(&quot;Terrain&quot;) then
&#9;&#9;minVec = Vector3.new(-2, -2, -2)
&#9;&#9;maxVec = Vector3.new(2, 2, 2)
&#9;else
&#9;&#9;local part1 = partOrModel:GetChildren()[1]
&#9;&#9;if partOrModel:IsA(&quot;Tool&quot;) then part1 = partOrModel.Handle if not part1 then return end end
&#9;&#9;if part1:IsA(&quot;Flag&quot;) then part1 = partOrModel:FindFirstChild(&quot;Part&quot;) if not part1 then return end end
&#9;&#9;for i, object in pairs(partOrModel:GetChildren()) do
&#9;&#9;&#9;if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;TrussPart&quot;)) then
&#9;&#9;&#9;&#9;boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
&#9;&#9;&#9;&#9;boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
&#9;&#9;&#9;&#9;boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)
&#9;&#9;&#9;&#9;boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

&#9;&#9;&#9;&#9;local minX = minVec.x
&#9;&#9;&#9;&#9;local minY = minVec.y
&#9;&#9;&#9;&#9;local minZ = minVec.z
&#9;&#9;&#9;&#9;local maxX = maxVec.x
&#9;&#9;&#9;&#9;local maxY = maxVec.y
&#9;&#9;&#9;&#9;local maxZ = maxVec.z
&#9;&#9;&#9;&#9;if boxMinInPart1.x &lt; minVec.x then
&#9;&#9;&#9;&#9;&#9;minX = boxMinInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.y &lt; minVec.y then
&#9;&#9;&#9;&#9;&#9;minY = boxMinInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.z &lt; minVec.z then
&#9;&#9;&#9;&#9;&#9;minZ = boxMinInPart1.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.x &lt; minX then
&#9;&#9;&#9;&#9;&#9;minX = boxMaxInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.y &lt; minY then
&#9;&#9;&#9;&#9;&#9;minY = boxMaxInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.z &lt; minZ then
&#9;&#9;&#9;&#9;&#9;minZ = boxMaxInPart1.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if boxMinInPart1.x &gt; maxVec.x then
&#9;&#9;&#9;&#9;&#9;maxX = boxMinInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.y &gt; maxVec.y then
&#9;&#9;&#9;&#9;&#9;maxY = boxMinInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.z &gt; maxVec.z then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMinInPart1.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.x &gt; maxX then
&#9;&#9;&#9;&#9;&#9;maxX = boxMaxInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.y &gt; maxY then
&#9;&#9;&#9;&#9;&#9;maxY = boxMaxInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.z &gt; maxZ then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMaxInPart1.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;minVec = Vector3.new(minX, minY, minZ)
&#9;&#9;&#9;&#9;maxVec = Vector3.new(maxX, maxY, maxZ)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;-- Adjust bounding box to reflect what the model or part author wants in  terms of justification
&#9;local justifyValue = partOrModel:FindFirstChild(&quot;Justification&quot;)
&#9;if justifyValue ~= nil then
&#9;&#9;-- find the multiple of 4 that contains the model
&#9;&#9;justify = justifyValue.Value
&#9;&#9;two = Vector3.new(2, 2, 2)
&#9;&#9;actualBox = maxVec - minVec - Vector3.new(0.01, 0.01, 0.01)
&#9;&#9;containingGridBox = Vector3.new(4 * math.ceil(actualBox.x/4), 4 * math.ceil(actualBox.y/4), 4 * math.ceil(actualBox.z/4))
&#9;&#9;adjustment = containingGridBox - actualBox
&#9;&#9;minVec = minVec - 0.5 * adjustment * justify
&#9;&#9;maxVec = maxVec + 0.5 * adjustment * (two - justify)
&#9;end

&#9;return minVec, maxVec

end


function getBoundingBoxInWorldCoordinates(partOrModel)
&#9;local minVec = Vector3.new(math.huge, math.huge, math.huge)
&#9;local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

&#9;if partOrModel:IsA(&quot;BasePart&quot;)then
&#9;&#9;vec1 = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
&#9;&#9;vec2 = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
&#9;&#9;minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
&#9;&#9;maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
&#9;elseif partOrModel:IsA(&quot;Terrain&quot;) then
&#9;&#9;-- we shouldn&apos;t have to deal with this case
&#9;&#9;--minVec = Vector3.new(-2, -2, -2)
&#9;&#9;--maxVec = Vector3.new(2, 2, 2)
&#9;else
&#9;&#9;local part1 = partOrModel:GetChildren()[1]
&#9;&#9;for i, object in pairs(partOrModel:GetChildren()) do
&#9;&#9;&#9;if object:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;&#9;boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
&#9;&#9;&#9;&#9;boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)

&#9;&#9;&#9;&#9;local minX = minVec.x
&#9;&#9;&#9;&#9;local minY = minVec.y
&#9;&#9;&#9;&#9;local minZ = minVec.z
&#9;&#9;&#9;&#9;local maxX = maxVec.x
&#9;&#9;&#9;&#9;local maxY = maxVec.y
&#9;&#9;&#9;&#9;local maxZ = maxVec.z
&#9;&#9;&#9;&#9;if boxMinInWorld.x &lt; minX then
&#9;&#9;&#9;&#9;&#9;minX = boxMinInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.y &lt; minY then
&#9;&#9;&#9;&#9;&#9;minY = boxMinInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.z &lt; minZ then
&#9;&#9;&#9;&#9;&#9;minZ = boxMinInWorld.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.x &lt; minX then
&#9;&#9;&#9;&#9;&#9;minX = boxMaxInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.y &lt; minY then
&#9;&#9;&#9;&#9;&#9;minY = boxMaxInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.z &lt; minZ then
&#9;&#9;&#9;&#9;&#9;minZ = boxMaxInWorld.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if boxMinInWorld.x &gt; maxX then
&#9;&#9;&#9;&#9;&#9;maxX = boxMinInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.y &gt; maxY then
&#9;&#9;&#9;&#9;&#9;maxY = boxMinInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.z &gt; maxZ then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMinInWorld.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.x &gt; maxX then
&#9;&#9;&#9;&#9;&#9;maxX = boxMaxInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.y &gt; maxY then
&#9;&#9;&#9;&#9;&#9;maxY = boxMaxInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.z &gt; maxZ then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMaxInWorld.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;minVec = Vector3.new(minX, minY, minZ)
&#9;&#9;&#9;&#9;maxVec = Vector3.new(maxX, maxY, maxZ)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return minVec, maxVec
end


function getClosestAlignedWorldDirection(aVector3InWorld)

&#9;local xDir = Vector3.new(1,0,0)
&#9;local yDir = Vector3.new(0,1,0)
&#9;local zDir = Vector3.new(0,0,1)
&#9;local xDot = aVector3InWorld.x * xDir.x + aVector3InWorld.y * xDir.y + aVector3InWorld.z * xDir.z
&#9;local yDot = aVector3InWorld.x * yDir.x + aVector3InWorld.y * yDir.y + aVector3InWorld.z * yDir.z
&#9;local zDot = aVector3InWorld.x * zDir.x + aVector3InWorld.y * zDir.y + aVector3InWorld.z * zDir.z

&#9;if math.abs(xDot) &gt; math.abs(yDot) and math.abs(xDot) &gt; math.abs(zDot) then
&#9;&#9;if xDot &gt; 0 then
&#9;&#9;&#9;return 0
&#9;&#9;else
&#9;&#9;&#9;return 3
&#9;&#9;end
&#9;elseif math.abs(yDot) &gt; math.abs(xDot) and math.abs(yDot) &gt; math.abs(zDot) then
&#9;&#9;if yDot &gt; 0 then
&#9;&#9;&#9;return 1
&#9;&#9;else
&#9;&#9;&#9;return 4
&#9;&#9;end
&#9;else
&#9;&#9;if zDot &gt; 0 then
&#9;&#9;&#9;return 2
&#9;&#9;else
&#9;&#9;&#9;return 5
&#9;&#9;end
&#9;end 

end


function getMouseTargetCFrame(targetPart)

&#9;if targetPart.Parent:FindFirstChild(&quot;RobloxModel&quot;) ~= nil then
&#9;&#9;if targetPart.Parent:IsA(&quot;Tool&quot;) then return targetPart.Parent.Handle.CFrame
&#9;&#9;else return targetPart.Parent:GetChildren()[1].CFrame end
&#9;else
&#9;&#9;return targetPart.CFrame
&#9;end

end


function surfaceToVector(surf)
&#9;local vect = 1
&#9;if surf &lt; 0 then
&#9;&#9;surf = surf * -1
&#9;&#9;vect = vect * -1
&#9;end
&#9;if surf == 1 then return vect*Vector3.new(1, 0, 0)
&#9;elseif surf == 2 then return vect*Vector3.new(0, 1, 0)
&#9;elseif surf == 3 then return vect*Vector3.new(0, 0, 1)
&#9;elseif Mouse then return Vector3.FromNormalId(Mouse.TargetSurface) end  -- if we somehow got a &quot;0&quot;, then we just revert to old behavior
&#9;return Vector3.new(0,0,0)
end

function findConfigAtMouseTarget(partsTable)

-- *Critical Assumption* :
--&#9;&#9;&#9;&#9;This function assumes the target CF axes are orthogonal with the target bounding box faces
--&#9;&#9;&#9;&#9;And, it assumes the insert CF axes are orthongonal with the insert bounding box faces
--&#9;&#9;&#9;&#9;Therefore, insertion will not work with angled faces on wedges or other &quot;non-block&quot; parts, nor
--&#9;&#9;&#9;&#9;will it work for parts in a model that are not orthogonally aligned with the model&apos;s CF.

&#9;local grid = 4.0
&#9;local admissibleConfig = false
&#9;local targetConfig = CFrame.new(0,0,0)

&#9;local minBB, maxBB = getBoundingBox2(Data.Stamp.CurrentParts[1])
&#9;local diagBB = maxBB - minBB

&#9;local insertCFrame
&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;i = 1
&#9;&#9;while (i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;Part&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;TrussPart&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;WedgePart&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;CornerWedgePart&quot;)) do
&#9;&#9;&#9;i = i + 1
&#9;&#9;end
&#9;&#9;insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame
&#9;else
&#9;&#9;insertCFrame = Data.Stamp.CurrentParts[1].CFrame
&#9;end

&#9;if not isRestricted and Mouse then
&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then Mouse.TargetFilter = Data.Stamp.CurrentParts[1].Handle
&#9;&#9;else Mouse.TargetFilter = Data.Stamp.CurrentParts[1] end
&#9;end

&#9;local targetPart = nil
&#9;local success = pcall(function() targetPart = Mouse.Target end)

&#9;if not success or targetPart == nil then
&#9;&#9;return admissibleConfig, targetConfig
&#9;end

&#9;-- test mouse hit location
&#9;local minBBTarget, maxBBTarget = getTargetPartBoundingBox(targetPart)
&#9;local diagBBTarget = maxBBTarget - minBBTarget
&#9;local targetCFrame = getMouseTargetCFrame(targetPart)
&#9;local hitCFrame = CFrame.new(0,0,0)
&#9;if Mouse then
&#9;&#9;hitCFrame = Mouse.Hit
&#9;end
&#9;local mouseHitInWorld = hitCFrame.p

&#9;-- find which axis of the insertion objects should match with the target surface
&#9;-- this should use targetPart CFrame, not the model CFrame

&#9;--[[ attempt at fixing Mouse.TargetSurface below...
&#9;local targetModel = targetPart
&#9;if not targetPart:FindFirstChild(&quot;RobloxModel&quot;) and targetPart.Parent and targetPart.Parent:FindFirstChild(&quot;RobloxModel&quot;) then targetModel = targetPart.Parent end
&#9;local correctedTargetSurfaceVector = surfaceToVector(modelTargetSurface(targetModel, game.Workspace.CurrentCamera.CoordinateFrame.p, mouseHitInWorld))
&#9;local targetVectorInWorld = targetPart.CFrame:vectorToWorldSpace(correctedTargetSurfaceVector)
&#9;--]]

&#9;if targetPart:IsA(&quot;Terrain&quot;) then
&#9;&#9;if not cluster then cluster = game.Workspace.Terrain end

&#9;&#9;cellID = cluster:WorldToCellPreferSolid(mouseHitInWorld)
&#9;&#9;targetCFrame = CFrame.new(cluster:CellCenterToWorld(cellID.x, cellID.y, cellID.z))
&#9;end
&#9;
&#9;local mouseHitInTarget = targetCFrame:pointToObjectSpace(mouseHitInWorld)
&#9;local targetVectorInWorld = Vector3.new(0,0,0)
&#9;if Mouse then
&#9;&#9;targetVectorInWorld = targetCFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))
&#9;end


&#9;local targetRefPointInTarget
&#9;local clampToSurface

&#9;if getClosestAlignedWorldDirection(targetVectorInWorld) == 0 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;clampToSurface = Vector3.new(0,1,1)
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 3 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
&#9;&#9;clampToSurface = Vector3.new(0,1,1)
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 1 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;clampToSurface = Vector3.new(1,0,1)&#9;&#9;
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 4 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
&#9;&#9;clampToSurface = Vector3.new(1,0,1)
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 2 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
&#9;&#9;clampToSurface = Vector3.new(1,1,0)
&#9;else
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
&#9;&#9;clampToSurface = Vector3.new(1,1,0)
&#9;end

&#9;targetRefPointInTarget = targetRefPointInTarget * (0.5 * diagBBTarget) + 0.5 * (maxBBTarget + minBBTarget)
&#9;insertRefPointInInsert = insertRefPointInInsert * (0.5 * diagBB) + 0.5 * (maxBB + minBB)
&#9;
&#9;-- To Do: For cases that are not aligned to the world grid, account for the minimal rotation
&#9;-- needed to bring the Insert part(s) into alignment with the Target Part
&#9;-- Apply the rotation here

&#9;local delta = mouseHitInTarget - targetRefPointInTarget
&#9;local deltaClamped = Vector3.new(grid * math.modf(delta.x/grid), grid * math.modf(delta.y/grid), grid * math.modf(delta.z/grid))
&#9;deltaClamped = deltaClamped * clampToSurface
&#9;local targetTouchInTarget = deltaClamped + targetRefPointInTarget

&#9;local TargetTouchRelToWorld = targetCFrame:pointToWorldSpace(targetTouchInTarget)
&#9;local InsertTouchInWorld = insertCFrame:vectorToWorldSpace(insertRefPointInInsert)
&#9;local posInsertOriginInWorld = TargetTouchRelToWorld - InsertTouchInWorld

&#9;local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = insertCFrame:components()
&#9;targetConfig = CFrame.new(posInsertOriginInWorld.x, posInsertOriginInWorld.y, posInsertOriginInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
&#9;admissibleConfig = true

&#9;return admissibleConfig, targetConfig, getClosestAlignedWorldDirection(targetVectorInWorld)

end

function checkPartLimit()

&#9;local numPoints = player.PointsUsed.Value
&#9;local maxPoints = player.MaxPoints.Value

&#9;if numPoints &lt; maxPoints then
&#9;&#9;return true
&#9;else
&#9;&#9;return false
&#9;end

&#9;return true
end

function setupDraggableClone()
&#9;if eyeDropperConnection then eyeDropperConnection:disconnect() eyeDropperConnection = nil end

&#9;--if not Mouse.Target then return end
&#9;click.Value = false

&#9;if Data.Stamp.CurrentParts then
&#9;&#9;for i = 1, #Data.Stamp.CurrentParts do
&#9;&#9;&#9;if Data.Stamp.CurrentParts[i].Parent ~= nil then
&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[i].Parent = partModel
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if Data.Stamp[&quot;Model&quot;] == nil then return end

&#9;local clone = Data.Stamp.Model:Clone()
&#9;local scripts = {}
&#9;local parts = {}
&#9;local decals = {}
&#9;
&#9;collectParts(clone, parts, scripts, decals)

&#9;if #parts &gt; 0 then
&#9;&#9;Data.Stamp.DisabledScripts = {}
&#9;&#9;Data.Stamp.TransparencyTable = {}
&#9;&#9;Data.Stamp.MaterialTable = {}
&#9;&#9;Data.Stamp.CanCollideTable = {}
&#9;&#9;Data.Stamp.AnchoredTable = {}
&#9;&#9;Data.Stamp.DecalTransparencyTable = {}

&#9;&#9;for index,script in pairs(scripts) do
&#9;&#9;&#9;if not(script.Disabled) then
&#9;&#9;&#9;&#9;script.Disabled = true
&#9;&#9;&#9;&#9;Data.Stamp.DisabledScripts[#Data.Stamp.DisabledScripts +1] = script
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for index, part in pairs(parts) do
&#9;&#9;&#9;Data.Stamp.TransparencyTable[part] = part.Transparency
&#9;&#9;&#9;part.Transparency = gStaticTrans + (1-gStaticTrans)*part.Transparency
&#9;&#9;&#9;Data.Stamp.MaterialTable[part] = part.Material
&#9;&#9;&#9;part.Material = Enum.Material.Plastic
&#9;&#9;&#9;Data.Stamp.CanCollideTable[part] = part.CanCollide
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;Data.Stamp.AnchoredTable[part] = part.Anchored
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.archivable = false

&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;local con = nil
&#9;&#9;&#9;&#9;local exitLoop = false
&#9;&#9;&#9;&#9;con = click.Changed:connect(function()
&#9;&#9;&#9;&#9;&#9;if click.Value then
&#9;&#9;&#9;&#9;&#9;&#9;con:disconnect()
&#9;&#9;&#9;&#9;&#9;&#9;exitLoop = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;wait(fadeInDelayTime) -- give it some time to be completely transparent

&#9;&#9;&#9;&#9;if exitLoop then return end -- if we already stamped, we don&apos;t need to do the rest of this
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local begTime = tick()
&#9;&#9;&#9;&#9;local currTime = begTime
&#9;&#9;&#9;&#9;while (currTime - begTime) &lt; transFadeInTime and part and part:IsA(&quot;BasePart&quot;) and part.Transparency &gt; gDesiredTrans and not exitLoop do
&#9;&#9;&#9;&#9;&#9;local newTrans = 1 - (((currTime - begTime)/transFadeInTime) * (gStaticTrans - gDesiredTrans))
&#9;&#9;&#9;&#9;&#9;if Data.Stamp.TransparencyTable[part] then part.Transparency = newTrans + (1-newTrans) * Data.Stamp.TransparencyTable[part] end
&#9;&#9;&#9;&#9;&#9;wait(0.03)
&#9;&#9;&#9;&#9;&#9;currTime = tick()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if part and part:IsA(&quot;BasePart&quot;) and not exitLoop then
&#9;&#9;&#9;&#9;&#9;if Data.Stamp.TransparencyTable[part] then part.Transparency = gDesiredTrans + (1-gDesiredTrans)*Data.Stamp.TransparencyTable[part] end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if con then con:disconnect() end
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;for index, decal in pairs(decals) do
&#9;&#9;&#9;Data.Stamp.DecalTransparencyTable[decal] = decal.Transparency
&#9;&#9;&#9;decal.Transparency = gDesiredTrans + (1-gDesiredTrans)*decal.Transparency
&#9;&#9;end
&#9;&#9;
&#9;&#9;clone.Parent = game.Workspace

&#9;&#9;-- For Restricting Stamper Tool
&#9;&#9;if(isRestricted) then

&#9;&#9;&#9;-- mark a particular spot in BaseplateBumpers, so we can remove any stragglers later, when player leaves
&#9;&#9;&#9;local cloneInsertionSpot = game.Workspace.BaseplateBumpers:FindFirstChild(player.Name)
&#9;&#9;&#9;if cloneInsertionSpot == nil then
&#9;&#9;&#9;&#9;cloneInsertionSpot = Instance.new(&quot;Model&quot;)
&#9;&#9;&#9;&#9;cloneInsertionSpot.Name = player.Name
&#9;&#9;&#9;&#9;cloneInsertionSpot.Parent = game.Workspace.BaseplateBumpers
&#9;&#9;&#9;end

&#9;&#9;&#9;clone.Parent = cloneInsertionSpot
&#9;&#9;end

&#9;&#9;-- disable all seats
&#9;&#9;setSeatEnabledStatus(clone, true)
&#9;&#9;setSeatEnabledStatus(clone, false)

&#9;&#9;Data.Stamp.CurrentParts = clone:GetChildren()

&#9;&#9;-- if auto-alignable, we enforce a pre-rotation to the canonical &quot;0-frame&quot;
&#9;&#9;if autoAlignToFace() then
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1].PrimaryPart then modelInverse = Data.Stamp.CurrentParts[1].PrimaryPart.CFrame:inverse()
&#9;&#9;&#9;else modelInverse = Data.Stamp.CurrentParts[1]:GetModelCFrame():inverse() end
&#9;&#9;&#9;for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
&#9;&#9;&#9;&#9;if object:IsA(&quot;Flag&quot;) then object = object.Handle end
&#9;&#9;&#9;&#9;if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;) then object.CFrame = modelInverse*object.CFrame end
&#9;&#9;&#9;end
&#9;&#9;&#9;gInitial90DegreeRotations = 0
&#9;&#9;else

&#9;&#9;-- pre-rotate if necessary
&#9;&#9;local ry = gInitial90DegreeRotations * math.pi/2
&#9;&#9;local rotCF = CFrame.fromEulerAnglesXYZ(0, ry, 0) 
&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
&#9;&#9;&#9;&#9;if object:IsA(&quot;Flag&quot;) then object = object.Handle end
&#9;&#9;&#9;&#9;if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;) then object.CFrame = rotCF * object.CFrame end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
&#9;&#9;end
&#9;&#9;end

&#9;&#9;-- After rotating, update the position
&#9;&#9;configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
&#9;&#9;if configFound then
&#9;&#9;&#9;positionPartsAtCFrame3(Data.Stamp.TransparencyTable, targetCFrame)
&#9;&#9;end
&#9;&#9;-- to show joints during the mouse move
      game.JointsService:SetJoinAfterMoveInstance(Data.Stamp.CurrentParts[1])

&#9;&#9;local mouseTarget = nil
&#9;&#9;pcall(function() mouseTarget = Mouse.Target end)

      if mouseTarget and mouseTarget.Parent:FindFirstChild(&quot;RobloxModel&quot;) == nil then
&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveTarget(mouseTarget)
      else
&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveTarget(nil)
&#9;&#9;end
      game.JointsService:ShowPermissibleJoints()

&#9;&#9;for index, object in pairs(Data.Stamp.CurrentParts) do
&#9;&#9;&#9;object.Parent = clone.Parent
&#9;&#9;end

&#9;&#9;clone:Remove()

&#9;&#9;lastTargetCFrame = nil

&#9;
&#9;&#9;if billBoardOwnerGui then
&#9;&#9;&#9;if #parts == 1 then
&#9;&#9;&#9;&#9;billBoardOwnerGui.Parent = parts[1]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;billBoardOwnerGui.Parent = parts[1].Parent
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;HighScalabilityLine.NewHint = true -- show hint if they start dragging a high-scalability part

&#9;&#9;Data.Stamp.Dragger = Instance.new(&quot;Dragger&quot;)
&#9;&#9;--Begin a movement by faking a MouseDown signal
&#9;&#9;Data.Stamp.Dragger:MouseDown(parts[1], Vector3.new(0,0,0), parts)
&#9;&#9;Data.Stamp.Dragger:MouseUp()
&#9;else
&#9;&#9;--Nothing draggable in the Model
&#9;&#9;Data.Stamp.Model:Remove()
&#9;&#9;Data.Stamp.Model = nil
&#9;&#9;Data.Stamp.TransparencyTable = nil
&#9;&#9;Data.Stamp.MaterialTable = nil
&#9;&#9;Data.Stamp.CanCollideTable = nil
&#9;&#9;Data.Stamp.AnchoredTable = nil
&#9;&#9;Data.Stamp.DisabledScripts = nil
&#9;end

end


function noManualWelds(part)
&#9;local partChildren = part:GetChildren()
&#9;for i = 1, #partChildren do
&#9;&#9;if partChildren[i]:IsA(&quot;ManualWeld&quot;) or partChildren[i]:IsA(&quot;Rotate&quot;) then
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end
&#9;return true
end

local debris = game:GetService(&quot;Debris&quot;)
function flashRedBox()
&#9;errorBox.Parent = player.PlayerGui
&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then errorBox.Adornee = Data.Stamp.CurrentParts[1].Handle
&#9;else errorBox.Adornee = Data.Stamp.CurrentParts[1] end

&#9;delay(0,function()
&#9;&#9;for i = 1, 3 do
&#9;&#9;&#9;errorBox.Visible = true
&#9;&#9;&#9;wait(0.13)
&#9;&#9;&#9;errorBox.Visible = false
&#9;&#9;&#9;wait(0.13)
&#9;&#9;end
&#9;&#9;errorBox.Adornee = nil
&#9;&#9;errorBox.Parent = Tool
&#9;end)
end


-- below function should work as a Region3 query, returning true if a single cluster part is within this region
function clusterPartsInRegion(startVector, endVector)

&#9;if not cluster then return false end

&#9;local startCell = cluster:WorldToCell(startVector)
&#9;local endCell = cluster:WorldToCell(endVector)

&#9;local startX = startCell.X
&#9;local startY = startCell.Y
&#9;local startZ = startCell.Z

&#9;local endX = endCell.X
&#9;local endY = endCell.Y
&#9;local endZ = endCell.Z

&#9;if startX &lt; cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
&#9;if startY &lt; cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
&#9;if startZ &lt; cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end

&#9;if endX &gt; cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
&#9;if endY &gt; cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
&#9;if endZ &gt; cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end

&#9;for x = startX, endX do
&#9;&#9;for y = startY, endY do
&#9;&#9;&#9;for z = startZ, endZ do
&#9;&#9;&#9;&#9;if (cluster:GetCell(x, y, z).Value) &gt; 0 then return true end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return false
end

-- helper function to determine if a character can be pushed upwards by a certain amount
-- character is 5 studs tall, we&apos;ll check a 1.5 x 1.5 x 4.5 box around char, with center .5 studs below torsocenter
function spaceAboveCharacter(charTorso, newTorsoY)
&#9;local partsAboveChar = game.Workspace:FindPartsInRegion3(Region3.new(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)), charTorso.Parent, 100)
&#9;for j = 1, #partsAboveChar do
&#9;&#9;if partsAboveChar[j].CanCollide and not partsAboveChar[j]:IsDescendantOf(Data.Stamp.CurrentParts[1]) then return false end
&#9;end

&#9;if clusterPartsInRegion(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)) then return false end

&#9;return true
end


-- returns whether or not we want to cancel the stamp because we&apos;re blocked by this part
function isBlocker(part)
&#9;if not part then return false end
&#9;if not part.Parent then return false end
&#9;if part:FindFirstChild(&quot;Humanoid&quot;) then return false end
&#9;if part:FindFirstChild(&quot;RobloxStamper&quot;) or part:FindFirstChild(&quot;RobloxModel&quot;) then return true end
&#9;if part:IsA(&quot;Part&quot;) and not part.CanCollide then return false end
&#9;if part == game.Workspace then return true end
&#9;if part == game.Lighting then return false end
&#9;return isBlocker(part.Parent)
end

function onInsertMouseButton1Up()
&#9;if guiScriptIsLoadingSomething or variables.InsertAsset.Updated.Value then return end -- don&apos;t try to stamp while we&apos;re loading!

&#9;if eyeDropperConnection then 
&#9;&#9;eyeDropperConnection:disconnect()
&#9;&#9;eyeDropperConnection = nil
&#9;&#9;return
&#9;end

&#9;if Data.Stamp.MouseDown then
&#9;&#9;Data.Stamp.MouseDown = false
&#9;&#9;if Data.Stamp.Dragger then

&#9;&#9;&#9;--Place the object where the mouse is currently positioned
&#9;&#9;&#9;-- For Restricting Stamper Tool

&#9;&#9;&#9;while Data.Stamp.MouseLock do wait() end
&#9;&#9;&#9;onInsertMouseMove()
&#9;&#9;&#9;Data.Stamp.MouseLock = true

&#9;&#9;&#9;if(isRestricted) then
&#9;&#9;&#9;&#9;-- if player tries to stamp out of bounds, tell them they can&apos;t
&#9;&#9;&#9;&#9;if not inBounds(Data.Stamp.TransparencyTable) then
&#9;&#9;&#9;&#9;&#9;variables.ShowInvalidPlacement.Value = true
&#9;&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false
&#9;&#9;&#9;&#9;&#9;HighScalabilityLine.Start = nil
&#9;&#9;&#9;&#9;&#9;HighScalabilityLine.Adorn.Parent = nil
&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;-- if unstampable face, then don&apos;t let us stamp there!
&#9;&#9;&#9;if unstampableSurface then
&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false
&#9;&#9;&#9;&#9;HighScalabilityLine.Start = nil
&#9;&#9;&#9;&#9;HighScalabilityLine.Adorn.Parent = nil
&#9;&#9;&#9;&#9;flashRedBox()
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Prevent part from being stamped on top of a player

&#9;&#9;&#9;local minBB, maxBB = getBoundingBoxInWorldCoordinates(Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;local configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)

&#9;&#9;&#9;if configFound and not HighScalabilityLine.Adorn.Parent then
&#9;&#9;&#9;&#9;if clusterPartsInRegion(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector) then Data.Stamp.MouseLock = false flashRedBox() return end

&#9;&#9;&#9;&#9;local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector), Data.Stamp.CurrentParts[1], 100)
&#9;&#9;&#9;&#9;for b = 1, #blockingParts do
&#9;&#9;&#9;&#9;&#9;-- below if we only want to block stamping on self
&#9;&#9;&#9;&#9;&#9;--if blockingParts[b].Parent == script.Parent.Parent then return end
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- below if we want to block stamping on self and also stamping that intersects a model we&apos;ve previously stamped on our baseplate
&#9;&#9;&#9;&#9;&#9;--&#9;&#9;  should work as soon as Region3 queries are fixed
&#9;&#9;&#9;&#9;&#9;--      NOTE TO SELF:  See if partModel applies when isRestricted is false
&#9;&#9;&#9;&#9;&#9;--if blockingParts[b]:IsDescendantOf(partModel) or blockingParts[b].Parent == script.Parent.Parent then Data.Stamp.MouseLock = false flashRedBox() break end --return end
&#9;&#9;&#9;&#9;&#9;if isBlocker(blockingParts[b]) then Data.Stamp.MouseLock = false flashRedBox() return end-- still error if overlapping another model [should return here too!]
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local alreadyPushedUp = {}
&#9;&#9;&#9;&#9;-- if no blocking model below, then see if stamping on top of a character
&#9;&#9;&#9;&#9;for b = 1, #blockingParts do
&#9;&#9;&#9;&#9;&#9;--if blockingParts[b].Parent == script.Parent.Parent then
--&#9;&#9;&#9;&#9;&#9;&#9;local blockingPersonTorso = script.Parent.Parent:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;if blockingParts[b].Parent and not alreadyPushedUp[blockingParts[b].Parent] and blockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;) and blockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;):IsA(&quot;Humanoid&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;local blockingPersonTorso = blockingParts[b].Parent:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;alreadyPushedUp[blockingParts[b].Parent] = true

&#9;&#9;&#9;&#9;&#9;&#9;if blockingPersonTorso then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if so, let&apos;s push the person upwards so they pop on top of the stamped model/part (but only if there&apos;s space above them)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local newY = maxBB.Y + 3
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if spaceAboveCharacter(blockingPersonTorso, newY) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if no space, we just error
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;flashRedBox()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- should return here too!
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;--break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif (not configFound) then
&#9;&#9;&#9;&#9;HighScalabilityLine.Start = nil
&#9;&#9;&#9;&#9;HighScalabilityLine.Adorn.Parent = nil
&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false 
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end -- if no config then don&apos;t stamp!

&#9;&#9;&#9;-- something will be stamped!  so set the &quot;StampedSomething&quot; toggle to true
&#9;&#9;&#9;local localChar = game.Players.LocalPlayer.Character
&#9;&#9;&#9;if localChar then
&#9;&#9;&#9;&#9;local stampTracker = localChar:FindFirstChild(&quot;StampTracker&quot;)
&#9;&#9;&#9;&#9;if stampTracker and not stampTracker.Value then stampTracker.Value = true end
&#9;&#9;&#9;end

&#9;&#9;&#9;-- also, show hints again if high scalability part
&#9;&#9;&#9;HighScalabilityLine.NewHint = true

&#9;&#9;&#9;if Data.Stamp.Model and Data.Stamp.Model:GetChildren()[1] and Data.Stamp.Model:GetChildren()[1].Name == &quot;MegaClusterCube&quot; then
&#9;&#9;&#9;&#9;&#9;local line = HighScalabilityLine.InternalLine
&#9;&#9;&#9;&#9;&#9;local cMax = game.Workspace.Terrain.MaxExtents.Max
&#9;&#9;&#9;&#9;&#9;local cMin = game.Workspace.Terrain.MaxExtents.Min

&#9;&#9;&#9;&#9;&#9;local clusterMaterial = 1 -- default is grass
&#9;&#9;&#9;&#9;&#9;local clusterType = 0 -- default is brick
&#9;&#9;&#9;&#9;&#9;local clusterOrientation = 0 -- default is 0 rotation

&#9;&#9;&#9;&#9;&#9;local autoWedgeClusterParts = false
&#9;&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;AutoWedge&quot;) then autoWedgeClusterParts = true end

&#9;&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;ClusterMaterial&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;clusterMaterial = Data.Stamp.CurrentParts[1].ClusterMaterial
&#9;&#9;&#9;&#9;&#9;&#9;if (clusterMaterial:IsA(&quot;Vector3Value&quot;)) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- extract all info from vector
&#9;&#9;&#9;&#9;&#9;&#9;&#9;clusterType = clusterMaterial.Value.Y
&#9;&#9;&#9;&#9;&#9;&#9;&#9;clusterOrientation = clusterMaterial.Value.Z
&#9;&#9;&#9;&#9;&#9;&#9;&#9;clusterMaterial = clusterMaterial.Value.X
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;clusterMaterial = clusterMaterial.Value
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;
&#9;&#9;&#9;&#9;&#9;if HighScalabilityLine.Adorn.Parent and HighScalabilityLine.Start and ((HighScalabilityLine.Dimensions &gt; 1) or (line and line.magnitude &gt; 0)) then
&#9;&#9;&#9;&#9;&#9;&#9;local startCell = game.Workspace.Terrain:WorldToCell(HighScalabilityLine.Start)

&#9;&#9;&#9;&#9;&#9;&#9;local xInc = {0,0,0}
&#9;&#9;&#9;&#9;&#9;&#9;local yInc = {0,0,0}
&#9;&#9;&#9;&#9;&#9;&#9;local zInc = {0,0,0}
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;local incrementVect = {nil, nil, nil}
&#9;&#9;&#9;&#9;&#9;&#9;local stepVect = {Vector3.new(0, 0, 0), Vector3.new(0, 0, 0), Vector3.new(0, 0, 0)}

&#9;&#9;&#9;&#9;&#9;&#9;local worldAxes = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}

&#9;&#9;&#9;&#9;&#9;&#9;local lines = {}
&#9;&#9;&#9;&#9;&#9;&#9;if HighScalabilityLine.Dimensions &gt; 1 then table.insert(lines, HighScalabilityLine.MoreLines[1]) end
&#9;&#9;&#9;&#9;&#9;&#9;if line and line.magnitude &gt; 0 then table.insert(lines, line) end
&#9;&#9;&#9;&#9;&#9;&#9;if HighScalabilityLine.Dimensions &gt; 2 then table.insert(lines, HighScalabilityLine.MoreLines[2]) end

&#9;&#9;&#9;&#9;&#9;&#9;for i = 1, #lines do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lines[i] = Vector3.new(math.floor(lines[i].X+.5), math.floor(lines[i].Y+.5), math.floor(lines[i].Z+.5)) -- round to integers

&#9;&#9;&#9;&#9;&#9;&#9;&#9;if lines[i].X &gt; 0 then xInc[i] = 1 elseif lines[i].X &lt; 0 then xInc[i] = -1 end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if lines[i].Y &gt; 0 then yInc[i] = 1 elseif lines[i].Y &lt; 0 then yInc[i] = -1 end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if lines[i].Z &gt; 0 then zInc[i] = 1 elseif lines[i].Z &lt; 0 then zInc[i] = -1 end

&#9;&#9;&#9;&#9;&#9;&#9;&#9;incrementVect[i] = Vector3.new(xInc[i], yInc[i], zInc[i])
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if incrementVect[i].magnitude &lt; .9 then incrementVect[i] = nil end
&#9;&#9;&#9;&#9;&#9;&#9;end


&#9;&#9;&#9;&#9;&#9;&#9;if not lines[2] then lines[2] = Vector3.new(0, 0, 0) end
&#9;&#9;&#9;&#9;&#9;&#9;if not lines[3] then lines[3] = Vector3.new(0, 0, 0) end

&#9;&#9;&#9;&#9;&#9;&#9;while (stepVect[3].magnitude*4 &lt;= lines[3].magnitude) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local outerStepVectIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;while outerStepVectIndex &lt; 4 do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;stepVect[2] = Vector3.new(0, 0, 0)
&#9;&#9;&#9;&#9;&#9;&#9;while (stepVect[2].magnitude*4 &lt;= lines[2].magnitude) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local innerStepVectIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;while innerStepVectIndex &lt; 4 do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;stepVect[1] = Vector3.new(0, 0, 0)
&#9;&#9;&#9;&#9;&#9;&#9;while (stepVect[1].magnitude*4 &lt;= lines[1].magnitude) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local stepVectSum = stepVect[1] + stepVect[2] + stepVect[3]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local cellPos = Vector3int16.new(startCell.X + stepVectSum.X, startCell.Y + stepVectSum.Y, startCell.Z + stepVectSum.Z)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if cellPos.X &gt;= cMin.X and cellPos.Y &gt;= cMin.Y and cellPos.Z &gt;= cMin.Z and cellPos.X &lt; cMax.X and cellPos.Y &lt; cMax.Y and cellPos.Z &lt; cMax.Z then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- check if overlaps player or part:
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local cellCenter = game.Workspace.Terrain:CellCenterToWorld(cellPos.X, cellPos.Y, cellPos.Z)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local cellBlockingParts = game.Workspace:FindPartsInRegion3(Region3.new(cellCenter - Vector3.new(2, 2, 2) + insertBoundingBoxOverlapVector, cellCenter + Vector3.new(2, 2, 2) - insertBoundingBoxOverlapVector), Data.Stamp.CurrentParts[1], 100)

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local skipThisCell = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;for b = 1, #cellBlockingParts do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if isBlocker(cellBlockingParts[b]) then skipThisCell = true break end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not skipThisCell then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- pop players up above any set cells
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local alreadyPushedUp = {}
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if no blocking model below, then see if stamping on top of a character
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;for b = 1, #cellBlockingParts do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if cellBlockingParts[b].Parent and not alreadyPushedUp[cellBlockingParts[b].Parent] and cellBlockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;) and cellBlockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;):IsA(&quot;Humanoid&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local blockingPersonTorso = cellBlockingParts[b].Parent:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;alreadyPushedUp[cellBlockingParts[b].Parent] = true

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if blockingPersonTorso then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if so, let&apos;s push the person upwards so they pop on top of the stamped model/part (but only if there&apos;s space above them)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local newY = cellCenter.Y + 5
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if spaceAboveCharacter(blockingPersonTorso, newY) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if no space, we just skip this one
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;skipThisCell = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not skipThisCell then  -- if we STILL aren&apos;t skipping...  then we&apos;re good to go!
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- set it
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterMaterial, clusterType, clusterOrientation)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- auto-wedge it?
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (autoWedgeClusterParts) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;game.Workspace.Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1), Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;&#9;stepVect[1] = stepVect[1] + incrementVect[1]
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if incrementVect[2] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;while innerStepVectIndex &lt; 4 and worldAxes[innerStepVectIndex]:Dot(incrementVect[2]) == 0 do innerStepVectIndex = innerStepVectIndex + 1 end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if innerStepVectIndex &lt; 4 then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;stepVect[2] = stepVect[2] + worldAxes[innerStepVectIndex]*worldAxes[innerStepVectIndex]:Dot(incrementVect[2])
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;innerStepVectIndex = innerStepVectIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else stepVect[2] = Vector3.new(1, 0, 0) innerStepVectIndex = 4 end -- skip all remaining loops
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (stepVect[2].magnitude*4 &gt; lines[2].magnitude) then innerStepVectIndex = 4 end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if incrementVect[3] then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;while outerStepVectIndex &lt; 4 and worldAxes[outerStepVectIndex]:Dot(incrementVect[3]) == 0 do outerStepVectIndex = outerStepVectIndex + 1 end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if outerStepVectIndex &lt; 4 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;stepVect[3] = stepVect[3] + worldAxes[outerStepVectIndex]*worldAxes[outerStepVectIndex]:Dot(incrementVect[3]) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;outerStepVectIndex = outerStepVectIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else stepVect[3] = Vector3.new(1, 0, 0) outerStepVectIndex = 4 end -- skip all remaining loops
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (stepVect[3].magnitude*4 &gt; lines[3].magnitude) then outerStepVectIndex = 4 end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;-- and also get rid of any HighScalabilityLine stuff if it&apos;s there
&#9;&#9;&#9;&#9;&#9;&#9;HighScalabilityLine.Start = nil
&#9;&#9;&#9;&#9;&#9;&#9;HighScalabilityLine.Adorn.Parent = nil
&#9;&#9;&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false
&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;-- not High-Scalability-Line-Based, so behave normally [and get rid of any HSL stuff]
&#9;&#9;&#9;&#9;HighScalabilityLine.Start = nil
&#9;&#9;&#9;&#9;HighScalabilityLine.Adorn.Parent = nil

&#9;&#9;&#9;&#9;-- if target point is in cluster, just use cluster:SetCell
&#9;&#9;&#9;&#9;if cluster then
&#9;&#9;&#9;&#9;&#9;-- if targetCFrame is inside cluster, just set that cell to 1 and return
&#9;&#9;&#9;&#9;&#9;local cellPos = cluster:WorldToCell(targetCFrame.p)

&#9;&#9;&#9;&#9;&#9;if cellPos.X &gt;= cMin.X and cellPos.Y &gt;= cMin.Y and cellPos.Z &gt;= cMin.Z and cellPos.X &lt; cMax.X and cellPos.Y &lt; cMax.Y and cellPos.Z &lt; cMax.Z then
&#9;&#9;&#9;&#9;&#9;&#9;cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterMaterial, clusterType, clusterOrientation)

&#9;&#9;&#9;&#9;&#9;&#9;-- auto-wedge it
&#9;&#9;&#9;&#9;&#9;&#9;if (autoWedgeClusterParts) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;game.Workspace.Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1), Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)))
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false
&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Post process: after positioning the part or model, restore transparency, material, anchored and collide states and create joints
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;&#9;&#9;-- Tyler&apos;s magical hack-code for allowing/preserving clones of both Surface and Manual Welds...  just don&apos;t ask X&lt;
&#9;&#9;&#9;&#9;&#9;manualWeldTable = {}
&#9;&#9;&#9;&#9;&#9;manualWeldParentTable = {}
&#9;&#9;&#9;&#9;&#9;saveTheWelds(Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1]:BreakJoints()
&#9;&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1]:MakeJoints()
&#9;&#9;&#9;&#9;&#9;restoreTheWelds()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- if it&apos;s a model, we also want to fill in the playerID and playerName tags, if it has those (e.g. for the friend-only door)
&#9;&#9;&#9;&#9;playerIdTag = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;PlayerIdTag&quot;)
&#9;&#9;&#9;&#9;playerNameTag = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;PlayerNameTag&quot;)
&#9;&#9;&#9;&#9;if playerIdTag ~= nil then
&#9;&#9;&#9;&#9;&#9;tempPlayerValue = getPlayer()
&#9;&#9;&#9;&#9;&#9;if tempPlayerValue ~= nil then playerIdTag.Value = tempPlayerValue.userId end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if playerNameTag ~= nil then
&#9;&#9;&#9;&#9;&#9;tempPlayerValue = getPlayer()
&#9;&#9;&#9;&#9;&#9;if tempPlayerValue ~= nil then playerNameTag.Value = tempPlayerValue.Name end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;-- ...and tag all inserted models for subsequent origin identification
&#9;&#9;&#9;&#9;-- if no RobloxModel tag already exists, then add it.
&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxModel&quot;) == nil then
&#9;&#9;&#9;&#9;&#9;local stringTag = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;&#9;&#9;stringTag.Name = &quot;RobloxModel&quot;

&#9;&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxStamper&quot;) == nil then
&#9;&#9;&#9;&#9;&#9;&#9;local stringTag2 = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;&#9;&#9;&#9;stringTag2.Name = &quot;RobloxStamper&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1]:BreakJoints()
&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxStamper&quot;) == nil then
&#9;&#9;&#9;&#9;&#9;local stringTag2 = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;&#9;&#9;stringTag2.Name = &quot;RobloxStamper&quot;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- make sure all the joints are activated before restoring anchor states
&#9;&#9;&#9;if not createJoints then game.JointsService:CreateJoinAfterMoveJoints() end

&#9;&#9;&#9;click.Value = true
&#9;&#9;&#9;--Fix the transparency and material of all the parts
&#9;&#9;&#9;for part, transparency in pairs(Data.Stamp.TransparencyTable) do
&#9;&#9;&#9;&#9;part.Transparency = transparency
&#9;&#9;&#9;&#9;part.archivable = true
&#9;&#9;&#9;end
&#9;&#9;&#9;for part, material in pairs(Data.Stamp.MaterialTable) do
&#9;&#9;&#9;&#9;part.Material = material
&#9;&#9;&#9;end
&#9;&#9;&#9;for part, collide in pairs(Data.Stamp.CanCollideTable) do
&#9;&#9;&#9;&#9;part.CanCollide = collide
&#9;&#9;&#9;end
&#9;&#9;&#9;for part, anchored in pairs(Data.Stamp.AnchoredTable) do
&#9;&#9;&#9;&#9;part.Anchored = anchored
&#9;&#9;&#9;end
&#9;&#9;&#9;for decal, transparency in pairs(Data.Stamp.DecalTransparencyTable) do
&#9;&#9;&#9;&#9;decal.Transparency = transparency
&#9;&#9;&#9;end

&#9;&#9;&#9;if (Data.Stamp.CurrentParts[1] and Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot;) then
&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1].Transparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;-- re-enable all seats
&#9;&#9;&#9;setSeatEnabledStatus(Data.Stamp.CurrentParts[1], true)

&#9;&#9;&#9;Data.Stamp.TransparencyTable = nil
&#9;&#9;&#9;Data.Stamp.MaterialTable = nil
&#9;&#9;&#9;Data.Stamp.CanCollideTable = nil
&#9;&#9;&#9;Data.Stamp.AnchoredTable = nil

&#9;&#9;&#9;-- ...and tag all inserted models for subsequent origin identification
&#9;&#9;&#9;-- if no RobloxModel tag already exists, then add it.
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxModel&quot;) == nil then
&#9;&#9;&#9;&#9;local stringTag = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;&#9;stringTag.Name = &quot;RobloxModel&quot;
&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;-- set our object back to the player&apos;s plate
&#9;&#9;&#9;Data.Stamp.CurrentParts[1].Parent = partModel

&#9;&#9;&#9;--Re-enable the scripts
&#9;&#9;&#9;for index,script in pairs(Data.Stamp.DisabledScripts) do
&#9;&#9;&#9;&#9;script.Disabled = false
&#9;&#9;&#9;end
&#9;&#9;&#9;--Now that they are all marked enabled, reinsert them into the world so they start running
&#9;&#9;&#9;for index,script in pairs(Data.Stamp.DisabledScripts) do
&#9;&#9;&#9;&#9;local oldParent = script.Parent
&#9;&#9;&#9;&#9;script.Parent = nil
&#9;&#9;&#9;&#9;script:Clone().Parent = oldParent
&#9;&#9;&#9;end
&#9;&#9;&#9;Data.Stamp.DisabledScripts = nil
&#9;&#9;&#9;Data.Stamp.Dragger = nil
&#9;&#9;&#9;Data.Stamp.CurrentParts.Parent = nil
&#9;&#9;&#9;Data.Stamp.CurrentParts = nil

&#9;&#9;&#9;Data.Stamp.MouseLock = false

&#9;&#9;&#9;--Now set up a new instance of the object to allow a second copy to be stamped down
&#9;&#9;&#9;variables.Stamped.Value = true
&#9;&#9;&#9;variables.Stamped.Value = false
&#9;&#9;&#9;if isRestricted then
&#9;&#9;&#9;&#9;if checkPartLimit() then
&#9;&#9;&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;variables.ShowMaxedOut.Value = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;end

&#9;&#9;end
&#9;end
end


------------------------ EyeDropper Code -------------------------------------------

function onEyeDropperMouseButton1Down()
&#9;if eyeDropperMoveConnection then 
&#9;&#9;eyeDropperMoveConnection:disconnect()
&#9;end
&#9;clearSelection()
&#9;if Mouse then
&#9;&#9;Mouse.Icon = &quot;http://www.roblox.com/asset?id=66887745&quot;
&#9;end

&#9;-- deny any attempt to clone something that wasn&apos;t stamped using the Stamper tool
&#9;if not Mouse or not Mouse.Target then
&#9;&#9;startEyeDropperOperation()
&#9;&#9;return
&#9;end

&#9;local isTerrainEyedroppering = false
&#9;if Mouse.Target == game.Workspace.Terrain then
&#9;&#9;-- want to eyedropper a terrain piece; gotta do a little extra footwork
&#9;&#9;print(&quot;Eyedroppering Terrain Piece&quot;)
&#9;&#9;local newTerrainPiece

&#9;&#9;-- gotta make the fake part here
&#9;&#9;local hitCell = game.Workspace.Terrain:WorldToCellPreferSolid(Mouse.Hit.p)
&#9;&#9;local cellMat, cellType, cellOrient = game.Workspace.Terrain:GetCell(hitCell.x, hitCell.y, hitCell.z)

&#9;&#9;if (cellType.Value == 1 or cellType.Value == 4) then newTerrainPiece = Instance.new(&quot;WedgePart&quot;) newTerrainPiece.formFactor = &quot;Custom&quot;
&#9;&#9;elseif (cellType.Value == 2) then newTerrainPiece = Instance.new(&quot;CornerWedgePart&quot;)
&#9;&#9;else newTerrainPiece = Instance.new(&quot;Part&quot;) newTerrainPiece.formFactor = &quot;Custom&quot; end
&#9;&#9;newTerrainPiece.Name = &quot;MegaClusterCube&quot;
&#9;&#9;newTerrainPiece.Size = Vector3.new(4, 4, 4)
&#9;&#9;newTerrainPiece.BottomSurface = &quot;Smooth&quot;
&#9;&#9;newTerrainPiece.TopSurface = &quot;Smooth&quot;

&#9;&#9;-- can add decals or textures here if feeling particularly adventurous...  for now, can make a table of look-up colors
&#9;&#9;newTerrainPiece.BrickColor = getClosestColorToTerrainMaterial(cellMat.Value)

&#9;&#9;local sideways = 0
&#9;&#9;local flipped = math.pi
&#9;&#9;if cellType.Value == 4 then sideways = -math.pi/2 end
&#9;&#9;if cellType.Value == 2 or cellType.Value == 3 then flipped = 0 end
&#9;&#9;newTerrainPiece.CFrame = CFrame.Angles(0, math.pi/2*cellOrient.Value + flipped, sideways)

&#9;&#9;if cellType.Value == 3 then
&#9;&#9;&#9;local inverseCornerWedgeMesh = Instance.new(&quot;SpecialMesh&quot;)
&#9;&#9;&#9;inverseCornerWedgeMesh.MeshType = &quot;FileMesh&quot;
&#9;&#9;&#9;inverseCornerWedgeMesh.MeshId = &quot;http://www.roblox.com/asset?id=66832495&quot;
&#9;&#9;&#9;inverseCornerWedgeMesh.Scale = Vector3.new(2, 2, 2)
&#9;&#9;&#9;inverseCornerWedgeMesh.Parent = newTerrainPiece
&#9;&#9;end

&#9;&#9;local materialTag = Instance.new(&quot;Vector3Value&quot;)
&#9;&#9;materialTag.Value = Vector3.new(cellMat.Value, cellType.Value, cellOrient.Value)
&#9;&#9;materialTag.Name = &quot;ClusterMaterial&quot;
&#9;&#9;materialTag.Parent = newTerrainPiece

&#9;&#9;local tempModel = Instance.new(&quot;Model&quot;)
&#9;&#9;newTerrainPiece.Parent = tempModel

&#9;&#9;Data.Stamp.Model = tempModel
&#9;&#9;Data.Stamp.Model:BreakJoints()

&#9;&#9;isTerrainEyedroppering = true
&#9;end

&#9;local stamperTag = Mouse.Target.Parent:FindFirstChild(&quot;RobloxStamper&quot;)
&#9;if stamperTag == nil then stamperTag = Mouse.Target:FindFirstChild(&quot;RobloxStamper&quot;) end
&#9;if stamperTag == nil and not isTerrainEyedroppering then
&#9;&#9;startEyeDropperOperation()
&#9;&#9;return
&#9;end

&#9;local eyeDropperInstance
&#9;-- find out if the target part is part of a Roblox Set Model
&#9;local robloxModelTag = Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;)
&#9;if robloxModelTag ~= nil then
&#9;&#9;eyeDropperInstance = Mouse.Target.Parent
&#9;else
&#9;&#9;eyeDropperInstance = Mouse.Target
&#9;end
&#9;
&#9;-- do not allow certain objects to be captured with eye-dropper
&#9;-- for now, locked parts
&#9;if eyeDropperInstance:IsA(&quot;Part&quot;) and eyeDropperInstance.Locked and not isTerrainEyedroppering then
&#9;&#9;startEyeDropperOperation()
&#9;else
&#9;&#9;if not isTerrainEyedroppering then
&#9;&#9;&#9;local cloneInstance = eyeDropperInstance:clone()
&#9;&#9;&#9;local tempModel = Instance.new(&quot;Model&quot;)
&#9;&#9;&#9;cloneInstance.Parent = tempModel

&#9;&#9;&#9;-- once more, we make sure it&apos;s on grid before eyedroppering
&#9;&#9;&#9;if not isOnGrid(tempModel) then startEyeDropperOperation() return end

&#9;&#9;&#9;Data.Stamp.Model = tempModel
&#9;&#9;&#9;Data.Stamp.Model:BreakJoints()
&#9;&#9;end

&#9;&#9;-- will create and position clone without requiring user to move the mouse&#9;&#9;

&#9;&#9;if isRestricted then
&#9;&#9;&#9;if checkPartLimit() then
&#9;&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;&#9;if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;variables.ShowMaxedOut.Value = true
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end
&#9;&#9;end

&#9;&#9;variables.SwitchLoaderToDialog.AssetImage.Value = &quot;0&quot;
&#9;&#9;variables.SwitchLoaderToDialog.DialogType.Value = &quot;SideDialog&quot;
&#9;&#9;variables.SwitchLoaderToDialog.Value = true
&#9;end
end

function onEyeDropperMouseMove() 
&#9;if not(inGui) and not(inPalette) then
&#9;&#9;if not Mouse or not Mouse.Target then clearSelection() return end
&#9;&#9;local part = Mouse.Target
&#9;&#9;if part:IsA(&quot;Terrain&quot;) and Mouse.Hit then
&#9;&#9;&#9;selectionBox.Color = BrickColor.Green()
&#9;&#9;&#9;setTerrainSelection(Mouse.Hit.p)
&#9;&#9;elseif canEyeDropperObject(part) then
&#9;&#9;&#9;local model = findModel(part)
&#9;&#9;&#9;if model and isOnGrid(model) then &#9;&#9;
&#9;&#9;&#9;&#9;selectionBox.Color = BrickColor.Green()
&#9;&#9;&#9;&#9;setSelection(model)
&#9;&#9;&#9;elseif (not model) and isOnGrid(part) then
&#9;&#9;&#9;&#9;selectionBox.Color = BrickColor.Green()
&#9;&#9;&#9;&#9;setSelection(part)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;clearSelection()
&#9;&#9;end
&#9;end
end

function startEyeDropperOperation()

&#9;cancelAssetPlacement()
&#9;pressedEsc = false
&#9;signalInsertComplete(&quot;EyeDropper&quot;)

&#9;if mouseButton1UpCon then mouseButton1UpCon:disconnect() mouseButton1UpCon = nil end

&#9;if eyeDropperConnection then
&#9;&#9;eyeDropperConnection:disconnect()
&#9;&#9;eyeDropperConnection = nil
&#9;end
&#9;if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end
&#9;if Mouse then
&#9;&#9;--Mouse.Icon =&quot;rbxasset://textures//DropperCursor.png&quot;
&#9;&#9;Mouse.Icon = &quot;http://www.roblox.com/asset?id=67163166&quot;
&#9;&#9;eyeDropperConnection = Mouse.Button1Up:connect(onEyeDropperMouseButton1Down)
&#9;&#9;eyeDropperMoveConnection = Mouse.Move:connect(onEyeDropperMouseMove)
&#9;end

end

function findModel(part)

&#9;if isRestricted then
&#9;&#9;while part ~= nil do
&#9;&#9;&#9;if part.className == &quot;Model&quot; and part.Name ~= playerModel.Name and part.Name ~= &quot;GarbageParts&quot; then
&#9;&#9;&#9;&#9;return part
&#9;&#9;&#9;elseif part.Name == playerModel.Name or part.Name == &quot;GarbageParts&quot; then
&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;end
&#9;&#9;&#9;part = part.Parent
&#9;&#9;end
&#9;&#9;return nil

&#9;else
&#9;&#9;while part ~= game.Workspace do
&#9;&#9;&#9;if part:FindFirstChild(&quot;RobloxModel&quot;) then
&#9;&#9;&#9;&#9;return part
&#9;&#9;&#9;end
&#9;&#9;&#9;part = part.Parent
&#9;&#9;end
&#9;&#9;return nil
&#9;end

end

------------------------ End EyeDropper Code ---------------------------------------




------------------------ Start Selection Highlighting Code --------------------------
function setTerrainSelection(point)
&#9;if selectionBox then
&#9;&#9;local cell = game.Workspace.Terrain:WorldToCellPreferSolid(point)
&#9;&#9;local cellCenter = game.Workspace.Terrain:CellCenterToWorld(cell.X, cell.Y, cell.Z)
&#9;&#9;terrainSelectionBox.CFrame = CFrame.new(cellCenter)
&#9;&#9;selectionBox.Adornee = terrainSelectionBox
&#9;end
end
&#9;
function setSelection(partOrModel)
&#9;if partOrModel ~= currentSelection then
&#9;&#9;clearSelection()
&#9;&#9;currentSelection = partOrModel
&#9;&#9;selectionBox.Adornee = currentSelection
&#9;end
end

function clearSelection()
&#9;if currentSelection ~= nil then
&#9;&#9;for part, color in pairs(currentSelectionColors) do
&#9;&#9;&#9;part.BrickColor = color
&#9;&#9;end
&#9;&#9;selectionBox.Adornee = nil
&#9;end
&#9;currentSelectionColors = {}
&#9;-- I put these inside if statements, because we can&apos;t assume these exist. (Jahr, 12-29-2010)
&#9;if currentSelection then currentSelection = nil end
&#9;if selectionBox then selectionBox.Adornee = nil end
end

------------------------ End Selection Highlighting Code --------------------------

function autoAlignToFace()
&#9;local aatf = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;AutoAlignToFace&quot;)
&#9;if aatf then return aatf.Value else return false end
end


function autoAlignHelper()
&#9;local model = Data.Stamp.CurrentParts[1]
&#9;local aatfTag = model:FindFirstChild(&quot;AutoAlignToFace&quot;)
&#9;if not aatfTag then
&#9;&#9;aatfTag = Instance.new(&quot;IntValue&quot;)
&#9;&#9;aatfTag.Name = &quot;AutoAlignToFace&quot;
&#9;&#9;aatfTag.Parent = Data.Stamp.CurrentParts[1]
&#9;&#9;aatfTag.Value = 3
&#9;end
&#9;aatfTag.Value = aatfTag.Value + 1
&#9;if aatfTag.Value &gt; 3 then aatfTag.Value = 0 end
end

function unstampableFaceHelper()
&#9;if not Mouse or not Mouse.Target then return end
&#9;local model = Mouse.Target
&#9;if not model then return end
&#9;if not model:FindFirstChild(&quot;RobloxModel&quot;) then model = model.Parent end
&#9;if not model then return end
&#9;if not model:FindFirstChild(&quot;RobloxModel&quot;) then return end

&#9;local ufhTag = model:FindFirstChild(&quot;UnstampableFaces&quot;)
&#9;if not ufhTag then
&#9;&#9;ufhTag = Instance.new(&quot;StringValue&quot;)
&#9;&#9;ufhTag.Name = &quot;UnstampableFaces&quot;
&#9;&#9;ufhTag.Parent = model
&#9;&#9;ufhTag.Value = &quot;&quot;
&#9;end
&#9;
&#9;local hitFace = modelTargetSurface(model, game.Workspace.CurrentCamera.CoordinateFrame.p, Mouse.Hit.p)

&#9;-- put string list into table form
&#9;breakingFaceList = {}
&#9;for bf = -3, 3 do
&#9;&#9;breakingFaceList[bf] = false
&#9;end
&#9;for bf in string.gmatch(ufhTag.Value, &quot;[^,]+&quot;) do
&#9;&#9;breakingFaceList[tonumber(bf)] = true
&#9;end

&#9;-- toggle value of hit face
&#9;breakingFaceList[hitFace] = not breakingFaceList[hitFace]

&#9;-- put table form back into string value
&#9;ufhTag.Value = &quot;&quot;
&#9;local seenAValueSoFar = false
&#9;for bf = -3, 3 do
&#9;&#9;if bf ~= 0 then -- ignore 0 face, since that doesn&apos;t exist
&#9;&#9;&#9;if breakingFaceList[bf] then 
&#9;&#9;&#9;&#9;if seenAValueSoFar then ufhTag.Value = ufhTag.Value .. &quot;,&quot; .. tostring(bf)
&#9;&#9;&#9;&#9;else ufhTag.Value = tostring(bf) seenAValueSoFar = true end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function justificationHelper(whichAxis)
&#9;local model = Data.Stamp.CurrentParts[1]
&#9;local justTag = model:FindFirstChild(&quot;Justification&quot;)
&#9;if not justTag then
&#9;&#9;justTag = Instance.new(&quot;Vector3Value&quot;)
&#9;&#9;justTag.Name = &quot;Justification&quot;
&#9;&#9;justTag.Parent = Data.Stamp.CurrentParts[1]
&#9;&#9;justTag.Value = Vector3.new(1, 1, 1)
&#9;end
&#9;local oldValue = justTag.Value
&#9;if whichAxis == 1 then
&#9;&#9;if oldValue.X == 2 then justTag.Value = Vector3.new(0, oldValue.Y, oldValue.Z)
&#9;&#9;else justTag.Value = Vector3.new(oldValue.X+1, oldValue.Y, oldValue.Z) end
&#9;elseif whichAxis == 2 then
&#9;&#9;if oldValue.Y == 2 then justTag.Value = Vector3.new(oldValue.X, 0, oldValue.Z)
&#9;&#9;else justTag.Value = Vector3.new(oldValue.X, oldValue.Y+1, oldValue.Z) end
&#9;elseif whichAxis == 3 then
&#9;&#9;if oldValue.Z == 2 then justTag.Value = Vector3.new(oldValue.X, oldValue.Y, 0)
&#9;&#9;else justTag.Value = Vector3.new(oldValue.X, oldValue.Y, oldValue.Z+1) end
&#9;end
end

function onInsertKeyDown(key)
&#9;key = string.lower(key)
&#9;if Data.Stamp.Dragger then
&#9;&#9;if key == &apos;c&apos; and Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot; and HighScalabilityLine.InternalLine and HighScalabilityLine.InternalLine.magnitude &gt; 0 and HighScalabilityLine.Dimensions &lt; 3 then
&#9;&#9;&#9;HighScalabilityLine.MorePoints[HighScalabilityLine.Dimensions] = HighScalabilityLine.End
&#9;&#9;&#9;HighScalabilityLine.MoreLines[HighScalabilityLine.Dimensions] = HighScalabilityLine.InternalLine
&#9;&#9;&#9;HighScalabilityLine.Dimensions = HighScalabilityLine.Dimensions + 1
&#9;&#9;&#9;HighScalabilityLine.NewHint = true
&#9;&#9;end

&#9;&#9;if key == &apos;r&apos; and not autoAlignToFace() then
&#9;&#9;&#9;-- Update orientation value if this is a fake terrain part
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot; then
&#9;&#9;&#9;&#9;local clusterValues = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;ClusterMaterial&quot;)
&#9;&#9;&#9;&#9;if clusterValues and clusterValues:IsA(&quot;Vector3Value&quot;) then
&#9;&#9;&#9;&#9;&#9;clusterValues.Value = Vector3.new(clusterValues.Value.X, clusterValues.Value.Y, (clusterValues.Value.Z+1)%4)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Rotate the parts or all the parts in the model
&#9;&#9;&#9;local ry = math.pi/2
&#9;&#9;&#9;local rotCF = CFrame.fromEulerAnglesXYZ(0, ry, 0)
&#9;&#9;&#9;gInitial90DegreeRotations = gInitial90DegreeRotations + 1
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if object:IsA(&quot;Flag&quot;) then object = object.Handle end
&#9;&#9;&#9;&#9;&#9;if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;object.CFrame = rotCF * object.CFrame
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
&#9;&#9;&#9;end
&#9;&#9;&#9;-- After rotating, update the position
&#9;&#9;&#9;configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
&#9;&#9;&#9;if configFound then
&#9;&#9;&#9;&#9;positionPartsAtCFrame3(Data.Stamp.CurrentParts[1], targetCFrame)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- update everything else in MouseMove
&#9;&#9;&#9;&#9;onInsertMouseMove()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if key == &apos;e&apos;  then
&#9;&#9;startEyeDropperOperation()
&#9;elseif key == &apos;q&apos; then
&#9;&#9;pressedEsc = true
&#9;&#9;if eyeDropperConnection then
&#9;&#9;&#9;eyeDropperConnection:disconnect()
&#9;&#9;&#9;eyeDropperConnection = nil
&#9;&#9;end
&#9;&#9;if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end

&#9;&#9;if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end

&#9;&#9;clearSelection()
&#9;&#9;cancelAssetPlacement()
&#9;&#9;Data.Loading.Cancelled = true
&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;end
&#9;
&#9;-- admin-only tools: helpful functions for construction purposes
&#9;if adminAccess then
&#9;&#9;if key == &apos;L&apos; or key == &apos;l&apos; then
&#9;&#9;&#9;-- autoalign helper
&#9;&#9;&#9;if Data.Stamp.Dragger then autoAlignHelper() onInsertMouseMove() end
&#9;&#9;elseif key == &apos;U&apos; or key == &apos;u&apos; then
&#9;&#9;&#9;-- unstampable face helper
&#9;&#9;&#9;unstampableFaceHelper()
&#9;&#9;--elseif key == &apos;C&apos; or key == &apos;c&apos; then
--&#9;&#9;&#9;if Data.Stamp.Dragger then justificationHelper() end -- the &apos;c&apos; stands for &quot;Centering&quot; since &quot;j&quot; is already reserved by GuiScript
&#9;&#9;--end
&#9;&#9;elseif key == &apos;X&apos; or key == &apos;x&apos; then  -- change x justification
&#9;&#9;&#9;if Data.Stamp.Dragger then justificationHelper(1) onInsertMouseMove() end
&#9;&#9;elseif key == &apos;Y&apos; or key == &apos;y&apos; then  -- change y justification
&#9;&#9;&#9;if Data.Stamp.Dragger then justificationHelper(2) onInsertMouseMove() end
&#9;&#9;elseif key == &apos;Z&apos; or key == &apos;z&apos; then  -- change z justification
&#9;&#9;&#9;if Data.Stamp.Dragger then justificationHelper(3) onInsertMouseMove() end
&#9;&#9;end
&#9;end
end


function onEquippedLocal(newMouse)
&#9;Mouse = newMouse

&#9;player = getPlayer()

&#9;-- if equip goes through while in backpack (so getPlayer() returns nil), we don&apos;t want to process anything else
&#9;if not player then return end

&#9;--[[if game:FindFirstChild(&quot;NetworkClient&quot;) and game.CoreGui.Version &gt;= 7 then  only show billboards in online mode
&#9;&#9;if not billBoardOwnerGui then billBoardOwnerGui = generateOwnerGui(player.Name) end
&#9;end]]

&#9;if isRestricted then
&#9;&#9;if game.Workspace:FindFirstChild(&quot;BuildingAreas&quot;) then
&#9;&#9;&#9;local areas = game.Workspace.BuildingAreas:GetChildren()
&#9;&#9;&#9;for i = 1, #areas do
&#9;&#9;&#9;&#9;if areas[i]:FindFirstChild(&quot;Player&quot;) and areas[i].Player.Value == Tool.Parent.Name then
&#9;&#9;&#9;&#9;&#9;playerModel = areas[i]:FindFirstChild(&quot;PlayerArea&quot;)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;playerModel = game.Workspace

&#9;&#9;-- give them a topHint gui too, if they don&apos;t have it since the place won&apos;t already have it&#9;
&#9;&#9;if not player.PlayerGui:FindFirstChild(&quot;topHint&quot;) then
&#9;&#9;&#9;local topHintGui = script.Parent:FindFirstChild(&quot;topHint&quot;)
&#9;&#9;&#9;if topHintGui then
&#9;&#9;&#9;&#9;topHintGui:Clone().Parent = player.PlayerGui
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;if not playerModel then return end

&#9;-- used to move object when walking
&#9;cameraChangeCon = game.Players.LocalPlayer.Character.Humanoid.Running:connect(function(speed)
&#9;&#9;if speed &gt; 0 then
&#9;&#9;&#9;walking = true
&#9;&#9;&#9;while walking and cameraChangeCon do
&#9;&#9;&#9;&#9;onInsertMouseMove()
&#9;&#9;&#9;&#9;wait(1.0/30.0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;walking = false
&#9;&#9;end
&#9;end)
&#9;if Mouse then
&#9;&#9;mouseMoveCon = newMouse.Move:connect(onInsertMouseMove)
&#9;&#9;mouseButton1DownCon = newMouse.Button1Down:connect(onInsertMouseButton1Down)
&#9;&#9;mouseButton1UpCon = newMouse.Button1Up:connect(onInsertMouseButton1Up)
&#9;&#9;newMouse.KeyDown:connect(onInsertKeyDown)
&#9;end

&#9;if(isRestricted) then
&#9;&#9;local takenAreas = game.Workspace.BuildingAreas:GetChildren()

&#9;&#9;waitForChild(player, &quot;playerNumber&quot;)

&#9;&#9;if(player.playerNumber.Value == 0) then
&#9;&#9;&#9;buildingPlate = nil
&#9;&#9;&#9;partModel = nil
&#9;&#9;else
&#9;&#9;&#9;waitForChild(game.Workspace, &quot;BuildingAreas&quot;)
&#9;&#9;&#9;local buildingAreas = game.Workspace.BuildingAreas
&#9;&#9;&#9;waitForChild(buildingAreas, &quot;Area&quot;..tostring(player.playerNumber.Value))
&#9;&#9;&#9;local targetArea = buildingAreas:FindFirstChild(&quot;Area&quot;..tostring(player.playerNumber.Value))
&#9;&#9;&#9;
&#9;&#9;&#9;waitForChild(targetArea, &quot;PlayerArea&quot;)
&#9;&#9;&#9;waitForChild(targetArea.PlayerArea, &quot;BasePlate&quot;)

&#9;&#9;&#9;buildingPlate = targetArea.PlayerArea.BasePlate
&#9;&#9;&#9;partModel = targetArea.PlayerArea
&#9;&#9;end
&#9;else
&#9;&#9;partModel = game.Workspace
&#9;end

&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Name = &quot;Model Delete Selection&quot;
&#9;selectionBox.Color = BrickColor.Red()
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = player.PlayerGui

&#9;alreadyMoving = false
end


function onUnequipped()
&#9;Mouse = nil
&#9;if mouseMoveCon then mouseMoveCon:disconnect() end
&#9;if mouseButton1DownCon then mouseButton1DownCon:disconnect() end
&#9;if mouseButton1UpCon then mouseButton1UpCon:disconnect() end
&#9;if cameraChangeCon then cameraChangeCon:disconnect() cameraChangeCon = nil end
&#9;if billBoardOwnerGui then billBoardOwnerGui:Remove() end

&#9;cancelAssetPlacement()

&#9;clearSelection()
&#9;if selectionBox then selectionBox:Remove() end
end
----------------------------------------------------------------------------------------




-- Lua Start Script
Tool.Equipped:connect(function(newMouse) onEquippedLocal(newMouse) end)

waitForChild(variables,&quot;InsertAsset&quot;)
waitForChild(variables.InsertAsset, &quot;Updated&quot;)
variables.InsertAsset.Updated.Changed:connect(function(prop)
&#9;if variables.InsertAsset.Updated.Value == true then
&#9;&#9;pressedEsc = false
&#9;&#9;beginInsertAssetStamp(variables.InsertAsset.AssetName.Value, variables.InsertAsset.AssetId.Value,
&#9;&#9;&#9;variables.InsertAsset.Image.Value, variables.InsertAsset.StampMode.Value)
&#9;&#9;variables.InsertAsset.Updated.Value = false
&#9;end
end)

waitForChild(variables, &quot;SwitchMode&quot;)
waitForChild(variables.SwitchMode, &quot;Mode&quot;)
variables.SwitchMode.Changed:connect(function()
&#9;if variables.SwitchMode.Value == true then
&#9;&#9;if variables.SwitchMode.Mode.Value == &quot;Clone&quot; then
&#9;&#9;&#9;startEyeDropperOperation()
&#9;&#9;end
&#9;&#9;variables.SwitchMode.Value = false
&#9;end
end)

waitForChild(variables, &quot;ReloadCurrentAsset&quot;)
variables.ReloadCurrentAsset.Changed:connect(function()
&#9;if variables.ReloadCurrentAsset.Value == true then
&#9;&#9;setupDraggableClone()
&#9;&#9;variables.ReloadCurrentAsset.Value = false
&#9;end
end)

Tool.Unequipped:connect(function() onUnequipped() end)
----------------------------------------------------------------------------------------


</ProtectedString>
				</Properties>
			</Item>
			<Item class="ScreenGui" referent="RBX113">
				<Properties>
					<string name="Name">topHint</string>
				</Properties>
				<Item class="ImageLabel" referent="RBX114">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><null></null></Content>
						<string name="Name">_preview</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX115">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">Bkg</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-250</XO>
								<YS>0</YS>
								<YO>10</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>400</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">3</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX116">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">5</token>
							<bool name="Modal">false</bool>
							<string name="Name">Label</string>
							<UDim2 name="Position">
								<XS>0.25</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>10</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<string name="Text">Saved changes</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX117">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Add</string>
						<ProtectedString name="Source">-- This script&apos;s job is to destroy previous topHint instance (if exists) and clone and run a new _topHint script (naming it &quot;topHint&quot;)
-- When this script is finished, it disables and resets itself.

function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

function waitForNoChild(instance, name)
&#9;while instance:FindFirstChild(name) do
&#9;&#9;instance.ChildRemoved:wait()
&#9;end
end

function waitForAnyChild(instance)
&#9;while not instance:GetChildren()[1] do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForChild(script, &quot;Label&quot;)
waitForChild(script, &quot;Time&quot;)
waitForChild(script, &quot;Width&quot;)
waitForChild(script.Parent, &quot;_topHint&quot;)
waitForChild(script.Parent._topHint, &quot;Label&quot;)
waitForChild(script.Parent._topHint, &quot;HideTime&quot;)
waitForChild(script.Parent._topHint, &quot;Width&quot;)

local width = 0.55--script.Width.Value
--width = math.min(0.55,width/script.Parent.AbsoluteSize.X)

local quickReplace = true

-- If there&apos;s already an instance, do you quickly replace the text and width (true), or animate out then in? (false)

if (script.Parent:FindFirstChild(&quot;topHint&quot;)~=nil) then
&#9;-- If there&apos;s already an instance...
&#9;if(quickReplace) then
&#9;&#9;-- If quickReplace is true...
&#9;&#9;local bkg = script.Parent.Bkg
&#9;&#9;local label = script.Parent.Label
&#9;&#9;local ys = bkg.Position.Y.Scale
&#9;&#9;local yo = bkg.Position.Y.Offset
&#9;&#9;bkg.Position = UDim2.new((1 - width)/2,0, ys, yo)
&#9;&#9;bkg.Size = UDim2.new(width,0, 0, 40)
&#9;&#9;label.Text = script.Label.Value
&#9;&#9;script.Parent.topHint.HideTime.Value = time() + script.Time.Value
&#9;else
&#9;&#9;-- If quickReplace is false...
&#9;&#9;script.Parent.Delete.Disabled = false
&#9;&#9;-- Wait for instance to be removed
&#9;&#9;waitForNoChild(script.Parent, &quot;topHint&quot;)
&#9;&#9;waitForNoChild(script.Parent, &quot;Bkg&quot;)
&#9;&#9;waitForNoChild(script.Parent, &quot;Label&quot;)
&#9;end
else
&#9;-- There&apos;s no previous instance.
&#9;-- Clone and enable a new instance
&#9;local topHint = script.Parent._topHint:Clone()
&#9;topHint.Parent = script.Parent
&#9;topHint.Name = &quot;topHint&quot;
&#9;topHint.Label.Value = script.Label.Value
&#9;topHint.HideTime.Value = time() + script.Time.Value
&#9;topHint.Width.Value = width
&#9;topHint.Disabled = false
end

script.Disabled = true
</ProtectedString>
					</Properties>
					<Item class="NumberValue" referent="RBX118">
						<Properties>
							<string name="Name">Width</string>
							<double name="Value">0</double>
						</Properties>
					</Item>
					<Item class="StringValue" referent="RBX119">
						<Properties>
							<string name="Name">Label</string>
							<string name="Value"></string>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX120">
						<Properties>
							<string name="Name">Time</string>
							<double name="Value">0</double>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX121">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_topHint</string>
						<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

function waitForNoChild(instance, name)
&#9;while instance:FindFirstChild(name) do
&#9;&#9;instance.ChildRemoved:wait()
&#9;end
end

function waitForAnyChild(instance)
&#9;while not instance:GetChildren()[1] do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

-- This script creates the graphics for the new topHint, and animates it.
-- Before calling this script, we&apos;ve already made sure: there&apos;s no other &quot;topHint&quot;, &quot;Bkg&quot;, and &quot;Label&quot;
-- Then, if time~=0, it waits &quot;time&quot; and then calls &quot;Remove&quot; script

waitForChild(script, &quot;Label&quot;)
waitForChild(script, &quot;HideTime&quot;)
waitForChild(script, &quot;Width&quot;)

local container = script.Parent
local labelText = script.Label.Value
local hideTime = script.HideTime.Value
local width = script.Width.Value

-- SETTINGS
local tweenTime = 0.3 -- animation time (seconds)
local topY = -50
local bottomY = 10
local easing = &quot;Sine.easeInOut&quot;
--

local bkg = Instance.new(&quot;Frame&quot;)
bkg.Parent = container
bkg.Name = &quot;Bkg&quot;
bkg.Position = UDim2.new((1 - width)/2,0, ys, yo)
bkg.Size = UDim2.new(width,0, 0, 40)
bkg.Style = &quot;RobloxRound&quot;

function destroy()
&#9;script.Parent.Delete.Disabled = false
end

local label = Instance.new(&quot;TextButton&quot;)
label.Parent = container
label.Name = &quot;Label&quot;
label.BackgroundTransparency = 1
label.FontSize = &quot;Size14&quot;
label.Position = UDim2.new((1 - width)/2,0, 0, topY)
label.Size = UDim2.new(width,0, 0, 40)
label.Text = labelText
label.TextColor3 = Color3.new(1, 1, 1)
label.MouseButton1Click:connect(destroy)

bkg:TweenPosition(UDim2.new(bkg.Position.X.Scale,bkg.Position.X.Offset,bkg.Position.Y.Scale,bottomY),
&#9;&#9;Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)

label:TweenPosition(UDim2.new(label.Position.X.Scale,label.Position.X.Offset,label.Position.Y.Scale,bottomY),
&#9;&#9;Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)

if(hideTime~=0) then
&#9;while(time() &lt; hideTime) do wait(0.1) end
&#9;destroy()
end</ProtectedString>
					</Properties>
					<Item class="NumberValue" referent="RBX122">
						<Properties>
							<string name="Name">Width</string>
							<double name="Value">0</double>
						</Properties>
					</Item>
					<Item class="StringValue" referent="RBX123">
						<Properties>
							<string name="Name">Label</string>
							<string name="Value"></string>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX124">
						<Properties>
							<string name="Name">HideTime</string>
							<double name="Value">0</double>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX125">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Delete</string>
						<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

function waitForNoChild(instance, name)
&#9;while instance:FindFirstChild(name) do
&#9;&#9;instance.ChildRemoved:wait()
&#9;end
end

function waitForAnyChild(instance)
&#9;while not instance:GetChildren()[1] do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local topHint = script.Parent:FindFirstChild(&quot;topHint&quot;)
local bkg = script.Parent:FindFirstChild(&quot;Bkg&quot;)
local label = script.Parent:FindFirstChild(&quot;Label&quot;)

-- SETTINGS
local tweenTime = 0.3 -- animation time (seconds)
local topY = -50 -- top position (Y Offset)
local easing = &quot;Back.easeInOut&quot;
--

if(topHint~=nil) then
&#9;topHint:Remove()
end

if(bkg~=nil) then
&#9;bkg:TweenPosition(UDim2.new(bkg.Position.X.Scale,bkg.Position.X.Offset,bkg.Position.Y.Scale,topY),
&#9;&#9;Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,tweenTime,true)
end

if(label~=nil) then
&#9;label:TweenPosition(UDim2.new(label.Position.X.Scale,label.Position.X.Offset,label.Position.Y.Scale,topY),
&#9;&#9;Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,tweenTime,true)
end

wait(tweenTime)
if(bkg~=nil) then bkg:Remove() end
if(label~=nil) then label:Remove() end

script.Disabled = true
</ProtectedString>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX126">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_readme</string>
						<ProtectedString name="Source">--
-- Top Hint
--
--  * This is a string of text that&apos;s top-centered in the window. (White text on black background)
--  * It should be used for messages from the client, and never from the place creator. 
--
-- FEATURES:
--  * Auto-hides previous messages before showing yours.
--  * Always centered, regardless of length.
--  * Clicking the message hides it.
-- 
-- USE IT FOR:
--  * Quick task-related (non-essential) hints
--  * Showing the current modal state
--  * Tool hints (for the currently equipped tool)
--  * Keyboard shortcuts
--
-- NEVER USE IT FOR:
--  * Essential information (Use a popup instead)
--  * Messages from users or place creators.  This is for client messages only.
--
-- ARGUMENTS:
--  Label:  The message
--  Width:  Text and background width (pixels) -- This should be removed when textWidth is added to Lua
--  Time:   Seconds before hiding itself (If 0, it never hides)
--
-- USAGE:
local topHint = script.Parent.topHint  -- path to topHint ScreenGui
topHint.Add.Label.Value = &quot;Press D to return to main menu.&quot;
topHint.Add.Width.Value = 290
topHint.Add.Time.Value = 7
topHint.Add.Disabled = true  -- flip it off then on, in case it&apos;s currently running.
topHint.Add.Disabled = false
--
-- TO HIDE MANUALLY:
topHint.Delete.Disabled = false
-- Clicking the message also hides it.</ProtectedString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX127">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>-0.699999988</Z>
					<R00>-0</R00>
					<R01>0</R01>
					<R02>1</R02>
					<R10>1</R10>
					<R11>-0</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>1</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<string name="Name">RotateTool</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset/?id=59103214</url></Content>
				<string name="ToolTip">Rotate</string>
			</Properties>
			<Item class="Part" referent="RBX128">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>166.125</X>
						<Y>213.637451</Y>
						<Z>144.5</Z>
						<R00>5.81145287e-005</R00>
						<R01>0.999160707</R01>
						<R02>0.040962413</R02>
						<R10>0.999998391</R10>
						<R11>1.49607658e-005</R11>
						<R12>-0.00178271532</R12>
						<R20>-0.00178183056</R20>
						<R21>0.0409624539</R21>
						<R22>-0.999159098</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>-0.043884553</X>
						<Y>-0.0049505271</Y>
						<Z>-0.0890169665</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0.00318993418</X>
						<Y>-0.0285553932</Y>
						<Z>-0.00247529079</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.800000012</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX129">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=16884681</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>0.600000024</X>
							<Y>0.600000024</Y>
							<Z>0.600000024</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=16884673</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX130">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RotateScript</string>
					<ProtectedString name="Source">-- NOTES:
--      NEEDS:
--            X  1.)  Make single blocks rotate always (they rotate 2x, then seem to think of themselves as blockers of themselves...  whaaa?)
--&#9;&#9;&#9;&#9;  X  2.)  Make scripts continue to work through rotations (or else error on any objects which can&apos;t be rotated...  prehaps elevators?)
--            3.)  File bug for #1 and for &quot;# of parts counted BEFORE instance-filter is applied for game.Workspace:FindPartsInRegion3&quot;
--            4.)  Make things rotate separately (break and make welds)
--&#9;&#9;&#9;&#9;  5.)  When something else is attached to a single block, stuff still breaks X&lt;

-- general functions
function waitForProperty(instance, name)
&#9;while not instance[name] do
&#9;&#9;instance.Changed:wait()
&#9;end
end
function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local Tool = script.Parent
local player
local playerArea = nil
local selectionBox = nil
local selectedModel = nil

local terrainSelectionBox = Instance.new(&quot;Part&quot;)
terrainSelectionBox.Parent = nil
terrainSelectionBox.formFactor = &quot;Custom&quot;
terrainSelectionBox.Size = Vector3.new(4, 4, 4)
terrainSelectionBox.CFrame = CFrame.new()

local cluster = nil

waitForChild(Tool, &quot;ErrorBox&quot;)
local errorBox = Tool.ErrorBox

waitForChild(Tool, &quot;PlayerOwner&quot;)
local playerOwner = Tool.PlayerOwner

waitForProperty(game,&quot;PlaceId&quot;)
local isRestricted = (game.PlaceId == 41324860 or game.PlaceId == 129686177)

game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://icons/configure_sel.png&quot;)


function getBoundingBox2(partOrModel)
-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
-- relative to the first part&apos;s coordinate frame.

&#9;local minVec = Vector3.new(math.huge, math.huge, math.huge)
&#9;local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

&#9;if partOrModel:IsA(&quot;Part&quot;) or partOrModel:IsA(&quot;WedgePart&quot;) or partOrModel:IsA(&quot;TrussPart&quot;)then
&#9;&#9;minVec = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
&#9;&#9;maxVec = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
&#9;else
&#9;&#9;local part1 = partOrModel:GetChildren()[1]
&#9;&#9;for i, object in pairs(partOrModel:GetChildren()) do
&#9;&#9;&#9;if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;TrussPart&quot;)) then
&#9;&#9;&#9;&#9;boxMinInWorld1 = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
&#9;&#9;&#9;&#9;--boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
&#9;&#9;&#9;&#9;boxMaxInWorld1 = object.CFrame:pointToWorldSpace(0.5 * object.Size)
&#9;&#9;&#9;&#9;--boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

&#9;&#9;&#9;&#9;local minX = minVec.x
&#9;&#9;&#9;&#9;local minY = minVec.y
&#9;&#9;&#9;&#9;local minZ = minVec.z
&#9;&#9;&#9;&#9;local maxX = maxVec.x
&#9;&#9;&#9;&#9;local maxY = maxVec.y
&#9;&#9;&#9;&#9;local maxZ = maxVec.z
&#9;&#9;&#9;&#9;if boxMinInWorld1.x &lt; minVec.x then
&#9;&#9;&#9;&#9;&#9;minX = boxMinInWorld1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld1.y &lt; minVec.y then
&#9;&#9;&#9;&#9;&#9;minY = boxMinInWorld1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld1.z &lt; minVec.z then
&#9;&#9;&#9;&#9;&#9;minZ = boxMinInWorld1.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.x &lt; minX then
&#9;&#9;&#9;&#9;&#9;minX = boxMaxInWorld1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.y &lt; minY then
&#9;&#9;&#9;&#9;&#9;minY = boxMaxInWorld1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.z &lt; minZ then
&#9;&#9;&#9;&#9;&#9;minZ = boxMaxInWorld1.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if boxMinInWorld1.x &gt; maxVec.x then
&#9;&#9;&#9;&#9;&#9;maxX = boxMinInWorld1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld1.y &gt; maxVec.y then
&#9;&#9;&#9;&#9;&#9;maxY = boxMinInWorld1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld1.z &gt; maxVec.z then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMinInWorld1.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.x &gt; maxX then
&#9;&#9;&#9;&#9;&#9;maxX = boxMaxInWorld1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.y &gt; maxY then
&#9;&#9;&#9;&#9;&#9;maxY = boxMaxInWorld1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.z &gt; maxZ then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMaxInWorld1.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;minVec = Vector3.new(minX, minY, minZ)
&#9;&#9;&#9;&#9;maxVec = Vector3.new(maxX, maxY, maxZ)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return minVec, maxVec
end

function isInRobloxModel(part)
&#9;if part == game.Workspace then
&#9;&#9;return false, nil
&#9;elseif part:FindFirstChild(&quot;RobloxModel&quot;) then 
&#9;&#9;return true, part
&#9;else
&#9;&#9;return isInRobloxModel(part.Parent)
&#9;end
end

function isInMyArea(part)
&#9;if playerArea:FindFirstChild(&quot;PlayerArea&quot;)then
&#9;&#9;return playerArea.PlayerArea:IsAncestorOf(part)
&#9;end
&#9;return false
end


function on3dButton1Down(mouse)
&#9;-- don&apos;t do anything for now (can fix later: for now this means you can click one model, drag mouse to second model, and release mouse, and this will activate second model)
end


function offsetPartsByVector3(partOrModel, offsetVector)
&#9;local insertCFrame
&#9;if partOrModel:IsA(&quot;Model&quot;) then
&#9;&#9;for i, object in pairs(partOrModel:GetChildren()) do
&#9;&#9;&#9;if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;TrussPart&quot;)) then
&#9;&#9;&#9;&#9;object.CFrame = object.CFrame + offsetVector
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;partOrModel.CFrame = partOrModel.CFrame + offsetVector
&#9;end
end

function storeAndDisableScriptsInModel(parent, scriptTable)
&#9;for i, object in pairs(parent:GetChildren()) do
&#9;&#9;if object:IsA(&quot;Script&quot;) or object:IsA(&quot;LocalScript&quot;) then if not object.Disabled then object.Disabled = true table.insert(scriptTable, object) end end
&#9;&#9;if object.GetChildren then storeAndDisableScriptsInModel(object, scriptTable) end
&#9;end
end

function isInternalWeld(weld, model)
&#9;return (not weld.Part0 or weld.Part0:IsDescendantOf(model)) and (not weld.Part1 or weld.Part1:IsDescendantOf(model))
end

function storeAndRemoveWeldsInModel(initialmodel, model, welds, weldParents)
&#9;for i, object in pairs(model:GetChildren()) do
&#9;&#9;if object.className == &quot;ManualWeld&quot; then if isInternalWeld(object, initialmodel) then table.insert(welds, object) table.insert(weldParents, object.Parent) object.Parent = nil end end
&#9;&#9;if object.GetChildren then storeAndRemoveWeldsInModel(initialmodel, object, welds, weldParents) end
&#9;end
end


local debris = game:GetService(&quot;Debris&quot;)
function flashRedBox(modelToFlash)
&#9;if not modelToFlash then return end 

&#9;errorBox.Parent = player.PlayerGui
&#9;errorBox.Adornee = modelToFlash

&#9;delay(0,function()
&#9;&#9;for i = 1, 3 do
&#9;&#9;&#9;errorBox.Visible = true
&#9;&#9;&#9;wait(0.13)
&#9;&#9;&#9;errorBox.Visible = false
&#9;&#9;&#9;wait(0.13)
&#9;&#9;end
&#9;&#9;errorBox.Adornee = nil
&#9;&#9;errorBox.Parent = Tool
&#9;end)
end


-- below function should work as a Region3 query, returning true if a single cluster part is within this region
function clusterPartsInRegion(startVector, endVector)
&#9;if not cluster then return false end

&#9;local startCell = cluster:WorldToCell(startVector)
&#9;local endCell = cluster:WorldToCell(endVector)

&#9;local startX = startCell.X
&#9;local startY = startCell.Y
&#9;local startZ = startCell.Z

&#9;local endX = endCell.X
&#9;local endY = endCell.Y
&#9;local endZ = endCell.Z

&#9;if startX &lt; cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
&#9;if startY &lt; cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
&#9;if startZ &lt; cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end

&#9;if endX &gt; cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
&#9;if endY &gt; cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
&#9;if endZ &gt; cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end

&#9;for x = startX, endX do
&#9;&#9;for y = startY, endY do
&#9;&#9;&#9;for z = startZ, endZ do
&#9;&#9;&#9;&#9;if (cluster:GetCell(x, y, z).Value) &gt; 0 then return true end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return false
end


local debounce = false
function on3dButton1Up(mouse)
&#9;local modelToRotate = selectedModel -- so that other mouse events can&apos;t give us race conditions

&#9;if modelToRotate and not debounce then
&#9;&#9;debounce = true

&#9;&#9;if modelToRotate == terrainSelectionBox then
&#9;&#9;&#9;-- just rotate the terrain cell if we&apos;re selecting on terrain
&#9;&#9;&#9;local cellPos = game.Workspace.Terrain:WorldToCell(terrainSelectionBox.CFrame.p)
&#9;&#9;&#9;local cellMat, cellType, cellOrient = game.Workspace.Terrain:GetCell(cellPos.X, cellPos.Y, cellPos.Z)
&#9;&#9;&#9;game.Workspace.Terrain:SetCell(cellPos.X, cellPos.Y, cellPos.Z, cellMat, cellType, (cellOrient.Value + 1)%4)

&#9;&#9;&#9;debounce = false
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;-- get the model centroid
&#9;&#9;local minBB, maxBB = getBoundingBox2(modelToRotate)
&#9;&#9;local oldModelCentroid = (minBB + maxBB) / 2  -- point to rotate around

&#9;&#9;local diagVector = minBB - oldModelCentroid
&#9;&#9;local rotatedDiagVector = Vector3.new(diagVector.Z, diagVector.Y, diagVector.X)
&#9;&#9;local rotatedMinBB = oldModelCentroid + rotatedDiagVector
&#9;&#9;local rotatedMaxBB = oldModelCentroid - rotatedDiagVector

&#9;&#9;-- check if part rotation will cause collision
&#9;&#9;local fudgeVector = Vector3.new(0.4, 0.4, 0.4)  -- mmmmmm, fudge

&#9;&#9;-- we need to check the even/odd parity on the x and z axes of the model.  If there is a difference, then the rotation will push the model off-grid, so we will
&#9;&#9;&#9;--   need to adjust
&#9;&#9;local adjustVector = Vector3.new(0, 0, 0)
&#9;&#9;local diffVector = minBB - maxBB
&#9;&#9;local garbage, xParity = math.modf(math.modf(math.abs(diffVector.X)/4 + .5)/2)
&#9;&#9;local garbage, zParity = math.modf(math.modf(math.abs(diffVector.Z)/4 + .5)/2)
&#9;&#9;xParity = math.floor(xParity*2 + .5)
&#9;&#9;zParity = math.floor(zParity*2 + .5)
&#9;&#9;if xParity ~= zParity then
&#9;&#9;&#9;-- need to shift
&#9;&#9;&#9;adjustVector = Vector3.new(2, 0, 2)
&#9;&#9;&#9;local mouseHitFrame = mouse.Hit
&#9;&#9;&#9;if mouseHitFrame then
&#9;&#9;&#9;&#9;local mouseHit = mouseHitFrame.p
&#9;&#9;&#9;&#9;if math.abs(diffVector.X) &gt; math.abs(diffVector.Z) then
&#9;&#9;&#9;&#9;&#9;-- longest axis is X-axis
&#9;&#9;&#9;&#9;&#9;if mouseHit.X &gt; oldModelCentroid.X then
&#9;&#9;&#9;&#9;&#9;&#9;adjustVector = Vector3.new(2, 0, 2)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;adjustVector = Vector3.new(-2, 0, -2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;-- longest axis is Z-axis
&#9;&#9;&#9;&#9;&#9;if mouseHit.Z &gt; oldModelCentroid.Z then
&#9;&#9;&#9;&#9;&#9;&#9;adjustVector = Vector3.new(-2, 0, 2)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;adjustVector = Vector3.new(2, 0, -2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;-- below line checks CURRENT BB, not post-rotation BB
&#9;&#9;--local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB + fudgeVector, maxBB - fudgeVector), modelToRotate, 100)

&#9;&#9;-- if blocked by the cluster, then exit out
&#9;&#9;if cluster and clusterPartsInRegion(minBB + fudgeVector, maxBB - fudgeVector) then
&#9;&#9;&#9;debounce = false
&#9;&#9;&#9;flashRedBox(modelToRotate)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(rotatedMinBB + fudgeVector + adjustVector, rotatedMaxBB - fudgeVector + adjustVector), modelToRotate, 100)

&#9;&#9;if #blockingParts &gt; 1 or (#blockingParts &gt; 0 and blockingParts[1] ~= modelToRotate) then
&#9;&#9;&#9;-- BLOCKED!!  MAKE ERROR NOISE!
&#9;&#9;&#9;for j = 1, #blockingParts do 
&#9;&#9;&#9;&#9;if blockingParts[j].className ~= &quot;WedgePart&quot; and (blockingParts[j].Size / 2):Dot(blockingParts[j].Size / 2) &gt; 9 and blockingParts[j] ~= modelToRotate then
&#9;&#9;&#9;&#9;&#9;debounce = false
&#9;&#9;&#9;&#9;&#9;flashRedBox(modelToRotate)
&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;--else
&#9;&#9;end
&#9;&#9;&#9;-- do the rotation! :D
&#9;&#9;&#9;local rotCF = CFrame.fromEulerAnglesXYZ(0, math.pi/2, 0)

&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveInstance(modelToRotate)
&#9;&#9;&#9;game.JointsService:ClearJoinAfterMoveJoints()

&#9;&#9;
&#9;&#9;&#9;-- below simple script disabling/re-enabling works for all scripts in normal usabilityset except for elevators and retracting spike [see if just need to change &quot;Weld&quot; in spikescript to &quot;ManualWeld&quot;... may need to also make sure below script-table can store all descendent scripts of modelToRotate, and not just immediate children...]
&#9;&#9;&#9;&#9;-- and elevator scripts only break if you rotate when the elevator is in the &quot;fully down&quot; position...  probably just need some sort of check in ElevatorScript for this case

&#9;&#9;&#9;local scriptsToTurnBackOn = {}
&#9;&#9;&#9;storeAndDisableScriptsInModel(modelToRotate, scriptsToTurnBackOn)

&#9;&#9;&#9;local weldsToReturn = {}
&#9;&#9;&#9;local weldParentsToReturn = {}
&#9;&#9;&#9;storeAndRemoveWeldsInModel(modelToRotate, modelToRotate, weldsToReturn, weldParentsToReturn)

&#9;&#9;&#9;modelToRotate:BreakJoints()

&#9;&#9;&#9;if modelToRotate:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;&#9;for i, object in pairs(modelToRotate:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) then object.CFrame = rotCF * object.CFrame end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;modelToRotate.CFrame = rotCF * modelToRotate.CFrame
&#9;&#9;&#9;end

&#9;&#9;&#9;-- fix position so centroid remains in same place [and then move centroid by adjustVector so it stays on grid]
&#9;&#9;&#9;local newMinBB, newMaxBB = getBoundingBox2(modelToRotate)
&#9;&#9;&#9;local newModelCentroid = (newMinBB + newMaxBB) / 2
&#9;&#9;&#9;offsetPartsByVector3(modelToRotate, oldModelCentroid - newModelCentroid + adjustVector)

&#9;&#9;&#9;game.JointsService:CreateJoinAfterMoveJoints()
&#9;&#9;&#9;modelToRotate:MakeJoints()

&#9;&#9;&#9;-- return all manual welds
&#9;&#9;&#9;for i = 1, #weldsToReturn do weldsToReturn[i].Parent = weldParentsToReturn[i] end

&#9;&#9;&#9;-- turn back on scripts
&#9;&#9;&#9;for i = 1, #scriptsToTurnBackOn do scriptsToTurnBackOn[i].Disabled = false end
&#9;&#9;--end

&#9;&#9;--[[ for debugging
&#9;&#9;local tempPart = Instance.new(&quot;Part&quot;)
&#9;&#9;tempPart.CanCollide = false
&#9;&#9;tempPart.Anchored = true
&#9;&#9;tempPart.Size = maxBB - minBB
&#9;&#9;tempPart.CFrame = CFrame.new((minBB + maxBB)/2)
&#9;&#9;tempPart.Parent = game.Workspace
&#9;&#9;game:GetService(&quot;Debris&quot;):AddItem(tempPart, .5) ]]--


&#9;&#9;debounce = false
&#9;end
end

function on3dMouseMove(mouse)
&#9;local mouseModel

&#9;if mouse.Target and mouse.Target:IsA(&quot;Terrain&quot;) and not isRestricted and mouse.Hit and (mouse.Hit.p - Tool.Parent.Head.Position).magnitude &lt; 60 then
&#9;&#9;-- do something special if we&apos;re selecting close-by terrain
&#9;&#9;selectedModel = terrainSelectionBox

&#9;&#9;local cell = game.Workspace.Terrain:WorldToCellPreferSolid(mouse.Hit.p)
&#9;&#9;local cellCenter = game.Workspace.Terrain:CellCenterToWorld(cell.X, cell.Y, cell.Z)
&#9;&#9;terrainSelectionBox.CFrame = CFrame.new(cellCenter)

&#9;&#9;selectionBox.Adornee = selectedModel
&#9;&#9;return
&#9;end

&#9;if mouse.Target == nil then mouseModel = nil
&#9;else boolGarbage, mouseModel = isInRobloxModel(mouse.Target) end

&#9;if mouseModel == nil or (isRestricted and (not isInMyArea(mouseModel))) then mouseModel = nil end

&#9;-- see if need to switch selectionBox
&#9;if mouseModel ~= selectedModel then
&#9;&#9;selectedModel = mouseModel
&#9;&#9;selectionBox.Adornee = selectedModel
&#9;end
end

function canSelectObject(part)
&#9;if isRestricted then
&#9;&#9;waitForChild(playerArea,&quot;PlayerArea&quot;)
&#9;&#9;if playerArea:FindFirstChild(&quot;PlayerArea&quot;) and part:IsDescendantOf(playerArea.PlayerArea) then
&#9;&#9;&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end

&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function onEquippedLocal(mouse)
&#9;if game.Workspace:FindFirstChild(&quot;Terrain&quot;) then
&#9;&#9;cluster = game.Workspace.Terrain
&#9;end

&#9;local character = script.Parent.Parent
&#9;player = game.Players:GetPlayerFromCharacter(character)

&#9;if player == nil then return end
&#9;if playerOwner.Value and playerOwner.Value ~= player then return end
&#9;playerOwner.Value = player

&#9;if isRestricted then
&#9;&#9;waitForChild(game.Workspace,&quot;BuildingAreas&quot;)
&#9;&#9;waitForChild(game.Workspace.BuildingAreas,&quot;Area1&quot;)
&#9;&#9;waitForChild(game.Workspace.BuildingAreas.Area1,&quot;Player&quot;)
&#9;&#9;local areas = game.Workspace.BuildingAreas:GetChildren()
&#9;&#9;for i = 1, #areas do
&#9;&#9;&#9;if areas[i]:FindFirstChild(&quot;Player&quot;) and areas[i].Player.Value == player.Name then
&#9;&#9;&#9;&#9;playerArea = areas[i]
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;if game.Workspace:FindFirstChild(&quot;BaseplateBumpers&quot;) then mouse.TargetFilter = game.Workspace.BaseplateBumpers end

&#9;mouse.Icon = &quot;http://www.roblox.com/asset?id=67163124&quot;
&#9;mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)
&#9;mouse.Button1Up:connect(function() on3dButton1Up(mouse) end)
&#9;mouse.Move:connect(function() on3dMouseMove(mouse) end)
&#9;
&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Name = &quot;MainSelectionBox&quot;
&#9;selectionBox.Color = BrickColor.Blue()
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = player.PlayerGui;

&#9;on3dMouseMove(mouse) -- so if they unequip/reequip, they still have selection box
end

function onUnequippedLocal()
&#9;if selectionBox then selectionBox:Remove() end
&#9;selectedModel = nil
&#9;player = nil
end


Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)

</ProtectedString>
				</Properties>
			</Item>
			<Item class="SelectionBox" referent="RBX131">
				<Properties>
					<Ref name="Adornee">null</Ref>
					<int name="Color">21</int>
					<string name="Name">ErrorBox</string>
					<float name="Transparency">0</float>
					<bool name="Visible">false</bool>
				</Properties>
			</Item>
			<Item class="ObjectValue" referent="RBX132">
				<Properties>
					<string name="Name">PlayerOwner</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX133">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>-0.5</Z>
					<R00>0</R00>
					<R01>0</R01>
					<R02>1</R02>
					<R10>1</R10>
					<R11>0</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>1</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<string name="Name">DeleteTool</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset?id=55212908</url></Content>
				<string name="ToolTip"></string>
			</Properties>
			<Item class="Part" referent="RBX134">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>131.75</X>
						<Y>217.574951</Y>
						<Z>160.8125</Z>
						<R00>-0.387897134</R00>
						<R01>0.000652840186</R01>
						<R02>0.921702504</R02>
						<R10>0.000821671856</R10>
						<R11>0.999999583</R11>
						<R12>-0.000362498598</R12>
						<R20>-0.921702385</R20>
						<R21>0.000616724836</R21>
						<R22>-0.387897491</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0.400000006</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0.00807761215</X>
						<Y>0.00224074489</Y>
						<Z>0.00253608939</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>-4.32013621e-005</X>
						<Y>0.00175812328</Y>
						<Z>-0.00146475947</Z>
					</Vector3>
					<token name="formFactorRaw">2</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.800000012</Y>
						<Z>3</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX135">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=16198309</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1.20000005</X>
							<Y>1.20000005</Y>
							<Z>1.20000005</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=16198294</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX136">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Sound</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.roblox.com/Asset/?ID=12135982</url></Content>
						<float name="Volume">0.699999988</float>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX137">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Model Delete Local</string>
					<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end


local Tool = script.Parent

enabled = true
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://icons/delete_sel.png&quot;)

local cluster = nil

local selectionBox
local currentSelection
local currentSelectionColors = {}
local selectionLasso

local deleteDistance = 100
local player = nil
--local playerModel = nil
local playerModel = game.Workspace
local buildingPlate = nil

local highlight = false

local megaClusterSelectionBox = Instance.new(&quot;Part&quot;)
megaClusterSelectionBox.FormFactor = &quot;Custom&quot;
megaClusterSelectionBox.Size = Vector3.new(4, 4, 4) -- a little thicker than 4x4x4 unit clusterpart; just so selection box is more easily seen
megaClusterSelectionBox.Transparency = 1
megaClusterSelectionBox.Anchored = true
megaClusterSelectionBox.CanCollide = false
megaClusterSelectionBox.Parent = nil

waitForChild(Tool, &quot;IsRestricted&quot;)
local isRestricted = Tool.IsRestricted.Value

waitForChild(Tool, &quot;AutoWedgeClusterParts&quot;)
local autoWedgeClusterParts = Tool.AutoWedgeClusterParts.Value

function hint(label)

&#9;-- Pass in a string, it shows a top hint.  (Replaces previous hint, if exists)
&#9;_player = game.Players:GetPlayerFromCharacter(Tool.Parent)
&#9;if(_player ~= nil and _player.PlayerGui:FindFirstChild(&quot;topHint&quot;)~=nil) then
&#9;&#9;local topHint = _player.PlayerGui.topHint
&#9;&#9;topHint.Add.Label.Value = label
&#9;&#9;topHint.Add.Width.Value = 3 -- widest width
&#9;&#9;topHint.Add.Time.Value = 5
&#9;&#9;topHint.Add.Disabled = true
&#9;&#9;topHint.Add.Disabled = false
&#9;end

end

function canDeleteObject(part)
&#9;-- let them delete anything that they created *or* anything on their baseplate
&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; deleteDistance and (isChildOfMyModel(part) or partInBounds(part))
end

-- For Restricting Stamper Tool (isRestricted)
function inBounds(part)

&#9;if part == nil then return false end

&#9;if part:IsA(&quot;Part&quot;) or part:IsA(&quot;WedgePart&quot;) or part:IsA(&quot;TrussPart&quot;) then
&#9;&#9;if not partInBounds(part) then return false end
&#9;elseif part:IsA(&quot;Model&quot;) then
&#9;&#9;local primPart = object.PrimaryPart
&#9;&#9;if not partInBounds(primPart) then return false end
&#9;end

&#9;return true

end

function partInBounds(part)

&#9;local xOne = buildingPlate.Position.x + buildingPlate.Size.x/2
&#9;local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
&#9;local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
&#9;local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2

&#9;if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
&#9;if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end

&#9;return true

end


function findModel(part)
&#9;while part ~= nil do
&#9;&#9;if part.className == &quot;Model&quot; and part.Name ~= playerModel.Name and part.Name ~= &quot;GarbageParts&quot; then
&#9;&#9;&#9;return part
&#9;&#9;elseif part.Name == playerModel.Name or part.Name == &quot;GarbageParts&quot; then
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;&#9;part = part.Parent
&#9;end

&#9;return nil
end

function cleanOrphanedModel(parent)
&#9;if not parent then return end
&#9;if parent.className == &quot;Model&quot; then
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;if #children == 0 and parent.Name ~= &quot;GarbageParts&quot; then
&#9;&#9;&#9;local oldParent = parent.Parent
&#9;&#9;&#9;parent:Remove()
&#9;&#9;&#9;cleanOrphanedModel(oldParent)
&#9;&#9;end
&#9;end
end

function isChildOfMyModel(part)
&#9;&#9;if not playerModel then return true end
&#9;&#9;if playerModel:IsAncestorOf(part) then
&#9;&#9;&#9;return true
&#9;&#9;else return false end
end


-- Cyrion&apos;s auto-wedge fcn:
--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously was
--returns true if made a wedge, false if the cell remains a block
function MakeWedge(x, y, z, defaultmaterial)
&#9;local c = game.Workspace.Terrain
&#9;--gather info about all the cells around x, y, z
&#9;surroundings = {} --surroundings is a 3 x 3 x 3 array of the material of the cells adjacent to x, y, z
&#9;for i = x - 1, x + 1 do
&#9;&#9;surroundings[i] = {}
&#9;&#9;for j = y - 1, y + 1 do
&#9;&#9;&#9;surroundings[i][j] = {}
&#9;&#9;&#9;for k = z - 1, z + 1 do
&#9;&#9;&#9;&#9;local material, wedge, rotation = c:GetCell(i, j, k)
&#9;&#9;&#9;&#9;surroundings[i][j][k] = material.Value
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--make some useful arrays and counters
&#9;local sides = {} --sides is an array of the material of the 4 adjacent sides
&#9;sides[0] = surroundings[x - 1][y][z]
&#9;sides[1] = surroundings[x][y][z + 1]
&#9;sides[2] = surroundings[x + 1][y][z]
&#9;sides[3] = surroundings[x][y][z - 1]
&#9;local adjacentSides = 0
&#9;for n = 0, 3 do
&#9;&#9;if sides[n] &gt; 0 then
&#9;&#9;&#9;adjacentSides = adjacentSides + 1
&#9;&#9;end
&#9;end
&#9;local sidesAbove = {} --sides is an array of the material of the 4 adjacent sides 1 height above
&#9;sidesAbove[0] = surroundings[x - 1][y + 1][z]
&#9;sidesAbove[1] = surroundings[x][y + 1][z + 1]
&#9;sidesAbove[2] = surroundings[x + 1][y + 1][z]
&#9;sidesAbove[3] = surroundings[x][y + 1][z - 1]
&#9;local adjacentSidesAbove = 0
&#9;for n = 0, 3 do
&#9;&#9;if sidesAbove[n] &gt; 0 then
&#9;&#9;&#9;adjacentSidesAbove = adjacentSidesAbove + 1
&#9;&#9;end
&#9;end
&#9;local corners = {} --corners is an array of the material of the 4 adjacent corners
&#9;corners[0] = surroundings[x - 1][y][z - 1]
&#9;corners[1] = surroundings[x - 1][y][z + 1]
&#9;corners[2] = surroundings[x + 1][y][z + 1]
&#9;corners[3] = surroundings[x + 1][y][z - 1]
&#9;local adjacentCorners = 0
&#9;for n = 0, 3 do
&#9;&#9;if corners[n] &gt; 0 then
&#9;&#9;&#9;adjacentCorners = adjacentCorners + 1
&#9;&#9;end
&#9;end
&#9;local cornersAbove = {} --corners is an array of the material of the 4 adjacent corners 1 height above
&#9;cornersAbove[0] = surroundings[x - 1][y + 1][z - 1]
&#9;cornersAbove[1] = surroundings[x - 1][y + 1][z + 1]
&#9;cornersAbove[2] = surroundings[x + 1][y + 1][z + 1]
&#9;cornersAbove[3] = surroundings[x + 1][y + 1][z - 1]
&#9;local adjacentCornersAbove = 0
&#9;for n = 0, 3 do
&#9;&#9;if cornersAbove[n] &gt; 0 then
&#9;&#9;&#9;adjacentCornersAbove = adjacentCornersAbove + 1
&#9;&#9;end
&#9;end
&#9;--determine what type of wedge to make
&#9;local material = nil
&#9;local wedge = nil
&#9;local rotation = nil 
&#9;if defaultmaterial then
&#9;&#9;material = defaultmaterial
&#9;else
&#9;&#9;material, wedge, rotation = c:GetCell(x, y, z) --start with the existing material, wedge, and rotation
&#9;end
&#9;wedge = 0 --default wedge is a block
&#9;rotation = 0 --default rotation is 0
&#9;--type 1: 45 degree ramp //must not have a block on top and must have a block under, and be surrounded by 1 side; or 3 sides and the 2 corners between them
&#9;if surroundings[x][y + 1][z] == 0 and surroundings[x][y - 1][z] &gt; 0 then
&#9;&#9;if adjacentSides == 1 then
&#9;&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;&#9;if sides[n] &gt; 0 then
&#9;&#9;&#9;&#9;&#9;wedge = 1
&#9;&#9;&#9;&#9;&#9;rotation = (n + 1) % 4
&#9;&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;elseif  adjacentSides == 3 then
&#9;&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;&#9;if sides[n] &gt; 0 and corners[(n + 1) % 4] &gt; 0 and sides[(n + 1) % 4] &gt; 0 and corners[(n + 2) % 4] &gt; 0 and sides[(n + 2) % 4] &gt; 0 then
&#9;&#9;&#9;&#9;&#9;wedge = 1
&#9;&#9;&#9;&#9;&#9;rotation = (n + 2) % 4
&#9;&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--type 2: 45 degree corner //must not have a block on top and must have a block under, and be surrounded by 2 sides and the 1 corner between them; or 3 sides and 1 corner between 2 of them (facing towards that corner)
&#9;if surroundings[x][y + 1][z] == 0 and surroundings[x][y - 1][z] &gt; 0 then
&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;if sides[n] &gt; 0 and corners[(n + 1) % 4] &gt; 0 and sides[(n + 1) % 4] &gt; 0 and (adjacentSides == 2 or (adjacentSides == 3 and (corners[(n + 3) % 4] &gt; 0 or (sides[(n + 2) % 4] &gt; 0 and corners[(n + 2) % 4] &gt; 0) or (sides[(n + 3) % 4] &gt; 0 and corners[n] &gt; 0)))) then
&#9;&#9;&#9;&#9;wedge = 2
&#9;&#9;&#9;&#9;rotation = (n + 2) % 4
&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--type 3: 45 degree inverse corner //surrounded by three sides or 4 sides and 3 corners, with nothing above or else a block on top surrounded on 2 sides and the corner between them
&#9;if adjacentSides == 3 and surroundings[x][y + 1][z] &gt; 0 then
&#9;&#9;if adjacentCorners &gt; 1 then
&#9;&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;&#9;if (corners[n] == 0 or cornersAbove[n] == 0) and (sides[(n - 1) % 4] == 0 or sides[n] == 0) and (sidesAbove[n] == 0 and sidesAbove[(n + 1) % 4] &gt; 0 and sidesAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 3) % 4] == 0) then 
&#9;&#9;&#9;&#9;&#9;wedge = 3
&#9;&#9;&#9;&#9;&#9;rotation = (n + 3) % 4
&#9;&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;elseif adjacentSides == 4 and adjacentCorners == 3 then
&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;if corners[n] == 0 and (surroundings[x][y + 1][z] == 0 or (sidesAbove[n] == 0 and sidesAbove[(n + 1) % 4] &gt; 0 and cornersAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 3) % 4] == 0)) then
&#9;&#9;&#9;&#9;wedge = 3
&#9;&#9;&#9;&#9;rotation = (n + 3) % 4
&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--type 4: half a cube, as if it were cut diagonally from front to back //surrounded by 2 sides
&#9;if adjacentSides == 2 and adjacentCorners &lt; 4 then
&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;if sides[n] == 0 and sides[(n + 1) % 4] == 0 and (surroundings[x][y + 1][z] == 0 or (sidesAbove[n] == 0 and sidesAbove[(n + 1) % 4] == 0 and sidesAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 3) % 4] &gt; 0)) then
&#9;&#9;&#9;&#9;wedge = 4
&#9;&#9;&#9;&#9;rotation = n
&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;return false
end

function on3dButton1Down(mouse)
&#9;local part = mouse.Target

&#9;if part == nil then 
&#9;&#9;return
&#9;elseif part:IsA(&quot;Terrain&quot;) then
&#9;&#9;if cluster ~= nil then
&#9;&#9;&#9;local cellPos = cluster:WorldToCellPreferSolid(Vector3.new(mouse.Hit.x, mouse.Hit.y, mouse.Hit.z))
&#9;&#9;&#9;local x = cellPos.x
&#9;&#9;&#9;local y = cellPos.y
&#9;&#9;&#9;local z = cellPos.z

&#9;&#9;&#9;cluster:SetCell(x, y, z, 0, 0, 0)
&#9;&#9;&#9;
&#9;&#9;&#9;if (autoWedgeClusterParts) then

&#9;&#9;&#9;&#9;for i = x - 1, x + 1 do
&#9;&#9;&#9;&#9;&#9;for j = y - 1, y + 1 do
&#9;&#9;&#9;&#9;&#9;&#9;for k = z - 1, z + 1 do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;MakeWedge(i, j, k)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;end

&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;on3dMouseMove(mouse)

&#9;&#9;end
&#9;elseif canDeleteObject(part) then
&#9;&#9;local model = findModel(part)
&#9;&#9;local oldParent
&#9;&#9;if model then 
&#9;&#9;&#9;if currentSelection == model then
&#9;&#9;&#9;&#9;currentSelection = nil
&#9;&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;end
&#9;&#9;&#9;oldParent = model.Parent
&#9;&#9;&#9;model:Remove()
&#9;&#9;else
&#9;&#9;&#9;if currentSelection == part then
&#9;&#9;&#9;&#9;currentSelection = nil
&#9;&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;end
&#9;&#9;&#9;oldParent = part.Parent
&#9;&#9;&#9;part:Remove()
&#9;&#9;end
&#9;&#9;cleanOrphanedModel(oldParent)
&#9;end
end

function saveSelectionColor(instance)
&#9;if instance:IsA(&quot;BasePart&quot;) then
&#9;&#9;currentSelectionColors[instance] = instance.BrickColor
&#9;&#9;if instance.BrickColor == BrickColor.Red() then
&#9;&#9;&#9;instance.BrickColor = BrickColor.new(&quot;Really red&quot;)
&#9;&#9;else
&#9;&#9;&#9;instance.BrickColor = BrickColor.Red()
&#9;&#9;end
&#9;end
end
&#9;
function setSelection(partOrModel)
&#9;if partOrModel ~= currentSelection then
&#9;&#9;clearSelection()
&#9;&#9;currentSelection = partOrModel
&#9;&#9;selectionBox.Adornee = currentSelection
&#9;end
end

function clearSelection()
&#9;if currentSelection ~= nil then
&#9;&#9;for part, color in pairs(currentSelectionColors) do
&#9;&#9;&#9;part.BrickColor = color
&#9;&#9;end
&#9;&#9;selectionBox.Adornee = nil
&#9;end
&#9;currentSelectionColors = {}
&#9;if currentSelection then currentSelection = nil end
&#9;if selectionBox then selectionBox.Adornee = nil end
&#9;megaClusterSelectionBox.Parent = nil
end


function on3dMouseMove(mouse) 
&#9;if isRestricted then
&#9;&#9;mouse.TargetFilter = game.Workspace.BaseplateBumpers
&#9;else
&#9;&#9;mouse.TargetFilter = megaClusterSelectionBox
&#9;end
&#9;local part = mouse.Target

&#9;if not part then
&#9;&#9;clearSelection() 
&#9;&#9;return
&#9;elseif part:IsA(&quot;Terrain&quot;) then
&#9;&#9;if not cluster then cluster = game.Workspace.Terrain end
&#9;&#9;local hitCell = cluster:WorldToCellPreferSolid(mouse.Hit.p)
&#9;&#9;if cluster:GetCell(hitCell.x, hitCell.y, hitCell.z).Value &gt; 0 then
&#9;&#9;&#9;megaClusterSelectionBox.CFrame = CFrame.new(cluster:CellCenterToWorld(hitCell.x, hitCell.y, hitCell.z))

&#9;&#9;&#9;if isRestricted then megaClusterSelectionBox.Parent = game.Workspace.BaseplateBumpers else megaClusterSelectionBox.Parent = game.Workspace end
&#9;&#9;&#9;selectionBox.Adornee = megaClusterSelectionBox
&#9;&#9;else
&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;return
&#9;&#9;end
&#9;elseif canDeleteObject(part) then
&#9;&#9;local model = findModel(part)
&#9;&#9;if model then &#9;&#9;
&#9;&#9;&#9;selectionBox.Color = BrickColor.Red()
&#9;&#9;&#9;setSelection(model)
&#9;&#9;else
&#9;&#9;&#9;selectionBox.Color = BrickColor.Red()
&#9;&#9;&#9;setSelection(part)
&#9;&#9;end
&#9;else
&#9;&#9;clearSelection()
&#9;end
end

local equipCount = 0
function onEquippedLocal(mouse)
&#9;equipCount = equipCount + 1
&#9;local val = equipCount

&#9;if isRestricted then
&#9;&#9;waitForChild(game.Workspace, &quot;BuildingAreas&quot;)
&#9;&#9;if val ~= equipCount then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end

&#9;local character = script.Parent.Parent
&#9;player = game.Players:GetPlayerFromCharacter(character)
&#9;
&#9;if not player then return end

&#9;if isRestricted then
&#9;&#9;local takenAreas = game.Workspace.BuildingAreas:GetChildren()
&#9;&#9;for i = 1, #takenAreas do
&#9;&#9;&#9;&#9;if takenAreas[i]:FindFirstChild(&quot;Player&quot;) ~= nil then  -- Test if child exists (to fix current bug: &quot;Player&quot; child is omitted from 1 baseplate at random, when played online.)
&#9;&#9;&#9;&#9;&#9;if takenAreas[i].Player.Value == Tool.Parent.Name then
&#9;&#9;&#9;&#9;&#9;&#9;buildingPlate = takenAreas[i].PlayerArea.BasePlate
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

   if buildingPlate then
&#9;&#9;playerModel  = buildingPlate.Parent
&#9;else
&#9;&#9;--playerModel  = nil
&#9;&#9;playerModel = game.Workspace
&#9;end
&#9;guiMain = Instance.new(&quot;ScreenGui&quot;)
&#9;guiMain.Parent = player.PlayerGui

&#9;mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)
&#9;mouse.Move:connect(function() on3dMouseMove(mouse) end)
&#9;mouse.Icon =&quot;rbxasset://textures\\HammerCursor.png&quot;

&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Name = &quot;Model Delete Selection&quot;
&#9;selectionBox.Color = BrickColor.Red()
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = player.PlayerGui

&#9;selectionLasso = Instance.new(&quot;SelectionPartLasso&quot;)
&#9;selectionLasso.Name = &quot;Model Delete Lasso&quot;
&#9;selectionLasso.Humanoid = character.Humanoid
&#9;selectionLasso.archivable = false
&#9;selectionLasso.Visible = true
&#9;selectionLasso.Parent = game.workspace
&#9;selectionLasso.Color = BrickColor.Red()

&#9;highlight = true
end

function onUnequippedLocal()
&#9;highlight = false
&#9;if selectionBox then
&#9;&#9;clearSelection()
&#9;&#9;selectionBox:Remove()
&#9;end
&#9;if selectionLasso then selectionLasso:Remove() end
end


Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX138">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SwordScript</string>
					<ProtectedString name="Source">-------- OMG HAX

r = game:service(&quot;RunService&quot;)


local damage = 0


local slash_damage = 0


sword = script.Parent.Handle
Tool = script.Parent



function attack()
&#9;local anim = Instance.new(&quot;StringValue&quot;)
&#9;anim.Name = &quot;toolanim&quot;
&#9;anim.Value = &quot;Slash&quot;
&#9;anim.Parent = Tool
end


function swordUp()
&#9;Tool.GripForward = Vector3.new(-1,0,0)
&#9;Tool.GripRight = Vector3.new(0,1,0)
&#9;Tool.GripUp = Vector3.new(0,0,1)
end

function swordOut()
&#9;Tool.GripForward = Vector3.new(0,0,1)
&#9;Tool.GripRight = Vector3.new(0,-1,0)
&#9;Tool.GripUp = Vector3.new(-1,0,0)
end



Tool.Enabled = true

function onActivated()

&#9;if not Tool.Enabled then
&#9;&#9;return
&#9;end

&#9;Tool.Enabled = false

&#9;local character = Tool.Parent;
&#9;local humanoid = character.Humanoid
&#9;if humanoid == nil then
&#9;&#9;return 
&#9;end

&#9;

&#9;attack()

&#9;wait(1)

&#9;Tool.Enabled = true
end


script.Parent.Activated:connect(onActivated)

</ProtectedString>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX139">
				<Properties>
					<string name="Name">IsRestricted</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX140">
				<Properties>
					<string name="Name">AutoWedgeClusterParts</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX141">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>-0.699999988</Z>
					<R00>-0</R00>
					<R01>0</R01>
					<R02>1</R02>
					<R10>1</R10>
					<R11>-0</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>1</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<string name="Name">ConfigTool</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset/?id=59102714</url></Content>
				<string name="ToolTip">Configure Parts</string>
			</Properties>
			<Item class="Part" referent="RBX142">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>90.1875</X>
						<Y>217.574951</Y>
						<Z>174.5</Z>
						<R00>-0.0187646151</R00>
						<R01>0.00013109119</R01>
						<R02>-0.999823928</R02>
						<R10>0.000173843378</R10>
						<R11>1</R11>
						<R12>0.000127851599</R12>
						<R20>0.999823928</R20>
						<R21>-0.000171413689</R21>
						<R22>-0.0187646151</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>-0.0249766689</X>
						<Y>-0.00901040342</Y>
						<Z>-0.0119544808</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>-0.00526797445</X>
						<Y>-0.0188903194</Y>
						<Z>-0.00109783141</Z>
					</Vector3>
					<token name="formFactorRaw">2</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.800000012</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX143">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=16884681</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>0.600000024</X>
							<Y>0.600000024</Y>
							<Z>0.600000024</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=16884673</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX144">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ConfigurationLocal</string>
					<ProtectedString name="Source">-- general functions
function waitForProperty(instance, name)
&#9;while not instance[name] do
&#9;&#9;instance.Changed:wait()
&#9;end
end
function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local RbxGui
if LoadLibrary then
&#9;RbxGui = LoadLibrary(&quot;RbxGui&quot;)
else
&#9;return
end

local isRestricted = (game.PlaceId == 41324860 or game.PlaceId == 129686177)
local Tool = script.Parent

enabled = true
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=59785529&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=61423967&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=61427382&quot;)

local configIconImage = &quot;http://www.roblox.com/asset/?id=59785529&quot;
local configIconOverImage = &quot;http://www.roblox.com/asset/?id=61423967&quot;
local configIconHoverImage = &quot;http://www.roblox.com/asset/?id=61427382&quot;
local highlightedImage = nil

waitForChild(Tool, &quot;PlayerOwner&quot;)
local playerOwner = Tool.PlayerOwner

local STATIC_BASE_PLATE = nil

local ServiceConnections

local guiMain
local screen

local selectionGui

local player
local playerArea

local canTween = true
local gridRecalc
local lastPart

local lastConfig = nil
local lastVehicleSeat = nil
local origValueMap = {}

local valueConnections = {}

local objectValueSelect = {}

local adornmentTable = {}

local colorPaletteSelectMode = false

local needsIconReset = false

local textSize = 5

--Constants
local width = UDim.new(3, 0)
local height = 20 
local transparency = 0.5
local buttonColor = BrickColor.new(&quot;Mid gray&quot;)
local frameColor = BrickColor.new(&quot;Pastel yellow&quot;)


local function isInModel(part)
&#9;if part == game.Workspace then
&#9;&#9;return false, nil
&#9;elseif part:IsA(&quot;Model&quot;) then
&#9;&#9;return true, part
&#9;else
&#9;&#9;return isInModel(part.Parent)
&#9;end
end


function constrained(valueObject)
&#9;return (valueObject:IsA(&quot;IntConstrainedValue&quot;) or valueObject:IsA(&quot;DoubleConstrainedValue&quot;))
end

function sharedProcess(name, parentFrame)
&#9;local subFrame = Instance.new(&quot;Frame&quot;)
&#9;subFrame.Name = name
&#9;subFrame.Size = UDim2.new(1.0, 0, 0, height)
&#9;subFrame.BackgroundTransparency = 1.0
&#9;subFrame.BorderSizePixel = 0
&#9;
&#9;local label = Instance.new(&quot;TextLabel&quot;)
&#9;label.Font = Enum.Font.ArialBold
&#9;label.Position = UDim2.new(0.0, 0, 0.0, 0)
&#9;label.Size = UDim2.new(0.5, 0, 1.0, 0)
&#9;label.FontSize = textSize
&#9;label.TextColor = BrickColor.White()
&#9;label.Text = name
&#9;label.Parent = subFrame
&#9;label.BackgroundTransparency = 1.0
&#9;label.BorderSizePixel = 0

&#9;return subFrame
end

function createTextBox(size, text)
&#9;local textBox = Instance.new(&quot;TextBox&quot;)
&#9;textBox.Position = UDim2.new(0.5, 1, 0.0, 1)
&#9;textBox.Size = size
&#9;textBox.BackgroundTransparency = 1
&#9;textBox.FontSize = textSize - 3
&#9;textBox.TextColor3 = Color3.new(1,1,1)
&#9;textBox.Text = text&#9;
&#9;textBox.ZIndex = 2

&#9;local textBoxBacking = Instance.new(&quot;TextButton&quot;)
&#9;textBoxBacking.Text = &quot;&quot;
&#9;textBoxBacking.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;textBoxBacking.Size = UDim2.new(1,0,1,0)
&#9;textBoxBacking.Parent = textBox

&#9;return textBox
end

function setCheckBoxValue(checkBox, value)
&#9;if value then
&#9;&#9;checkBox.Text = &quot;X&quot;
&#9;else
&#9;&#9;checkBox.Text = &quot;&quot;
&#9;end
end
function createCheckBox(value)
&#9;local checkBox = Instance.new(&quot;TextButton&quot;)
&#9;checkBox.Position = UDim2.new(0.75, -(height-4)/2, 0.0, 2)
&#9;checkBox.Size = UDim2.new(0.0, height-4, 0.0, height-4)
&#9;checkBox.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;checkBox.TextColor3 = Color3.new(1,1,1)
&#9;checkBox.FontSize = textSize
&#9;setCheckBoxValue(checkBox, value)
&#9;return checkBox
end



function processBoolValue(value, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)
&#9;local checkBox = createCheckBox(value.Value)
&#9;
&#9;--Tie the two values together... we&apos;ll need to break these connections later
&#9;checkBox.MouseButton1Down:connect(function() value.Value = not(value.Value) end)
&#9;valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) setCheckBoxValue(checkBox, newValue) end)&#9;
&#9;checkBox.Parent = subFrame
&#9;return subFrame
end

function processConstrainedNumberValue(value, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)
&#9;local textBox = createTextBox(UDim2.new(0.5,-2, 1.0, -2), value.ConstrainedValue, function(textBox) value.ConstrainedValue = textBox.Text end)
&#9;textBox.Name = value.Name

&#9;--Tie the two values together... we&apos;ll need to break these connections later
&#9;textBox.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Text&quot; then
&#9;&#9;&#9;local prevValue = value.ConstrainedValue
&#9;&#9;&#9;if textBox.Text ~= &quot;&quot; then
&#9;&#9;&#9;&#9;pcall(function() value.ConstrainedValue = textBox.Text end)
&#9;&#9;&#9;end
&#9;&#9;&#9;textBox.Text = value.ConstrainedValue
&#9;&#9;end
&#9;end)
&#9;valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) textBox.Text = newValue end)
&#9;
&#9;textBox.Parent = subFrame
&#9;return subFrame;
end

function processIntValue(value, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)
&#9;local textBox = createTextBox(UDim2.new(0.5,-2, 1.0, -2), value.Value, function(textBox) value.Value = textBox.Text end)
&#9;textBox.Name = value.Name

&#9;--Tie the two values together... we&apos;ll need to break these connections later
&#9;textBox.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Text&quot; then
&#9;&#9;&#9;local prevValue = value.Value
&#9;&#9;&#9;if textBox.Text ~= &quot;&quot; then
&#9;&#9;&#9;&#9;pcall(function() value.Value = textBox.Text end)
&#9;&#9;&#9;end
&#9;&#9;&#9;textBox.Text = value.Value
&#9;&#9;end
&#9;end)
&#9;valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) textBox.Text = newValue end)
&#9;
&#9;textBox.Parent = subFrame
&#9;return subFrame;
end

function processPropertyValue(object, name, field, guiFrame)
&#9;origValueMap[name] = object[field]

&#9;local subFrame = sharedProcess(name, guiFrame)
&#9;local textBox = createTextBox(UDim2.new(0.5,-2, 1.0, -2), object[field], function(textBox) object[field] = textBox.Text end)
&#9;textBox.Name = name

&#9;--Tie the two values together... we&apos;ll need to break these connections later
&#9;textBox.Changed:connect(function(prop) 
&#9;&#9;if prop == &quot;Text&quot; then
&#9;&#9;&#9;if textBox.Text ~= &quot;&quot; then
&#9;&#9;&#9;&#9;local success = pcall(function() object[field] = textBox.Text end)
&#9;&#9;&#9;end
&#9;&#9;&#9;textBox.Text = object[field]
&#9;&#9;end
&#9;end)

&#9;valueConnections[#valueConnections+1] = object.Changed:connect(function(property) if property == field then textBox.Text = object[field] end end)
&#9;
&#9;textBox.Parent = subFrame
&#9;return subFrame
end


function processEnumValue(value, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)

&#9;local valueChildren = value:GetChildren()
&#9;local enumNames = {}
&#9;for i = 1, #valueChildren do
&#9;&#9;if valueChildren[i]:IsA(&quot;BoolValue&quot;) and valueChildren[i].Value == true then
&#9;&#9;&#9;table.insert(enumNames,valueChildren[i].Name)
&#9;&#9;end
&#9;end

&#9;local valueToChange = value
&#9;local enumSelect = function(item)
&#9;&#9;valueToChange.Value = tostring(item)
&#9;end

&#9;local dropDownEnumMenu, updateEnumSelection = RbxGui.CreateDropDownMenu(enumNames, enumSelect)
&#9;dropDownEnumMenu.Position = UDim2.new(0.5,0,0,0)
&#9;dropDownEnumMenu.Size = UDim2.new(0.5,0,0,20)
&#9;dropDownEnumMenu.Parent = subFrame

&#9;for i = 1, #valueChildren do
&#9;&#9;if value.Value == valueChildren[i].Name then
&#9;&#9;&#9;dropDownEnumMenu.DropDownMenuButton.Text = valueChildren[i].Name
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end

&#9;return subFrame
end



function processNumberValue(value, guiFrame)
&#9;return processIntValue(value, guiFrame)
end


function processStringValue(value, guiFrame)
&#9;return processIntValue(value, guiFrame)
end

function inBaseplate(instance)
&#9;if instance == STATIC_BASE_PLATE then return true end

&#9;local instanceCopy = instance

&#9;while instanceCopy and (instanceCopy.Parent ~= nil or instanceCopy.Parent ~= game.Workspace) do
&#9;&#9;if instanceCopy.Parent == STATIC_BASE_PLATE then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;instanceCopy = instanceCopy.Parent
&#9;end

&#9;return false
end

function onMouseLeave(hoverSelection, selectedButtonTable, oldButton)
&#9;if oldButton[0] then
&#9;&#9;local notSelected = true;
&#9;&#9;local selectionText = &quot;&quot;;
&#9;&#9;for key, value in pairs(selectedButtonTable) do
&#9;&#9;&#9;if oldButton[0] == value then
&#9;&#9;&#9;&#9;notSelected = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;selectionText = value.BackgroundColor.Name;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if notSelected then
&#9;&#9;&#9;hoverSelection.Text = selectionText;
&#9;&#9;&#9;oldButton[0].Parent.BackgroundColor = BrickColor.Black();
&#9;&#9;end
&#9;end
&#9;oldButton[0] = nil
end

function onMouseEnter(hoverSelection, guiButton, selectedButtonTable, oldButton)
&#9;onMouseLeave(hoverSelection, selectedButtonTable, oldButton)
&#9;hoverSelection.Text = guiButton.BackgroundColor.Name
&#9;if guiButton ~= selectedButton then
&#9;&#9;guiButton.Parent.BackgroundColor = BrickColor.White();
&#9;&#9;oldButton[0] = guiButton
&#9;end
end

function changeColorSelection(colorHolder, paletteFrame, guiButton, selectedButtonTable)
&#9;if selectedButtonTable[colorHolder] ~= nil then
&#9;&#9;selectedButtonTable[colorHolder].Parent.BackgroundColor = BrickColor.Black();
&#9;end

&#9;guiButton.Parent.BackgroundColor = BrickColor.Yellow();
&#9;colorHolder.BackgroundColor = guiButton.BackgroundColor
&#9;selectedButtonTable[colorHolder] = guiButton
end

function onMouseUp(colorHolder, paletteFrame, guiButton, selectedButtonTable)
&#9;changeColorSelection(colorHolder, paletteFrame, guiButton, selectedButtonTable)

&#9;onMouseLeavePalette(paletteFrame)
end

function onShowColorDialog(paletteFrame)
&#9;paletteFrame.Visible = not(paletteFrame.Visible)
&#9;colorPaletteSelectMode = true
end


function onMouseEnterPalette(mouse)
&#9;colorPaletteSelectMode = true
end
function onMouseLeavePalette(paletteFrame)
&#9;colorPaletteSelectMode = false
&#9;paletteFrame.Visible = false
end

function processBrickColorValue(value, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)

&#9;local sideBar = Instance.new(&quot;Frame&quot;)
&#9;sideBar.Position = UDim2.new(0.5, 0, 0.0, 0)
&#9;sideBar.Size = UDim2.new(0.5, 0, 1.0, 0)
&#9;sideBar.BackgroundTransparency = 1.0
&#9;sideBar.Parent = subFrame
&#9;sideBar.BorderSizePixel = 0

&#9;local primaryColor = Instance.new(&quot;TextButton&quot;)
&#9;primaryColor.Position = UDim2.new(0.0, 1, 0.0, 1)
&#9;primaryColor.Size = UDim2.new(0.0, height-2, 0, height-2)
&#9;primaryColor.Text  = &quot;&quot;&#9;
&#9;primaryColor.FontSize = textSize
&#9;primaryColor.BackgroundColor = value.Value
&#9;primaryColor.BorderColor = BrickColor.Black()
&#9;primaryColor.Parent = sideBar

&#9;local hoverSelection = Instance.new(&quot;TextLabel&quot;)
&#9;hoverSelection.Position = UDim2.new(0.0, height+2, 0.0, 0)
&#9;hoverSelection.Size = UDim2.new(1.0, -height - 4, 1.0, 0)
&#9;hoverSelection.Text = &quot;&quot;
&#9;hoverSelection.Font = Enum.Font.ArialBold
&#9;hoverSelection.FontSize = textSize
&#9;hoverSelection.BackgroundTransparency = 1.0
&#9;hoverSelection.BorderSizePixel = 0
&#9;hoverSelection.TextColor = BrickColor.White()
&#9;hoverSelection.Text = primaryColor.BackgroundColor.Name;
&#9;hoverSelection.Parent = sideBar

&#9;local paletteFrame = Instance.new(&quot;Frame&quot;)
&#9;paletteFrame.Position = UDim2.new(primaryColor.Position.X.Scale, primaryColor.Position.X.Offset + height, primaryColor.Position.Y.Scale, primaryColor.Position.Y.Offset - height*7)
&#9;paletteFrame.Size = UDim2.new(0, height*8, 0, height*8)
&#9;paletteFrame.BackgroundColor = BrickColor.White()
&#9;paletteFrame.BorderColor = BrickColor.White()
&#9;paletteFrame.Visible = false;
&#9;paletteFrame.Parent = sideBar
&#9;paletteFrame.ZIndex = 2
&#9;paletteFrame.MouseEnter:connect(function() onMouseEnterPalette(mouse) end)
&#9;paletteFrame.MouseLeave:connect(function() onMouseLeavePalette(paletteFrame, mouse) end)

&#9;primaryColor.MouseButton1Down:connect(function() onShowColorDialog(paletteFrame) end)

&#9;local selectedButtonTable = {}
&#9;local colorButtonTable = {}
&#9;local oldButton = {}
&#9;for xOffset = 0, 7 do
&#9;&#9;for yOffset = 0,7 do
&#9;&#9;&#9;local guiFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;guiFrame.Position = UDim2.new(1.0/8 * xOffset, 0, 1.0/8*yOffset, 0)
&#9;&#9;&#9;guiFrame.Size = UDim2.new(1.0/8, 0, 1.0/8, 0)
&#9;&#9;&#9;guiFrame.BackgroundColor = BrickColor.White();
&#9;&#9;&#9;guiFrame.BorderSizePixel = 0
&#9;&#9;&#9;guiFrame.Parent = paletteFrame;
&#9;&#9;&#9;guiFrame.ZIndex = 2
&#9;&#9;
&#9;&#9;&#9;local guiButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;guiButton.FontSize = textSize
&#9;&#9;&#9;guiButton.Position = UDim2.new(0.0, 1, 0.0, 1)
&#9;&#9;&#9;guiButton.Size = UDim2.new(1.0, -2, 1.0, -2)
&#9;&#9;&#9;guiButton.Text = &quot;&quot;
&#9;&#9;&#9;guiButton.BorderSizePixel = 0
&#9;&#9;&#9;guiButton.AutoButtonColor = false
&#9;&#9;&#9;local color = BrickColor.palette(xOffset + yOffset*8)
&#9;&#9;&#9;colorButtonTable[color.Number] = guiButton
&#9;&#9;&#9;guiButton.BackgroundColor = color
&#9;&#9;&#9;guiButton.MouseEnter:connect(function() onMouseEnter(hoverSelection, guiButton, selectedButtonTable, oldButton) end)
&#9;&#9;&#9;guiButton.MouseButton1Up:connect(function() onMouseUp(primaryColor, paletteFrame, guiButton, selectedButtonTable, oldButton) end)
&#9;&#9;&#9;guiButton.MouseButton1Up:connect(function() value.Value = guiButton.BackgroundColor end)
&#9;&#9;&#9;guiButton.Parent = guiFrame
&#9;&#9;&#9;guiButton.ZIndex = 2

&#9;&#9;&#9;if guiButton.BackgroundColor == primaryColor.BackgroundColor then
&#9;&#9;&#9;&#9;guiFrame.BackgroundColor = BrickColor.White()
&#9;&#9;&#9;&#9;selectedButtonTable[primaryColor] = guiButton
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) changeColorSelection(primaryColor, paletteFrame, colorButtonTable[newValue.Number], selectedButtonTable) end)&#9;
&#9;return subFrame
end


function onObjectValueMouseClick(guiFrame, value, objectButton)
&#9;objectValueSelect[&quot;Value&quot;] = value
&#9;objectValueSelect[&quot;Frame&quot;] = guiFrame
&#9;objectValueSelect[&quot;Enabled&quot;] = true

&#9;onObjectValueMouseLeave(value, objectButton)
end

function onObjectValueMouseEnter(value, objectButton)
&#9;objectValueSelect[&quot;HoverValue&quot;] = value
&#9;if value.Value then
&#9;&#9;objectButton.BackgroundColor = BrickColor.Blue()
&#9;else
&#9;&#9;objectButton.BackgroundColor = BrickColor.White()
&#9;end
end
&#9;
function onObjectValueMouseLeave(value, objectButton)
&#9;if objectValueSelect[&quot;HoverValue&quot;] == value then
&#9;&#9;objectValueSelect[&quot;HoverValue&quot;] = nil
&#9;end
&#9;objectButton.BackgroundColor = buttonColor
end

function onObjectValueCancel()
&#9;if objectValueSelect[&quot;Enabled&quot;] then
&#9;&#9;objectValueSelect[&quot;Enabled&quot;] = false

&#9;&#9;objectValueSelect[&quot;Frame&quot;].Visible = true
&#9;&#9;objectValueSelect[&quot;Frame&quot;] = nil
&#9;&#9;objectValueSelect[&quot;Value&quot;] = nil
&#9;end
end

function on3dObjectValueButton1Up(mouse, guiMain)
&#9;local part = mouse.Target
&#9;if part ~= nil then
&#9;&#9;objectValueSelect[&quot;Value&quot;].Value = part

&#9;&#9;objectValueSelect[&quot;Enabled&quot;] = false

&#9;&#9;objectValueSelect[&quot;Frame&quot;].Visible = true

&#9;&#9;objectValueSelect[&quot;Frame&quot;] = nil
&#9;&#9;objectValueSelect[&quot;Value&quot;] = nil
&#9;end
end

function on3dObjectValueMouseMove(mouse, guiMain)
end

function setObjectButtonText(guiFrame, objectButton, objectValue)
&#9;if objectValueSelect[&quot;Enabled&quot;] and objectValue == objectValueSelect[&quot;Value&quot;] then
&#9;&#9;guiFrame.Visible = true
&#9;&#9;objectValueSelect[&quot;Enabled&quot;] = false
&#9;&#9;objectValueSelect[&quot;Value&quot;] = nil
&#9;end

&#9;if  objectValue.Value ~= nil then
&#9;&#9;objectButton.Text = objectValue.Value.Name
&#9;else
&#9;&#9;objectButton.Text = &quot;[nil]&quot;
&#9;end
&#9;objectButton.BackgroundColor = buttonColor
end

function processObjectValue(value, playerGui, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)
&#9;local objectButton = Instance.new(&quot;TextButton&quot;)
&#9;objectButton.FontSize = textSize
&#9;objectButton.Position = UDim2.new(0.5, 2, 0.0, 2)
&#9;objectButton.Size = UDim2.new(0.5, -4, 1.0, -4)
&#9;objectButton.BackgroundColor = BrickColor.White()
&#9;objectButton.TextColor = BrickColor.Black()
&#9;objectButton.Parent = subFrame
&#9;objectButton.AutoButtonColor = false

&#9;objectButton.MouseButton1Click:connect(function() onObjectValueMouseClick(guiFrame, value, objectButton) end)
&#9;objectButton.MouseEnter:connect(function() onObjectValueMouseEnter(value, objectButton) end)
&#9;objectButton.MouseLeave:connect(function() onObjectValueMouseLeave(value, objectButton) end)

&#9;valueConnections[#valueConnections+1] = value.Changed:connect(function(newObjectValue) setObjectButtonText(guiFrame, objectButton, value) end)&#9;

&#9;setObjectButtonText(guiFrame, objectButton, value)
&#9;return subFrame
end


function processValue(value, playerGui, guiFrame)
&#9;if constrained(value) then origValueMap[value.Name] = value.ConstrainedValue
&#9;else origValueMap[value.Name] = value.Value end

&#9;if #value:GetChildren() &gt; 0 and value:IsA(&quot;StringValue&quot;) then
&#9;&#9;return processEnumValue(value, guiFrame)
&#9;else
&#9;&#9;if value.className == &quot;BoolValue&quot; then
&#9;&#9;&#9;return processBoolValue(value, guiFrame)
&#9;&#9;elseif value.className == &quot;IntValue&quot; then
&#9;&#9;&#9;return processIntValue(value, guiFrame)
&#9;&#9;elseif value.className == &quot;NumberValue&quot; then
&#9;&#9;&#9;return processNumberValue(value, guiFrame)
&#9;&#9;elseif value.className == &quot;StringValue&quot; then
&#9;&#9;&#9;return processStringValue(value, guiFrame)
&#9;&#9;elseif value.className == &quot;ObjectValue&quot; then
&#9;&#9;&#9;return processObjectValue(value, playerGui, guiFrame)
&#9;&#9;elseif value.className == &quot;BrickColorValue&quot; then
&#9;&#9;&#9;return processBrickColorValue(value, guiFrame)
&#9;&#9;elseif value.className == &quot;IntConstrainedValue&quot; or value.className == &quot;DoubleConstrainedValue&quot; then
&#9;&#9;&#9;return processConstrainedNumberValue(value, guiFrame)
&#9;&#9;else
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;end
end

function killFrame(frame)
&#9;screen.Enabled = false
&#9;frame:remove()
end

function closeFrame(frame)
&#9;lastPart = nil
&#9;if frame.Parent == nil then return end
&#9;frame:TweenSizeAndPosition(UDim2.new(0,0,0,0),UDim2.new(0.5,0,0.5,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,0.5, true, function() killFrame(frame) end)
end

function allowTween()
&#9;canTween = true
end

function openFrame(frame,size)
&#9;if not canTween then return end
&#9;canTween = false
&#9;screen.Enabled = true
&#9;frame.Size = UDim2.new(0,0,0,0)
&#9;frame.Position = UDim2.new(0.5,0,0.5,0)
&#9;frame:TweenSizeAndPosition(size,UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,0.5,true, function() allowTween() end)
end

function sharedMain(name, playerGui)
&#9;local parentFrame = Instance.new(&quot;Frame&quot;)
&#9;parentFrame.Style = Enum.FrameStyle.RobloxRound
&#9;parentFrame.Active = true
&#9;parentFrame.Name = &quot;MainFrame&quot;
&#9;parentFrame.Size = UDim2.new(1, 0, 1, 0)
&#9;parentFrame.BackgroundTransparency = 1

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;TitleLabel&quot;
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = textSize + 2
&#9;titleLabel.Size = UDim2.new(1.0, 0.0, 0.0, height)
&#9;titleLabel.TextColor = BrickColor.White()
&#9;titleLabel.BackgroundColor = BrickColor.new(&quot;Cool yellow&quot;)
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.Text = name
&#9;titleLabel.Parent = parentFrame

&#9;local closeButton = Instance.new(&quot;TextButton&quot;)
&#9;closeButton.Name = &quot;CloseButton&quot;
&#9;closeButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;closeButton.Size = UDim2.new(0,20,0,20)
&#9;closeButton.Position = UDim2.new(1,-16,0,-5)
&#9;closeButton.Text = &quot;X&quot;
&#9;closeButton.TextColor3 = Color3.new(1,1,1)
&#9;closeButton.Font = Enum.Font.ArialBold
&#9;closeButton.FontSize = Enum.FontSize.Size18
&#9;closeButton.Parent = parentFrame

&#9;local closeCon = nil
&#9;closeCon = closeButton.MouseButton1Click:connect(function()
&#9;&#9;closeCon:disconnect()
&#9;&#9;removeBillboards()
&#9;&#9;screen.Enabled = false
&#9;&#9;cancelSelectionGui()
&#9;end)

&#9;local scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction = RbxGui.CreateScrollingFrame()
&#9;gridRecalc = recalculateFunction
&#9;scrollFrame.Name = &quot;ValueContainer&quot;
&#9;scrollFrame.Size = UDim2.new(1,-17,1,-50)
&#9;scrollFrame.Position = UDim2.new(0,0,0,25)
&#9;scrollFrame.Parent = parentFrame

&#9;local changerCon = nil
&#9;delay(1,function()
&#9;&#9;if scrollFrame and scrollFrame.Parent then
&#9;&#9;&#9;changerCon = scrollFrame.Changed:connect(function(prop)
&#9;&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;if scrollFrame.AbsoluteSize.Y &lt; 38 then
&#9;&#9;&#9;&#9;&#9;&#9;changerCon:disconnect()
&#9;&#9;&#9;&#9;&#9;&#9;closeFrame(parentFrame)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;gridRecalc()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end)

&#9;local dieCon
&#9;dieCon = scrollFrame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;dieCon:disconnect()
&#9;&#9;&#9;if changerCon then changerCon:disconnect() end
&#9;&#9;end
&#9;end)

&#9;local scrollButtonFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollButtonFrame.Name = &quot;ScrollButtonFrame&quot;
&#9;scrollButtonFrame.Position = UDim2.new(1,-17,0,25)
&#9;scrollButtonFrame.Size = UDim2.new(0,17,1,-50)
&#9;scrollButtonFrame.BackgroundTransparency = 1
&#9;scrollButtonFrame.Parent = parentFrame

&#9;scrollUpButton.Parent = scrollButtonFrame
&#9;scrollDownButton.Parent = scrollButtonFrame
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-17)
&#9;

&#9;return parentFrame
end

function sharedButtons(parentFrame, valueChildren)
&#9;local buttonFrame = Instance.new(&quot;Frame&quot;)
&#9;buttonFrame.Name = &quot;Buttons&quot;
&#9;buttonFrame.BackgroundTransparency = 1.0
&#9;buttonFrame.Size = UDim2.new(1.0, 0.0, 0.0, height)
&#9;buttonFrame.Position = UDim2.new(0.0, 0, 1, -25)
&#9;buttonFrame.Parent = parentFrame
&#9;valueChildren = valueChildren + 1

&#9;local okButton = Instance.new(&quot;TextButton&quot;)
&#9;okButton.FontSize = textSize
&#9;okButton.Name = &quot;OkButton&quot;
&#9;okButton.Font = Enum.Font.ArialBold
&#9;okButton.TextColor = BrickColor.White()
&#9;okButton.Style = Enum.ButtonStyle.RobloxButton
&#9;okButton.Text = &quot;Ok&quot;
&#9;okButton.Size = UDim2.new(.25, -4, 0.0, height + 5)
&#9;okButton.Position = UDim2.new(0.55, 2, 0.0, 2)
&#9;okButton.BackgroundColor = buttonColor
&#9;okButton.MouseButton1Click:connect(function() removeSelectionGui() end)
&#9;okButton.Parent = buttonFrame

&#9;local cancelButton = okButton:clone()
&#9;cancelButton.Name = &quot;cancelButton&quot;
&#9;cancelButton.Text  = &quot;Cancel&quot;
&#9;cancelButton.Position = UDim2.new(0.200000003, 2, 0, 2)
&#9;cancelButton.MouseButton1Click:connect(function() cancelSelectionGui() end)
&#9;cancelButton.Parent = buttonFrame
end

function processVehicleSeat(vehicleSeat, playerGui, valueChildren)
&#9;local parentFrame = sharedMain(vehicleSeat.Name, playerGui)
&#9;lastVehicleSeat = vehicleSeat

&#9;local valueChildren = 1
&#9;local fields = {&quot;MaxSpeed&quot;, &quot;Steer&quot;, &quot;Torque&quot;, &quot;TurnSpeed&quot;}
&#9;for pos, field in pairs(fields) do
&#9;&#9;local newFrame = processPropertyValue(vehicleSeat, field, field, guiFrame)
&#9;&#9;if newFrame then
&#9;&#9;&#9;newFrame.Position = UDim2.new(0.0, 0, 0.0, (valueChildren*height) - height)
&#9;&#9;&#9;newFrame.Parent = parentFrame.ValueContainer
&#9;&#9;&#9;valueChildren = valueChildren + 1
&#9;&#9;end

&#9;end

&#9;sharedButtons(parentFrame, valueChildren)
&#9;return parentFrame
end

function processConfiguration(config, playerGui)
&#9;local parentFrame = sharedMain(config.Name, playerGui)
&#9;lastConfig = config

&#9;local valueChildren = 1
&#9;local children = config:GetChildren() 
&#9;if children then
&#9;&#9;for pos, child in pairs(children) do
&#9;&#9;&#9;local newFrame = processValue(child, playerGui, parentFrame)
&#9;&#9;&#9;if newFrame then
&#9;&#9;&#9;&#9;newFrame.Position = UDim2.new(0.0, 0, 0.0, (valueChildren*height) - height)
&#9;&#9;&#9;&#9;newFrame.Parent = parentFrame.ValueContainer
&#9;&#9;&#9;&#9;valueChildren = valueChildren + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;sharedButtons(parentFrame, valueChildren)
&#9;return parentFrame
end

function on3dMouseMove(mouse, guiMain)
&#9;if mouse.Target and canSelectObject(mouse.Target) then

&#9;&#9;local part = mouse.Target
&#9;&#9;if part:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;foundPart = part
&#9;&#9;else
&#9;&#9;&#9;foundPart = findConfiguration(part)
&#9;&#9;end

&#9;&#9;if foundPart then
&#9;&#9;&#9;if objectValueSelect[&quot;HoverBox&quot;] then 
&#9;&#9;&#9;&#9;local isModel, model = isInModel(part)
&#9;&#9;&#9;&#9;local adornee = part
&#9;&#9;&#9;&#9;if isModel then
&#9;&#9;&#9;&#9;&#9;adornee = model
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;objectValueSelect[&quot;HoverBox&quot;].Adornee = adornee
&#9;&#9;&#9;&#9;local billboard = getBillboard(adornee)

&#9;&#9;&#9;&#9;local configBadge = billboard:FindFirstChild(&quot;ConfigBadge&quot;,true)
&#9;&#9;&#9;&#9;if configBadge then
&#9;&#9;&#9;&#9;&#9;configBadge.Image = configIconOverImage
&#9;&#9;&#9;&#9;&#9;highlightedImage = configBadge
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;needsIconReset = true
&#9;&#9;else
&#9;&#9;&#9;if needsIconReset then
&#9;&#9;&#9;&#9;if objectValueSelect[&quot;HoverBox&quot;] then objectValueSelect[&quot;HoverBox&quot;].Adornee = nil end
&#9;&#9;&#9;&#9;needsIconReset = false

&#9;&#9;&#9;&#9;if highlightedImage then 
&#9;&#9;&#9;&#9;&#9;highlightedImage.Image = configIconImage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;if needsIconReset then
&#9;&#9;&#9;if objectValueSelect[&quot;HoverBox&quot;] then objectValueSelect[&quot;HoverBox&quot;].Adornee = nil end
&#9;&#9;&#9;needsIconReset = false

&#9;&#9;&#9;if highlightedImage then 
&#9;&#9;&#9;&#9;highlightedImage.Image = configIconImage
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;if objectValueSelect[&quot;Enabled&quot;] then
&#9;&#9;on3dObjectValueMouseMove(mouse, guiMain)
&#9;end
end

function cancelSelectionGui()
&#9;lastPart = nil

&#9;if selectionGui ~= nil then
&#9;&#9;closeFrame(selectionGui)
&#9;&#9;selectionGui = nil
&#9;&#9;for pos, connection in pairs(valueConnections) do
&#9;&#9;&#9;connection:disconnect()
&#9;&#9;end
&#9;&#9;valueConnections = {}
&#9;end

&#9;showConfigurationAnnotations()

&#9;if lastConfig then
&#9;&#9;local configValues = lastConfig:GetChildren()
&#9;&#9;for i = 1, #configValues do
&#9;&#9;&#9;if origValueMap[configValues[i].Name] ~= nil then
&#9;&#9;&#9;&#9;if constrained(configValues[i]) then configValues[i].ConstrainedValue = origValueMap[configValues[i].Name]
&#9;&#9;&#9;&#9;else configValues[i].Value = origValueMap[configValues[i].Name] end

&#9;&#9;&#9;&#9;origValueMap[configValues[i].Name] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;elseif lastVehicleSeat then
&#9;&#9;lastVehicleSeat.MaxSpeed = origValueMap[&quot;MaxSpeed&quot;]
&#9;&#9;origValueMap[&quot;MaxSpeed&quot;] = nil
&#9;&#9;lastVehicleSeat.Steer = origValueMap[&quot;Steer&quot;]
&#9;&#9;origValueMap[&quot;Steer&quot;] = nil
&#9;&#9;lastVehicleSeat.Torque = origValueMap[&quot;Torque&quot;]
&#9;&#9;origValueMap[&quot;Torque&quot;] = nil
&#9;&#9;lastVehicleSeat.TurnSpeed = origValueMap[&quot;TurnSpeed&quot;]
&#9;&#9;origValueMap[&quot;TurnSpeed&quot;] = nil
&#9;end
end

function removeSelectionGui()
&#9;if selectionGui ~= nil then
&#9;&#9;closeFrame(selectionGui)
&#9;&#9;for pos, connection in pairs(valueConnections) do
&#9;&#9;&#9;connection:disconnect()
&#9;&#9;end
&#9;&#9;valueConnections = {}
&#9;end

&#9;if objectValueSelect[&quot;HoverBox&quot;] then objectValueSelect[&quot;HoverBox&quot;].Adornee = nil end

&#9;showConfigurationAnnotations()

&#9;if lastConfig then
&#9;&#9;local configValues = lastConfig:GetChildren()
&#9;&#9;for i = 1, #configValues do
&#9;&#9;&#9;if origValueMap[configValues[i].Name] ~= nil then
&#9;&#9;&#9;&#9;origValueMap[configValues[i].Name] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function canSelectObject(part)
&#9;if isRestricted then
&#9;&#9;waitForChild(playerArea,&quot;PlayerArea&quot;)
&#9;&#9;if isRestricted and playerArea:FindFirstChild(&quot;PlayerArea&quot;) and part:IsDescendantOf(playerArea.PlayerArea) then
&#9;&#9;&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end

&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

local function findConfigInModel(model)
&#9;local children = model:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;if children[i]:IsA(&quot;Configuration&quot;) or children[i]:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;return children[i]
&#9;&#9;end
&#9;end
&#9;for i = 1, #children do
&#9;&#9;if #children[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;local returnValue = findConfigInModel(children[i])
&#9;&#9;&#9;if returnValue ~= nil then
&#9;&#9;&#9;&#9;return returnValue
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return nil
end

function findConfiguration(part)
&#9;local partInModel, model = isInModel(part)
&#9;if partInModel then
&#9;&#9;local isModelConfig = findConfigInModel(model)
&#9;&#9;return isModelConfig
&#9;else
&#9;&#9;local children = part:GetChildren() &#9;&#9;
&#9;&#9;if children then
&#9;&#9;&#9;for pos, child in pairs(children) do
&#9;&#9;&#9;&#9;if child:IsA(&quot;Configuration&quot;) or child:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;&#9;&#9;return child
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return nil
end

function removeBillboards()
&#9;local guis = guiMain:GetChildren()
&#9;for i = 1, #guis do
&#9;&#9;if guis[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;guis[i]:remove()
&#9;&#9;end
&#9;end
end

function on3dButton1Up(mouse, guiMain, playerGui)
&#9;if objectValueSelect[&quot;Enabled&quot;] then
&#9;&#9;on3dObjectValueButton1Up(mouse, guiMain)
&#9;&#9;return
&#9;elseif canSelectObject(mouse.Target) then
&#9;&#9;local part = mouse.Target
&#9;&#9;local foundPart = nil
&#9;&#9;if part:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;foundPart = part
&#9;&#9;else
&#9;&#9;&#9;foundPart = findConfiguration(part)
&#9;&#9;end
&#9;
&#9;&#9;if foundPart then
&#9;&#9;&#9;
&#9;&#9;&#9;if foundPart == lastPart then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;&#9;lastPart = foundPart

&#9;&#9;&#9;removeBillboards()
&#9;&#9;&#9;screen.Enabled = true

&#9;&#9;&#9;if foundPart:IsA(&quot;Configuration&quot;) then
&#9;&#9;&#9;&#9;selectionGui = processConfiguration(foundPart, playerGui)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;selectionGui = processVehicleSeat(foundPart, playerGui)&#9;
&#9;&#9;&#9;end
&#9;&#9;&#9;selectionGui.Parent = guiMain
&#9;&#9;&#9;openFrame(selectionGui, selectionGui.Size)

&#9;&#9;&#9;local hasModel, model = isInModel(part)
&#9;&#9;&#9;if hasModel then
&#9;&#9;&#9;&#9;screen.Adornee = model
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;screen.Adornee = part
&#9;&#9;&#9;end

&#9;&#9;&#9;if highlightedImage then 
&#9;&#9;&#9;&#9;highlightedImage.Image = configIconImage
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;cancelSelectionGui()
&#9;end
end

function onEquippedLocal(mouse)
&#9;local character = script.Parent.Parent
&#9;player = game.Players:GetPlayerFromCharacter(character)

&#9;if player == nil then return end
&#9;if playerOwner.Value and playerOwner.Value ~= player then return end
&#9;playerOwner.Value = player

&#9;if isRestricted then
&#9;&#9;waitForChild(game.Workspace,&quot;BuildingAreas&quot;)
&#9;&#9;waitForChild(game.Workspace.BuildingAreas,&quot;Area1&quot;)
&#9;&#9;waitForChild(game.Workspace.BuildingAreas.Area1,&quot;Player&quot;)
&#9;&#9;local areas = game.Workspace.BuildingAreas:GetChildren()
&#9;&#9;for i = 1, #areas do
&#9;&#9;&#9;if areas[i]:FindFirstChild(&quot;Player&quot;) and areas[i].Player.Value == player.Name then
&#9;&#9;&#9;&#9;playerArea = areas[i]
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;waitForChild(playerArea,&quot;PlayerArea&quot;)
&#9;&#9;STATIC_BASE_PLATE = playerArea.PlayerArea
&#9;end

&#9;if not screen then
&#9;&#9;screen = Instance.new(&quot;BillboardGui&quot;)
&#9;&#9;screen.Name = &quot;ConfigGui&quot;
&#9;&#9;screen.Size = UDim2.new(0,360,0,180)
&#9;&#9;screen.Enabled = false
&#9;&#9;screen.Active = true
&#9;&#9;screen.Parent = player.PlayerGui
&#9;&#9;screen.AlwaysOnTop = true

&#9;&#9;guiMain = Instance.new(&quot;Frame&quot;)
&#9;&#9;guiMain.BackgroundTransparency = 1
&#9;&#9;guiMain.Size = UDim2.new(1,0,1,0)
&#9;&#9;guiMain.Parent = screen
&#9;else
&#9;&#9;removeBillboards()
&#9;&#9;lastPart = nil
&#9;&#9;screen.Parent = player.PlayerGui
&#9;end

&#9;setUpConfigurationService(guiMain)
&#9;showConfigurationAnnotations()

&#9;mouse.Icon = &quot;http://www.roblox.com/asset?id=66887593&quot;
&#9;mouse.Button1Up:connect(function() on3dButton1Up(mouse, guiMain, player.PlayerGui) end)
&#9;mouse.Move:connect(function() on3dMouseMove(mouse, guiMain) end)

&#9;objectValueSelect.HoverBox = Instance.new(&quot;SelectionBox&quot;)
&#9;objectValueSelect.HoverBox.Name = &quot;HoverBox&quot;
&#9;objectValueSelect.HoverBox.Color = BrickColor.new(&quot;Really blue&quot;)
&#9;objectValueSelect.HoverBox.Transparency = 0.5
&#9;objectValueSelect.HoverBox.Adornee = nil
&#9;objectValueSelect.HoverBox.Parent = player.PlayerGui;
end

function onUnequippedLocal()

&#9;local guiChildren = game.Players.LocalPlayer.PlayerGui:GetChildren()
&#9;for i = 1, #guiChildren do
&#9;&#9;if guiChildren[i]:IsA(&quot;BillboardGui&quot;) then
&#9;&#9;&#9;guiChildren[i].Parent = nil
&#9;&#9;end
&#9;end

&#9;destroyConfigurationService()

&#9;objectValueSelect.HoverBox:Remove()

&#9;if screen then
&#9;&#9;screen.Parent = nil
&#9;end

&#9;player = nil

&#9;hideConfigurationAnnotations()

&#9;objectValueSelect = {}
end


local configTable = {}

function createVisualAnnotation(config, guiMain)
&#9;local selection = Instance.new(&quot;SelectionBox&quot;)
&#9;selection.Name = &quot;Annotation&quot;
&#9;selection.Color = BrickColor.new(&quot;Really blue&quot;)
&#9;selection.Transparency = 0.5
&#9;selection.Parent = guiMain.Parent
&#9;return selection
end

function configurationParentChanged(data, part)
&#9;local isModel, model = isInModel(part)
&#9;if not isModel then
&#9;&#9;data[&quot;VisualAnnotation&quot;].Adornee = part
&#9;else
&#9;&#9;data[&quot;VisualAnnotation&quot;].Adornee = model
&#9;end
end

function showConfigurationAnnotations()
&#9;for config, data in pairs(configTable) do
&#9;&#9;data[&quot;VisualAnnotation&quot;].Visible = true
&#9;end
end


function hideConfigurationAnnotations()
&#9;for config, data in pairs(configTable) do
&#9;&#9;data[&quot;VisualAnnotation&quot;].Visible = false
&#9;end
end

local function isInMyArea(part)
&#9;if part.Parent == nil then return false end
&#9;if part.Parent:FindFirstChild(&quot;Player&quot;) and part.Parent.Player:IsA(&quot;StringValue&quot;) then
&#9;&#9;if part.Parent.Player.Value == player.Name then
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;elseif part.Parent == game.Workspace.BuildingAreas or part.Parent == game.Workspace then
&#9;&#9;return false
&#9;else
&#9;&#9;return isInMyArea(part.Parent)
&#9;end
end

function findBillboard(guiTable)
&#9;if not guiTable then return end

&#9;for i = 1, #guiTable do
&#9;&#9;if guiTable[i] and guiTable[i]:IsA(&quot;BillboardGui&quot;) then
&#9;&#9;&#9;return guiTable[i]
&#9;&#9;end
&#9;end
end

function getBillboard(adornee)
&#9;local guiKey = adornee
&#9;
&#9;local billboard = findBillboard(adornmentTable[guiKey])
&#9;if not billboard then
&#9;&#9;local screen = Instance.new(&quot;BillboardGui&quot;)
&#9;&#9;screen.Name = adornee.Name .. &quot;BadgeGUI&quot;
&#9;&#9;screen.Size = UDim2.new(1.5,0,1.5,0)
&#9;&#9;screen.Enabled = true
&#9;&#9;screen.Active = true
&#9;&#9;screen.AlwaysOnTop = true
&#9;&#9;screen.ExtentsOffset = Vector3.new(0,0,0)
&#9;&#9;screen.Adornee = adornee
&#9;&#9;screen.Parent = game.Players.LocalPlayer.PlayerGui

&#9;&#9;if not adornmentTable[guiKey] then 
&#9;&#9;&#9;adornmentTable[guiKey] = {}
&#9;&#9;end
&#9;&#9;table.insert(adornmentTable[guiKey],screen)

&#9;&#9;return screen
&#9;end

&#9;return billboard
end

function hasBadge(adornee)
&#9;local screen = getBillboard(adornee)
&#9;if not screen then return false end
&#9;return screen:FindFirstChild(&quot;Badge&quot;,true)
end

function removeBadge(adornee)
&#9;local screen = getBillboard(adornee)
&#9;local badge = screen:FindFirstChild(&quot;ConfigBadge&quot;,true)
&#9;if badge then badge:remove() end
end

function giveConfigBadge(adornee)
&#9;local billboard = getBillboard(adornee)

&#9;local configBadge = Instance.new(&quot;ImageLabel&quot;)
&#9;configBadge.Name = &quot;ConfigBadge&quot;
&#9;configBadge.BackgroundTransparency = 1
&#9;configBadge.Image = configIconImage
&#9;configBadge.Size = UDim2.new(1,0,1,0)
&#9;configBadge.Parent = billboard

&#9;billboard.Parent =  game.Players.LocalPlayer.PlayerGui

&#9;local badgeCon = configBadge.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;configBadge.Visible = (configBadge.AbsoluteSize.X &gt; 10)
&#9;&#9;end
&#9;end)

&#9;local enterCon = configBadge.MouseEnter:connect(function()
&#9;&#9;configBadge.Image = configIconHoverImage
&#9;end)

&#9;local leaveCon = configBadge.MouseLeave:connect(function()
&#9;&#9;configBadge.Image = configIconImage
&#9;end)

&#9;local killCon = nil
&#9;killCon = configBadge.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;killCon:disconnect()
&#9;&#9;&#9;badgeCon:disconnect()
&#9;&#9;&#9;enterCon:disconnect()
&#9;&#9;&#9;leaveCon:disconnect()
&#9;&#9;end
&#9;end)
end

function configurationAdded(config, guiMain)
&#9;if configTable[config] then
&#9;&#9;return
&#9;end

&#9;if isRestricted and not inBaseplate(config) then return end
&#9;
&#9;local data = {}
&#9;data.Configuration = config
&#9;data.VisualAnnotation = createVisualAnnotation(config, guiMain)
&#9;if config:IsA(&quot;Configuration&quot;) then
&#9;&#9;data.Connection = config.AncestryChanged:connect(function(child, newParent)
&#9;&#9;&#9;if child == config then
&#9;&#9;&#9;&#9;configurationParentChanged(data, newParent)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;configurationParentChanged(data, config.Parent)
&#9;else
&#9;&#9;configurationParentChanged(data, config)
&#9;end

&#9;local partInModel, model = isInModel(config.Parent)
&#9;if partInModel then
&#9;&#9;if not hasBadge(model) then
&#9;&#9;&#9;giveConfigBadge(model)
&#9;&#9;end
&#9;else
&#9;&#9;if not hasBadge(config.Parent) then
&#9;&#9;&#9;giveConfigBadge(config.Parent)
&#9;&#9;end
&#9;end

&#9;configTable[config] = data
end

function configurationRemoved(config)

&#9;local data = configTable[config]&#9;
&#9;if not(data) then
&#9;&#9;--I have no opinion about this
&#9;&#9;return
&#9;end

&#9;if data.Connection then
&#9;&#9;data.Connection:disconnect()
&#9;end

&#9;data.VisualAnnotation:Remove()
&#9;removeBadge(config.Parent)
&#9;
&#9;configTable[config] = nil
end

function findVehicleSeats(object, guiMain)
&#9;if object:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;configurationAdded(object, guiMain)
&#9;end
&#9;for index,child in pairs(object:GetChildren()) do
&#9;&#9;findVehicleSeats(child, guiMain)
&#9;end
end

function setUpConfigurationService(guiMain)
&#9;ServiceConnections = {}
&#9;local collectionService = game:GetService(&quot;CollectionService&quot;)

&#9;ServiceConnections[#ServiceConnections+1] = collectionService.ItemAdded:connect(function(instance) if instance:IsA(&quot;Configuration&quot;) then configurationAdded(instance, guiMain) end end)
&#9;ServiceConnections[#ServiceConnections+1] = collectionService.ItemRemoved:connect(function(instance) if instance:IsA(&quot;Configuration&quot;) then configurationRemoved(instance) end end)

&#9;local configs = collectionService:GetCollection(&quot;Configuration&quot;)
&#9;if configs then
&#9;&#9;for pos, config in pairs(configs) do
&#9;&#9;&#9;configurationAdded(config, guiMain)
&#9;&#9;end
&#9;end

&#9;ServiceConnections[#ServiceConnections+1] = game.workspace.DescendantAdded:connect(function(instance) if instance:IsA(&quot;VehicleSeat&quot;) then configurationAdded(instance, guiMain) end end)
&#9;ServiceConnections[#ServiceConnections+1] = game.workspace.DescendantRemoving:connect(function(instance) if instance:IsA(&quot;VehicleSeat&quot;) then configurationRemoved(instance) end end)
&#9;findVehicleSeats(game.workspace, guiMain)

end

function destroyConfigurationService()
&#9;for config, data in pairs(configTable) do
&#9;&#9;configurationRemoved(config)
&#9;end
&#9;for index, connection in pairs(ServiceConnections) do
&#9;&#9;connection:disconnect()
&#9;end
&#9;ServiceConnections = {}
end


Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)</ProtectedString>
				</Properties>
			</Item>
			<Item class="ObjectValue" referent="RBX145">
				<Properties>
					<string name="Name">PlayerOwner</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX146">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">ClassicTool</string>
				<Content name="TextureId"><url>http://www.roblox.com/asset/?id=59105322</url></Content>
				<string name="ToolTip"></string>
			</Properties>
			<Item class="LocalScript" referent="RBX147">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ClassicToolController</string>
					<ProtectedString name="Source">local Tool = script.Parent

local keyUpCon = nil
local gui = nil

local connections = {}
local buttons = {}

local colorButton,SurfaceButton,MaterialButton,ResizeButton,draggerButton = nil

game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset?id=59103051&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset?id=59103080&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset?id=59103092&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset?id=59103119&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset?id=59103152&quot;)

function makeImageButton(buttonName, image, position, parent, hotKeyString)
&#9;local button = Instance.new(&quot;ImageButton&quot;)
&#9;button.Name = buttonName
&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;button.Size = UDim2.new(0,45,0,45)
&#9;if position then button.Position = position end
&#9;button.Parent = parent

&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;buttonImage.BackgroundTransparency = 1
&#9;buttonImage.Size = UDim2.new(1,12,1,12)
&#9;buttonImage.Position = UDim2.new(0,-6,0,-6)
&#9;buttonImage.Image = image
&#9;buttonImage.Parent = button

&#9;if hotKeyString then
&#9;&#9;local textShortcut = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;textShortcut.Text = hotKeyString
&#9;&#9;textShortcut.Name = &quot;TextShortcut&quot;
&#9;&#9;textShortcut.Font = Enum.Font.ArialBold
&#9;&#9;textShortcut.BackgroundTransparency = 1
&#9;&#9;textShortcut.FontSize = Enum.FontSize.Size14
&#9;&#9;textShortcut.TextColor3 = Color3.new(1,1,1)
&#9;&#9;textShortcut.Size = UDim2.new(0,textShortcut.TextBounds.X,0,textShortcut.TextBounds.X)
&#9;&#9;textShortcut.Parent = button
&#9;end

&#9;return button
end

function deactivateTool(script)
&#9;local enable = script:FindFirstChild(&quot;Active&quot;)
&#9;if enable and enable:IsA(&quot;BoolValue&quot;) then
&#9;&#9;enable.Value = false
&#9;end
end

function deactivateAllTools()
&#9;local toolChildren = Tool:GetChildren()
&#9;for i = 1, #toolChildren do
&#9;&#9;if toolChildren[i]:IsA(&quot;BaseScript&quot;) and toolChildren[i] ~= script then
&#9;&#9;&#9;deactivateTool(toolChildren[i])
&#9;&#9;end
&#9;end
&#9;for i = 1, #buttons do
&#9;&#9;buttons[i].Selected = false
&#9;end
end

function goToTool(toolName, button)
&#9;deactivateAllTools()
&#9;button.Selected = true

&#9;wait() -- give scripts a heartbeat to get set straight

&#9;local toolScript = Tool:FindFirstChild(toolName)
&#9;if toolScript and toolScript:IsA(&quot;BaseScript&quot;) then
&#9;&#9;local enable = toolScript:FindFirstChild(&quot;Active&quot;)
&#9;&#9;if enable and enable:IsA(&quot;BoolValue&quot;) then
&#9;&#9;&#9;enable.Value = true
&#9;&#9;end
&#9;end
end

function makeClassicControlGui()
&#9;clearAllConnections()

&#9;local classicGui = Instance.new(&quot;ScreenGui&quot;)
&#9;classicGui.Name = &quot;ClassicGui&quot;
&#9;
&#9;local classicFrame = Instance.new(&quot;Frame&quot;)
&#9;classicFrame.Name = &quot;ClassicFrame&quot;
&#9;classicFrame.BackgroundTransparency = 1
&#9;classicFrame.Size = UDim2.new(0,246,0,45)
&#9;classicFrame.Position = UDim2.new(0.5, -113, 1, -130)
&#9;classicFrame.Parent = classicGui

&#9;colorButton = makeImageButton(&quot;ColorButton&quot;,&quot;http://www.roblox.com/asset?id=59103051&quot;,UDim2.new(0,0,0.5,-23), classicFrame, &quot;F&quot;)
&#9;local colorCon = colorButton.MouseButton1Click:connect(function() goToTool(&quot;Color&quot;, colorButton) end)
&#9;table.insert(connections,colorCon)
&#9;table.insert(buttons,colorButton)

&#9;SurfaceButton = makeImageButton(&quot;SurfaceButton&quot;,&quot;http://www.roblox.com/asset?id=59103080&quot;,UDim2.new(0,90,0.5,-23), classicFrame, &quot;H&quot;)
&#9;local surfaceCon = SurfaceButton.MouseButton1Click:connect(function() goToTool(&quot;Surface&quot;, SurfaceButton) end)
&#9;table.insert(connections,surfaceCon)
&#9;table.insert(buttons,SurfaceButton)

&#9;MaterialButton = makeImageButton(&quot;MaterialButton&quot;,&quot;http://www.roblox.com/asset?id=59103092&quot;,UDim2.new(0,45,0.5,-23), classicFrame, &quot;G&quot;)
&#9;local materialCon = MaterialButton.MouseButton1Click:connect(function() goToTool(&quot;Material&quot;, MaterialButton) end)
&#9;table.insert(connections,materialCon)
&#9;table.insert(buttons,MaterialButton)

&#9;ResizeButton = makeImageButton(&quot;ResizeButton&quot;,&quot;http://www.roblox.com/asset?id=59103119&quot;,UDim2.new(0,180,0.5,-23), classicFrame, &quot;K&quot;)
&#9;local resizeCon = ResizeButton.MouseButton1Click:connect(function() goToTool(&quot;Resize&quot;, ResizeButton) end)
&#9;table.insert(connections,resizeCon)
&#9;table.insert(buttons,ResizeButton)

&#9;draggerButton = makeImageButton(&quot;ResizeButton&quot;,&quot;http://www.roblox.com/asset?id=59103152&quot;,UDim2.new(0,135,0.5,-23), classicFrame, &quot;J&quot;)
&#9;local draggerCon = draggerButton.MouseButton1Click:connect(function() goToTool(&quot;Dragger&quot;, draggerButton) end)
&#9;table.insert(connections,draggerCon)
&#9;table.insert(buttons,draggerButton)

&#9;return classicGui
end

function clearAllConnections()
&#9;for i = 1, #connections do
&#9;&#9;connections[i]:disconnect()
&#9;end
&#9;connections = {}
end


function hotKey(key)
&#9;key = key:lower()

&#9;if key == &quot;f&quot; then
&#9;&#9;goToTool(&quot;Color&quot;, colorButton)
&#9;elseif key == &quot;g&quot; then
&#9;&#9;goToTool(&quot;Material&quot;, MaterialButton)
&#9;elseif key == &quot;h&quot; then
&#9;&#9;goToTool(&quot;Surface&quot;, SurfaceButton)
&#9;elseif key == &quot;j&quot; then
&#9;&#9;goToTool(&quot;Dragger&quot;, draggerButton)
&#9;elseif key == &quot;k&quot; then
&#9;&#9;goToTool(&quot;Resize&quot;, ResizeButton)
&#9;end
end


function onEquippedLocal(mouse)
&#9;Tool.Mouse.Value = mouse
&#9;if not gui then
&#9;&#9;gui = makeClassicControlGui()
&#9;end
&#9;gui.Parent = game.Players.LocalPlayer.PlayerGui

&#9;keyUpCon = mouse.KeyUp:connect(function(key) hotKey(key) end)
end

function onUnequippedLocal()
&#9;if keyUpCon then keyUpCon:disconnect() end
&#9;deactivateAllTools()
&#9;gui.Parent = nil&#9;
end

Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX148">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>98.9375</X>
						<Y>233.574951</Y>
						<Z>158.4375</Z>
						<R00>0.000139951706</R00>
						<R01>0</R01>
						<R02>-0.99999994</R02>
						<R10>-0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0.99999994</R20>
						<R21>0</R21>
						<R22>0.000139951706</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0.00235385541</X>
						<Y>0.00367370201</Y>
						<Z>-0.00497476896</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>-0.0078106001</X>
						<Y>-0.0230827946</Y>
						<Z>-0.00332456268</Z>
					</Vector3>
					<token name="formFactorRaw">2</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.800000012</Y>
						<Z>2</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX149">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.roblox.com/asset/?id=15952510</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>0.400000006</X>
							<Y>0.400000006</Y>
							<Z>0.400000006</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.roblox.com/asset/?id=15952494</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX150">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Sound</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds/swordslash.wav</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX151">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Sound</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds/unsheath.wav</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX152">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Sound</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds/swordslash.wav</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX153">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Sound</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>rbxasset://sounds/unsheath.wav</url></Content>
						<float name="Volume">1</float>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX154">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Color</string>
					<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local Tool = script.Parent

enabled = true
local menu
local origTexture = &#9;Tool.TextureId
local localAssetBase = &quot;rbxasset://textures/ui/&quot;
local currentColorButton = nil
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://icons/color_sel.png&quot;)

local buttonDownCon, mouseMoveCon
local clickCons = {}

function onButton1Down(mouse)
&#9;if not enabled then
&#9;&#9;return
&#9;end

&#9;enabled = false
&#9;mouse.Icon = &quot;rbxasset://textures\\GunWaitCursor.png&quot;

&#9;wait(.5)
&#9;mouse.Icon = &quot;rbxasset://textures\\GunCursor.png&quot;
&#9;enabled = true

end


local selectionBox
local selectionLasso


function setSelectionBox(part) 
&#9;unsetSelectionBox()
&#9;selectionBox.Adornee = part
&#9;selectionLasso.Part = part
end
function unsetSelectionBox() 
&#9;selectionBox.Adornee = nil
&#9;selectionLasso.Part = nil
end

function canSelectObject(part)
&#9;return part and not (part.Locked) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function on3dButton1Down(mouse) 
&#9;local part = mouse.Target
&#9;if canSelectObject(part) then
&#9;&#9;if Instance.Lock(part) then
&#9;&#9;&#9;color =  Tool.Color.CurrentColor.Value
&#9;&#9;&#9;if color == nil then
&#9;&#9;&#9;&#9;Instance.Unlock(part)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;&#9;part.BrickColor = color
&#9;&#9;&#9;Instance.Unlock(part)
&#9;&#9;end
&#9;end
end

function on3dMouseMove(mouse) 
&#9;mouse.Icon =&quot;rbxasset://textures\\FillCursor.png&quot;
&#9;local part = mouse.Target
&#9;if canSelectObject(part) then
&#9;&#9;setSelectionBox(part)
&#9;else
&#9;&#9;unsetSelectionBox()
&#9;end
end

function makeColorMenu()
&#9;local paintGui = Instance.new(&quot;ScreenGui&quot;)
&#9;paintGui.Name = &quot;PaintGui&quot;

&#9;local paintMenu = Instance.new(&quot;ImageLabel&quot;)
&#9;paintMenu.Name = &quot;PaintMenu&quot;
&#9;paintMenu.Position = UDim2.new(0,0,1,-600)
&#9;paintMenu.Size = UDim2.new(0,120,0,500)
&#9;paintMenu.BackgroundTransparency = 1
&#9;paintMenu.ZIndex = 2
&#9;paintMenu.Image = localAssetBase .. &quot;PaintMenu.png&quot;
&#9;paintMenu.Parent = paintGui

&#9;local paintColorButton = Instance.new(&quot;ImageButton&quot;)
&#9;paintColorButton.BorderSizePixel = 0
&#9;paintColorButton.ZIndex = 3
&#9;paintColorButton.Size = UDim2.new(0.200000003, 0,0.0500000007, 0)

&#9;local selection = Instance.new(&quot;Frame&quot;)
&#9;selection.Name = &quot;Selection&quot;
&#9;selection.BorderSizePixel = 0
&#9;selection.BackgroundColor3 = Color3.new(1,1,1)
&#9;selection.BackgroundTransparency = 1
&#9;selection.ZIndex = 2
&#9;selection.Size = UDim2.new(1.1,0,1.1,0)
&#9;selection.Position = UDim2.new(-0.05,0,-0.05,0)
&#9;selection.Parent = paintColorButton

&#9;local header  = 0.08
&#9;local spacing = 18

&#9;local count = 1

&#9;local function findNextColor()
&#9;&#9;colorName = tostring(BrickColor.new(count))
&#9;&#9;while colorName == &quot;Medium stone grey&quot; do
&#9;&#9;&#9;count = count + 1
&#9;&#9;&#9;colorName = tostring(BrickColor.new(count))
&#9;&#9;end
&#9;&#9;return count
&#9;end

&#9;for i = 0,15 do
&#9;&#9;for j = 1, 4 do
&#9;&#9;&#9;newButton = paintColorButton:clone()
&#9;&#9;&#9;newButton.BackgroundColor3 = BrickColor.new(findNextColor()).Color
&#9;&#9;&#9;newButton.Name = tostring(BrickColor.new(count))
&#9;&#9;&#9;count = count + 1
&#9;&#9;&#9;if j == 1 then newButton.Position = UDim2.new(0.08,0,i/spacing + header,0)
&#9;&#9;&#9;elseif j == 2 then newButton.Position = UDim2.new(0.29,0,i/spacing + header,0)
&#9;&#9;&#9;elseif j == 3 then newButton.Position = UDim2.new(0.5,0,i/spacing + header,0)
&#9;&#9;&#9;elseif j == 4 then newButton.Position = UDim2.new(0.71,0,i/spacing + header,0) end
&#9;&#9;&#9;newButton.Parent = paintMenu
&#9;&#9;end
&#9;end

&#9;local paintButtons = paintMenu:GetChildren()
&#9;for i = 1, #paintButtons do
&#9;&#9;local newCon = paintButtons[i].MouseButton1Click:connect(function()
&#9;&#9;&#9;Tool.Color.CurrentColor.Value = BrickColor.new(paintButtons[i].Name)

&#9;&#9;&#9;if currentColorButton then
&#9;&#9;&#9;&#9;if currentColorButton:FindFirstChild(&quot;Selection&quot;) then
&#9;&#9;&#9;&#9;&#9;currentColorButton.Selection.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;currentColorButton = paintButtons[i]
&#9;&#9;&#9;paintButtons[i].Selection.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;local anotherCon = paintButtons[i].MouseEnter:connect(function()
&#9;&#9;&#9;paintButtons[i].Selection.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;local oneMoreCon = paintButtons[i].MouseLeave:connect(function()
&#9;&#9;&#9;if paintButtons[i] ~= currentColorButton then paintButtons[i].Selection.BackgroundTransparency = 1 end
&#9;&#9;end)

&#9;&#9;table.insert(clickCons,newCon)
&#9;&#9;table.insert(clickCons,anotherCon)
&#9;&#9;table.insert(clickCons,oneMoreCon)
&#9;end

&#9;return paintGui
end

function onEquippedLocal(mouse)
&#9;Tool.TextureId = &quot;rbxasset://icons/color_sel.png&quot;

&#9;local character = script.Parent.Parent
&#9;local player = game.Players:GetPlayerFromCharacter(character)

&#9;buttonDownCon = mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)
&#9;mouseMoveCon  = mouse.Move:connect(function() on3dMouseMove(mouse) end)
&#9;mouse.Icon =&quot;rbxasset://textures\\FillCursor.png&quot;

&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Color = Tool.Color.CurrentColor.Value
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = player.PlayerGui

&#9;selectionLasso = Instance.new(&quot;SelectionPartLasso&quot;)
&#9;selectionLasso.Name = &quot;Model Delete Lasso&quot;
&#9;selectionLasso.Humanoid = character.Humanoid
&#9;selectionLasso.Part = nil
&#9;selectionLasso.Visible = true
&#9;selectionLasso.archivable = false
&#9;selectionLasso.Color = Tool.Color.CurrentColor.Value
&#9;selectionLasso.Parent = game.workspace

&#9;menu = makeColorMenu()
&#9;menu.Parent = game.Players.LocalPlayer.PlayerGui
end

function onUnequippedLocal()
&#9;if menu then menu:remove() end
&#9;Tool.TextureId = origTexture

&#9;for i = 1, #clickCons do
&#9;&#9;clickCons[i]:disconnect()
&#9;end
&#9;clickCons = {}

&#9;if selectionBox then selectionBox:Remove() end
&#9;if selectionLasso then selectionLasso:Remove() end
&#9;if mouseMoveCon then mouseMoveCon:disconnect() end
&#9;if buttonDownCon then buttonDownCon:disconnect() end
end

waitForChild(Tool.Color,&quot;CurrentColor&quot;)
waitForChild(Tool.Color,&quot;Active&quot;)
Tool.Color.CurrentColor.Changed:connect(function()
&#9;if selectionBox then selectionBox.Color = Tool.Color.CurrentColor.Value end
&#9;if selectionLasso then selectionLasso.Color = Tool.Color.CurrentColor.Value end
end)

script.Active.Changed:connect(function(prop)
&#9;if script.Active.Value == true then
&#9;&#9;onEquippedLocal(Tool.Mouse.Value)
&#9;else
&#9;&#9;onUnequippedLocal()
&#9;end
end)</ProtectedString>
				</Properties>
				<Item class="BoolValue" referent="RBX155">
					<Properties>
						<string name="Name">Active</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BrickColorValue" referent="RBX156">
					<Properties>
						<string name="Name">CurrentColor</string>
						<int name="Value">194</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX157">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Material</string>
					<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local Tool = script.Parent
waitForChild(Tool.Material,&quot;Active&quot;)
waitForChild(Tool.Material,&quot;CurrentMaterial&quot;)

enabled = true
local origTexture = &#9;Tool.TextureId
local localAssetBase = &quot;rbxasset://textures/ui/&quot;
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://icons/material_sel.png&quot;)

local menu

local selectionBox
local selectionLasso

local selectedButton

local value = nil

local downCons = {}

local currentMaterialButton = nil

function setSelectionBox(part) 
&#9;unsetSelectionBox()
&#9;selectionBox.Adornee = part
&#9;selectionLasso.Part = part
end
function unsetSelectionBox() 
&#9;selectionBox.Adornee = nil
&#9;selectionLasso.Part = nil
end

local MaterialEnum = {}
MaterialEnum[&quot;Plastic&quot;] = Enum.Material.Plastic
MaterialEnum[&quot;Wood&quot;] = Enum.Material.Wood
MaterialEnum[&quot;Slate&quot;] = Enum.Material.Slate
MaterialEnum[&quot;CorrodedMetal&quot;] = Enum.Material.CorrodedMetal
MaterialEnum[&quot;Ice&quot;] = Enum.Material.Ice
MaterialEnum[&quot;Grass&quot;] = Enum.Material.Grass
MaterialEnum[&quot;Foil&quot;] = Enum.Material.Foil
MaterialEnum[&quot;DiamondPlate&quot;] = Enum.Material.DiamondPlate
MaterialEnum[&quot;Concrete&quot;] = Enum.Material.Concrete

function on3dButton1Down(mouse) 
&#9;local part = mouse.Target
&#9;if part and not (part.Locked) then
&#9;&#9;if Instance.Lock(part) then
&#9;&#9;&#9;part.Material = MaterialEnum[Tool.Material.CurrentMaterial.Value]
&#9;&#9;&#9;Instance.Unlock(part)
&#9;&#9;end
&#9;end
end

function canSelectObject(part)
&#9;return part and not (part.Locked) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end


function on3dMouseMove(mouse) 
&#9;mouse.Icon =&quot;rbxasset://textures\\MaterialCursor.png&quot;
&#9;local part = mouse.Target
&#9;if canSelectObject(part) then
&#9;&#9;setSelectionBox(part)
&#9;else
&#9;&#9;unsetSelectionBox()
&#9;end
end

function createMaterialMenu()
&#9;local materialGui = Instance.new(&quot;ScreenGui&quot;)
&#9;materialGui.Name = &quot;MaterialGui&quot;

&#9;local materialMenu = Instance.new(&quot;ImageLabel&quot;)
&#9;materialMenu.Name = &quot;MaterialMenu&quot;
&#9;materialMenu.Position = UDim2.new(0,0,1,-350)
&#9;materialMenu.Size = UDim2.new(0,100,0,250)
&#9;materialMenu.BackgroundTransparency = 1
&#9;materialMenu.ZIndex = 2
&#9;materialMenu.Image = localAssetBase .. &quot;MaterialMenu.png&quot;
&#9;materialMenu.Parent = materialGui

&#9;local textures = {&quot;Plastic&quot;,&quot;Wood&quot;,&quot;Slate&quot;,&quot;CorrodedMetal&quot;,&quot;Ice&quot;,&quot;Grass&quot;,&quot;Foil&quot;,&quot;DiamondPlate&quot;,&quot;Concrete&quot;}

&#9;local materialButtons = {}

&#9;local materialButton = Instance.new(&quot;ImageButton&quot;)
&#9;materialButton.BackgroundTransparency = 1
&#9;materialButton.Size = UDim2.new(0.400000003, 0,0.16, 0)
&#9;materialButton.ZIndex = 4

&#9;local selection = Instance.new(&quot;Frame&quot;)
&#9;selection.Name = &quot;Selection&quot;
&#9;selection.BorderSizePixel = 0
&#9;selection.BackgroundColor3 = Color3.new(1,1,1)
&#9;selection.BackgroundTransparency = 1
&#9;selection.ZIndex = 3
&#9;selection.Size = UDim2.new(1.1,0,1.1,0)
&#9;selection.Position = UDim2.new(-0.05,0,-0.05,0)
&#9;selection.Parent = materialButton

&#9;local current = 1
&#9;local function getTextureAndName(button)

&#9;&#9;if current &gt; #textures then
&#9;&#9;&#9;button:remove()
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;&#9;button.Image = localAssetBase .. textures[current] .. &quot;.png&quot;
&#9;&#9;button.Name = textures[current]
&#9;&#9;current = current + 1
&#9;&#9;return true

&#9;end

&#9;local ySpacing = 0.10
&#9;local xSpacing  = 0.07
&#9;for i = 1,5 do
&#9;&#9;for j = 1,2 do
&#9;&#9;&#9;local button = materialButton:clone()
&#9;&#9;&#9;button.Position = UDim2.new((j -1)/2.2 + xSpacing,0,ySpacing + (i - 1)/5.5,0)
&#9;&#9;&#9;if getTextureAndName(button) then button.Parent = materialMenu else button:remove() end
&#9;&#9;&#9;table.insert(materialButtons,button)
&#9;&#9;end
&#9;end


&#9;for i = 1, #materialButtons do
&#9;&#9;local newCon = materialButtons[i].MouseButton1Click:connect(function()
&#9;&#9;&#9;Tool.Material.CurrentMaterial.Value = materialButtons[i].Name

&#9;&#9;&#9;if currentMaterialButton then
&#9;&#9;&#9;&#9;if currentMaterialButton:FindFirstChild(&quot;Selection&quot;) then
&#9;&#9;&#9;&#9;&#9;currentMaterialButton.Selection.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;currentMaterialButton = materialButtons[i]
&#9;&#9;&#9;materialButtons[i].Selection.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;local enterCon = materialButtons[i].MouseEnter:connect(function()
&#9;&#9;&#9;materialButtons[i].Selection.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;local leaveCon = materialButtons[i].MouseLeave:connect(function()
&#9;&#9;&#9;if materialButtons[i] ~= currentMaterialButton then materialButtons[i].Selection.BackgroundTransparency = 1 end
&#9;&#9;end)
&#9;&#9;table.insert(downCons, newCon)
&#9;&#9;table.insert(downCons, enterCon)
&#9;&#9;table.insert(downCons, leaveCon)
&#9;end

&#9;return materialGui
end

function onEquippedLocal(mouse)
&#9;Tool.TextureId = &quot;rbxasset://icons/material_sel.png&quot;
&#9;value = nil
&#9;selectedButton = nil

&#9;local character = script.Parent.Parent
&#9;local player = game.Players:GetPlayerFromCharacter(character)

&#9;selectedButton = nil

&#9;button1DownCon = mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)
&#9;mouseMoveCon = mouse.Move:connect(function() on3dMouseMove(mouse) end)
&#9;mouse.Icon =&quot;rbxasset://textures\\MaterialCursor.png&quot;

&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Color = BrickColor.Yellow()
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = player.PlayerGui

&#9;selectionLasso = Instance.new(&quot;SelectionPartLasso&quot;)
&#9;selectionLasso.Name = &quot;Model Material Lasso&quot;
&#9;selectionLasso.Humanoid = character.Humanoid
&#9;selectionLasso.Parent = game.workspace
&#9;selectionLasso.Part = nil
&#9;selectionLasso.Visible = true
&#9;selectionLasso.archivable = false
&#9;selectionLasso.Color = BrickColor.Green()

&#9;menu = createMaterialMenu()
&#9;menu.Parent = game.Players.LocalPlayer.PlayerGui
end

function onUnequippedLocal()
&#9;if button1DownCon then button1DownCon:disconnect() end
&#9;if mouseMoveCon then mouseMoveCon:disconnect() end

&#9;for i = 1, #downCons do
&#9;&#9;downCons[i]:disconnect()
&#9;end
&#9;downCons = {}

&#9;menu:remove()
&#9;Tool.TextureId = origTexture
&#9;if selectionBox then selectionBox:Remove() end
&#9;if selectionLasso then selectionLasso:Remove() end
end

script.Active.Changed:connect(function(prop)
&#9;if script.Active.Value == true then
&#9;&#9;onEquippedLocal(Tool.Mouse.Value)
&#9;else
&#9;&#9;onUnequippedLocal()
&#9;end
end)
</ProtectedString>
				</Properties>
				<Item class="BoolValue" referent="RBX158">
					<Properties>
						<string name="Name">Active</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX159">
					<Properties>
						<string name="Name">CurrentMaterial</string>
						<string name="Value">Plastic</string>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX160">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Resize</string>
					<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local Tool = script.Parent
waitForChild(Tool.Resize,&quot;Active&quot;)

enabled = true
local origTexture = &#9;Tool.TextureId
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://icons/resize_sel.png&quot;)

local selectionBox
local selectionLasso
local handles

local previousDistance
local needsCursor = true

local currMouseTarget
local connections = {}

function onHandlesDown(normal)
&#9;previousDistance = 0
end
function onHandlesDrag(normal, distance)
&#9;
&#9;if handles.Adornee then
&#9;&#9;local delta = distance - previousDistance 
&#9;&#9;if math.abs(delta) &gt;= handles.Adornee.ResizeIncrement then
&#9;&#9;&#9;local sizeDelta = math.floor(delta / handles.Adornee.ResizeIncrement + 0.5) * handles.Adornee.ResizeIncrement
&#9;&#9;&#9;if handles.Adornee:Resize(normal, sizeDelta) then
&#9;&#9;&#9;&#9;previousDistance = distance
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function onButton1Down(mouse)
&#9;local success = pcall(function() theMouse = mouse.Target end)

&#9;if success then
&#9;&#9;if canSelect(mouse.Target) then
&#9;&#9;&#9;selectionBox.Adornee = mouse.Target
&#9;&#9;&#9;selectionLasso.Part = mouse.Target
&#9;&#9;&#9;handles.Adornee = mouse.Target
&#9;&#9;&#9;handles.Faces = mouse.Target.ResizeableFaces
&#9;&#9;else
&#9;&#9;&#9;selectionBox.Adornee = nil
&#9;&#9;&#9;selectionLasso.Part = nil
&#9;&#9;&#9;handles.Adornee = nil
&#9;&#9;end
&#9;end
end

function mouseTargetChanged(mouse)

&#9;if canSelect(mouse.Target) then
&#9;&#9;if needsCursor then
&#9;&#9;&#9;mouse.Icon =&quot;rbxasset://textures\\DragCursor.png&quot;
&#9;&#9;&#9;needsCursor = false
&#9;&#9;end
&#9;else
&#9;&#9;needsCursor = true
&#9;&#9;mouse.Icon = &quot;&quot;
&#9;end

end

local function isPartOfModel(object)
&#9;if object and object ~= game.Workspace and object:IsA(&quot;Model&quot;) then
&#9;&#9;return true
&#9;elseif not object or object == game.Workspace then
&#9;&#9;return false
&#9;else
&#9;&#9;return isPartOfModel(object.Parent)
&#9;end
end

function canSelect(object)
&#9;local isModel = isPartOfModel(object)
&#9;return object and object:IsA(&quot;BasePart&quot;) and not object.Locked and not isPartOfModel(object)
end


function onEquippedLocal(mouse)

&#9;currMouseTarget = nil

&#9;table.insert(connections,mouse.Button1Down:connect(function() onButton1Down(mouse) end) )
&#9;table.insert(connections, mouse.Move:connect(function()
&#9;&#9;&#9;if currMouseTarget ~= mouse.Target then
&#9;&#9;&#9;&#9;mouseTargetChanged(mouse)
&#9;&#9;&#9;&#9;currMouseTarget = mouse.Target
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;)

&#9;local character = script.Parent.Parent
&#9;local player = game.Players:GetPlayerFromCharacter(character)
&#9;
&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Color = BrickColor.Blue()
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = player.PlayerGui

&#9;selectionLasso = Instance.new(&quot;SelectionPartLasso&quot;)
&#9;selectionLasso.Name = &quot;Model Delete Lasso&quot;
&#9;selectionLasso.Humanoid = character.Humanoid
&#9;selectionLasso.Parent = game.workspace
&#9;selectionLasso.Part = nil
&#9;selectionLasso.Visible = true
&#9;selectionLasso.archivable = false
&#9;selectionLasso.Color = BrickColor.Red()

&#9;handles = Instance.new(&quot;Handles&quot;)
&#9;handles.Color = BrickColor.Blue()
&#9;handles.Adornee = nil
&#9;handles.MouseDrag:connect(onHandlesDrag)
&#9;handles.MouseButton1Down:connect(onHandlesDown)
&#9;handles.Parent = player.PlayerGui
end

function onUnequippedLocal()
&#9;Tool.TextureId = origTexture
&#9;selectionBox:Remove()
&#9;selectionLasso:Remove()
&#9;handles:Remove()

&#9;for i = 1, #connections do
&#9;&#9;if connections[i] then connections[i]:disconnect() end
&#9;end

&#9;connections = {}
end

script.Active.Changed:connect(function(prop)
&#9;if script.Active.Value == true then
&#9;&#9;onEquippedLocal(Tool.Mouse.Value)
&#9;else
&#9;&#9;onUnequippedLocal()
&#9;end
end)
</ProtectedString>
				</Properties>
				<Item class="BoolValue" referent="RBX161">
					<Properties>
						<string name="Name">Active</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX162">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Surface</string>
					<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local Tool = script.Parent
local menu


waitForChild(Tool.Surface,&quot;Active&quot;)
waitForChild(Tool.Surface,&quot;CurrentSurface&quot;)

enabled = true
local origTexture = &#9;Tool.TextureId
local localAssetBase = &quot;rbxasset://textures/ui/&quot;
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://icons/surface_sel.png&quot;)

local selectionSurface
local selectionLasso

local currentSurfaceButton = nil

local mouseMoveCon, button1DownCon
local conArray = {}

function setSelectionSurface(part, surface) 
&#9;unsetSelectionSurface()
&#9;selectionSurface.Adornee = part
&#9;selectionSurface.TargetSurface = surface
&#9;selectionLasso.Part = part
end
function unsetSelectionSurface() 
&#9;selectionSurface.Adornee = nil
&#9;selectionLasso.Part = nil
end

local SurfaceEnum = {}
SurfaceEnum[&quot;Smooth&quot;] = Enum.SurfaceType.Smooth
SurfaceEnum[&quot;Studs&quot;] = Enum.SurfaceType.Studs
SurfaceEnum[&quot;Inlet&quot;] = Enum.SurfaceType.Inlet
SurfaceEnum[&quot;Universal&quot;] = Enum.SurfaceType.Universal
SurfaceEnum[&quot;Glue&quot;] = Enum.SurfaceType.Glue
SurfaceEnum[&quot;Weld&quot;] = Enum.SurfaceType.Weld
SurfaceEnum[&quot;Hinge&quot;] = Enum.SurfaceType.Hinge
SurfaceEnum[&quot;Motor&quot;] = Enum.SurfaceType.Motor


function canSelectObject(part, surface)
&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60 and 
&#9;&#9;(not(part:IsA(&quot;WedgePart&quot;)) or surface ~= Enum.NormalId.Front)
end


function on3dMouseMove(mouse)
&#9;local part = mouse.Target
&#9;local surface = mouse.TargetSurface
&#9;if canSelectObject(part, surface) then
&#9;&#9;setSelectionSurface(part, surface)
&#9;else
&#9;&#9;unsetSelectionSurface()
&#9;end

end
function on3dButton1Down(mouse) 
&#9;local part = selectionSurface.Adornee
&#9;if part then
&#9;&#9;local normalId = selectionSurface.TargetSurface
&#9;&#9;local surface = Tool.Surface.CurrentSurface.Value
&#9;&#9;if surface == nil then return end
&#9;&#9;--Apply the selected surface to the current parts
&#9;&#9;if normalId == Enum.NormalId.Top then
&#9;&#9;&#9;part.TopSurface = surface
&#9;&#9;elseif normalId == Enum.NormalId.Bottom then  
&#9;&#9;elseif normalId == Enum.NormalId.Front then  
&#9;&#9;&#9;part.BottomSurface = surface
&#9;&#9;&#9;part.FrontSurface = surface
&#9;&#9;elseif normalId == Enum.NormalId.Back then  
&#9;&#9;&#9;part.BackSurface = surface
&#9;&#9;elseif normalId == Enum.NormalId.Left then  
&#9;&#9;&#9;part.LeftSurface = surface
&#9;&#9;elseif normalId == Enum.NormalId.Right then  
&#9;&#9;&#9;part.RightSurface = surface
&#9;&#9;end
&#9;end
end

function createSurfaceMenu()

&#9;local surfaceGui = Instance.new(&quot;ScreenGui&quot;)
&#9;surfaceGui.Name = &quot;SurfaceGui&quot;

&#9;local surfaceMenu = Instance.new(&quot;ImageLabel&quot;)
&#9;surfaceMenu.Name = &quot;SurfaceMenu&quot;
&#9;surfaceMenu.Position = UDim2.new(0,0,1,-400)
&#9;surfaceMenu.Size = UDim2.new(0,150,0,300)
&#9;surfaceMenu.BackgroundTransparency = 1
&#9;surfaceMenu.ZIndex = 2
&#9;surfaceMenu.Image = localAssetBase .. &quot;SurfaceMenu.png&quot;
&#9;surfaceMenu.Parent = surfaceGui

&#9;textures = {&quot;Smooth&quot;, &quot;Studs&quot;, &quot;Inlets&quot;, &quot;Universal&quot;, &quot;Glue&quot;, &quot;Weld&quot;, &quot;Hinge&quot;, &quot;Motor&quot;}
&#9;current = 1

&#9;local surfaceButtons = {}

&#9;local surfaceButton = Instance.new(&quot;ImageButton&quot;)
&#9;surfaceButton.BackgroundTransparency = 1
&#9;surfaceButton.Size = UDim2.new(0.400000003, 0,0.19, 0)
&#9;surfaceButton.ZIndex = 4
&#9;
&#9;local selection = Instance.new(&quot;Frame&quot;)
&#9;selection.Name = &quot;Selection&quot;
&#9;selection.BorderSizePixel = 0
&#9;selection.BackgroundColor3 = Color3.new(1,1,1)
&#9;selection.BackgroundTransparency = 1
&#9;selection.ZIndex = 3
&#9;selection.Size = UDim2.new(1.1,0,1.1,0)
&#9;selection.Position = UDim2.new(-0.05,0,-0.05,0)
&#9;selection.Parent = surfaceButton

&#9;local function getTextureAndName(button)
&#9;&#9;if current &gt; #textures then
&#9;&#9;&#9;button:remove()
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;&#9;button.Image = localAssetBase .. textures[current] .. &quot;.png&quot;

&#9;&#9;if textures[current] == &quot;Inlets&quot; then --nice hack to adjust for inconsistent namings
&#9;&#9;&#9;button.Name = &quot;Inlet&quot;
&#9;&#9;else
&#9;&#9;&#9;button.Name = textures[current]
&#9;&#9;end

&#9;&#9;current = current + 1
&#9;&#9;return true
&#9;end

&#9;local ySpacing = 0.14
&#9;local xSpacing  = 0.07
&#9;for i = 1,4 do
&#9;&#9;for j = 1,2 do
&#9;&#9;&#9;local button = surfaceButton:clone()
&#9;&#9;&#9;button.Position = UDim2.new((j -1)/2.2 + xSpacing,0,ySpacing + (i - 1)/4.6,0)
&#9;&#9;&#9;getTextureAndName(button)
&#9;&#9;&#9;button.Parent = surfaceMenu
&#9;&#9;&#9;table.insert(surfaceButtons,button)
&#9;&#9;end
&#9;end

&#9;for i = 1, #surfaceButtons do
&#9;&#9;local newCon = surfaceButtons[i].MouseButton1Click:connect(function()
&#9;&#9;&#9;Tool.Surface.CurrentSurface.Value = surfaceButtons[i].Name

&#9;&#9;&#9;if currentSurfaceButton then 
&#9;&#9;&#9;&#9;if currentSurfaceButton:FindFirstChild(&quot;Selection&quot;) then
&#9;&#9;&#9;&#9;&#9;currentSurfaceButton.Selection.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;currentSurfaceButton = surfaceButtons[i]
&#9;&#9;&#9;surfaceButtons[i].Selection.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;local enterCon = surfaceButtons[i].MouseEnter:connect(function()
&#9;&#9;&#9;surfaceButtons[i].Selection.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;local leaveCon = surfaceButtons[i].MouseLeave:connect(function()
&#9;&#9;&#9;if surfaceButtons[i] ~= currentSurfaceButton then surfaceButtons[i].Selection.BackgroundTransparency = 1 end
&#9;&#9;end)
&#9;&#9;table.insert(conArray,newCon)
&#9;&#9;table.insert(conArray,enterCon)
&#9;&#9;table.insert(conArray,leaveCon)
&#9;end

&#9;return surfaceGui
end



function onEquippedLocal(mouse)
&#9;Tool.TextureId = &quot;rbxasset://icons/surface_sel.png&quot;
&#9;local character = script.Parent.Parent
&#9;local player = game.Players:GetPlayerFromCharacter(character)

&#9;mouseMoveCon = mouse.Move:connect(function() on3dMouseMove(mouse) end)
&#9;button1DownCon = mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)

&#9;selectionSurface = Instance.new(&quot;SurfaceSelection&quot;)
&#9;selectionSurface.Color = BrickColor.Red()
&#9;selectionSurface.Adornee = nil
&#9;selectionSurface.Parent = player.PlayerGui

&#9;selectionLasso = Instance.new(&quot;SelectionPartLasso&quot;)
&#9;selectionLasso.Name = &quot;Model Surface Lasso&quot;
&#9;selectionLasso.Humanoid = character.Humanoid
&#9;selectionLasso.Parent = game.workspace
&#9;selectionLasso.Part = nil
&#9;selectionLasso.Visible = true
&#9;selectionLasso.archivable = false
&#9;selectionLasso.Color = BrickColor.Yellow()

&#9;menu = createSurfaceMenu()
&#9;menu.Parent = game.Players.LocalPlayer.PlayerGui
end

function onUnequippedLocal()
&#9;if mouseMoveCon then mouseMoveCon:disconnect() end
&#9;if button1DownCon then button1DownCon:disconnect() end

&#9;for i = 1, #conArray do
&#9;&#9;if conArray[i] then conArray[i]:disconnect() end
&#9;end
&#9;conArray = {}

&#9;menu:remove()
&#9;Tool.TextureId = origTexture
&#9;if selectionBox then selectionBox:Remove() end
&#9;if selectionLasso then selectionLasso:Remove() end
&#9;if selectionSurface then selectionSurface:Remove() end
end

script.Active.Changed:connect(function(prop)
&#9;if script.Active.Value == true then
&#9;&#9;onEquippedLocal(Tool.Mouse.Value)
&#9;else
&#9;&#9;onUnequippedLocal()
&#9;end
end)
</ProtectedString>
				</Properties>
				<Item class="BoolValue" referent="RBX163">
					<Properties>
						<string name="Name">Active</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX164">
					<Properties>
						<string name="Name">CurrentSurface</string>
						<string name="Value">Smooth</string>
					</Properties>
				</Item>
			</Item>
			<Item class="ObjectValue" referent="RBX165">
				<Properties>
					<string name="Name">Mouse</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX166">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Dragger</string>
					<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local Tool = script.Parent

waitForChild(Tool.Dragger, &quot;Active&quot;)


local gui = nil

local connections = {}

function deactivateTool(script)
&#9;local enable = script:FindFirstChild(&quot;Active&quot;)
&#9;if enable and enable:IsA(&quot;BoolValue&quot;) then
&#9;&#9;enable.Value = false
&#9;end
end

function deactivateAllTools()
&#9;local toolChildren = script:GetChildren()
&#9;for i = 1, #toolChildren do
&#9;&#9;if toolChildren[i]:IsA(&quot;BaseScript&quot;) and toolChildren[i] ~= script then
&#9;&#9;&#9;deactivateTool(toolChildren[i])
&#9;&#9;end
&#9;end
end

function switchGrid(type)
&#9;deactivateAllTools()

&#9;wait()

&#9;if type == &quot;1&quot; then
&#9;&#9;script.OldDragger.Active.Value = true
&#9;&#9;gui.DraggerButton.Selected = true
&#9;&#9;gui.Dragger4xButton.Selected = false
&#9;else
&#9;&#9;script.NewDragger.Active.Value = true
&#9;&#9;gui.DraggerButton.Selected = false
&#9;&#9;gui.Dragger4xButton.Selected = true
&#9;end
end

function makeTextButton(buttonName, text, position, parent)
&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;button.Name = buttonName
&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;button.Size = UDim2.new(0,100,0,40)
&#9;if position then button.Position = position end
&#9;button.Parent = parent

&#9;button.Text = text
&#9;button.Font = Enum.Font.ArialBold
&#9;button.FontSize = Enum.FontSize.Size18
&#9;button.TextColor3 = Color3.new(1,1,1)

&#9;return button
end

function makeDraggerGui()
&#9;local draggerGui = Instance.new(&quot;ScreenGui&quot;)
&#9;draggerGui.Name = &quot;DraggerGui&quot;

&#9;local draggerButton = makeTextButton(&quot;DraggerButton&quot;,&quot;1x1 Grid&quot;,UDim2.new(0.5,-100,0,0),draggerGui)
&#9;local dragger4xButton = makeTextButton(&quot;Dragger4xButton&quot;,&quot;4x4 Grid&quot;,UDim2.new(0.5,0,0,0),draggerGui)

&#9;local con = draggerButton.MouseButton1Click:connect(function() switchGrid(&quot;1&quot;) end)
&#9;local con2 = dragger4xButton.MouseButton1Click:connect(function() switchGrid(&quot;4&quot;) end)
&#9;table.insert(connections,con)
&#9;table.insert(connections,con2)

&#9;return draggerGui
end


function onEquippedLocal(mouse)
&#9;Tool.Mouse.Value = mouse
&#9;if not gui then
&#9;&#9;gui = makeDraggerGui()
&#9;end
&#9;gui.Parent = game.Players.LocalPlayer.PlayerGui
&#9;script.NewDragger.Active.Value = true
&#9;gui.Dragger4xButton.Selected = true
end

function onUnequippedLocal()
&#9;for i = 1, #connections do
&#9;&#9;connections[i]:disconnect()
&#9;end
&#9;connections = {}

&#9;gui:remove()
&#9;gui = nil
&#9;deactivateAllTools()
end

script.Active.Changed:connect(function(prop)
&#9;if script.Active.Value == true then
&#9;&#9;onEquippedLocal(Tool.Mouse.Value)
&#9;else
&#9;&#9;onUnequippedLocal()
&#9;end
end)

</ProtectedString>
				</Properties>
				<Item class="LocalScript" referent="RBX167">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">OldDragger</string>
						<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local Tool = script.Parent.Parent


waitForChild(Tool.Dragger.OldDragger, &quot;Active&quot;)

enabled = true
local origTexture = &#9;Tool.TextureId
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://icons/freemove_sel.png&quot;)

local selectionBox
local currentSelection
local currentSelectionColors = {}
local selectionLasso
local inGui = false
local inPalette = false

local connections = {}

function canSelectObject(part)
&#9;return part and not (part.Locked) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function findModel(part)
&#9;while part ~= nil do
&#9;&#9;if part:IsA(&quot;Model&quot;) and part ~= game.Workspace then
&#9;&#9;&#9;return part
&#9;&#9;elseif part == game.Workspace then
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;&#9;part = part.Parent
&#9;end

&#9;return nil
end


function startDrag(mousePart, hitPoint, collection)
&#9;dragger = Instance.new(&quot;Dragger&quot;)
&#9;pcall(function() dragger:MouseDown(mousePart, hitPoint, collection) end)
end

function collectBaseParts(object, collection)
&#9;if object == nil then return end
&#9;if object:IsA(&quot;BasePart&quot;) then
&#9;&#9;collection[#collection+1] = object
&#9;end
&#9;for index,child in pairs(object:GetChildren()) do
&#9;&#9;collectBaseParts(child, collection)
&#9;end
end

function onMouseDown(mouse) 
&#9;mouse.Icon =&quot;rbxasset://textures\\GrabRotateCursor.png&quot;
&#9;local part = mouse.Target
&#9;if canSelectObject(part) then
&#9;&#9;local hitPoint = mouse.Hit:toObjectSpace(part.CFrame).p
&#9;&#9;if trySelection(part) then
&#9;&#9;&#9;local instances = {}
&#9;&#9;&#9;collectBaseParts(currentSelection, instances)
&#9;&#9;&#9;startDrag(part, hitPoint, instances)
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;onMouseUp(mouse)
end



function onMouseUp(mouse)
&#9;mouse.Icon =&quot;rbxasset://textures\\GrabCursor.png&quot;
&#9;if dragger ~= nil then
&#9;&#9;pcall(function() dragger:MouseUp() end)
&#9;&#9;dragger = nil
&#9;end
end

function trySelection(part)
&#9;if canSelectObject(part) then
&#9;&#9;selectionLasso.Part = part
&#9;&#9;local model = findModel(part)
&#9;&#9;if model then &#9;&#9;
&#9;&#9;&#9;return setSelection(model)
&#9;&#9;else
&#9;&#9;&#9;return setSelection(part)
&#9;&#9;end
&#9;else
&#9;&#9;clearSelection()
&#9;&#9;return false
&#9;end
end

function onKeyDown(key)
&#9;if dragger ~= nil then
&#9;&#9;if key == &apos;R&apos; or key == &apos;r&apos;  then
&#9;&#9;&#9;dragger:AxisRotate(Enum.Axis.Y)
&#9;&#9;elseif key == &apos;T&apos; or key == &apos;t&apos; then
&#9;&#9;&#9;dragger:AxisRotate(Enum.Axis.Z)
&#9;&#9;end
&#9;end
end
local alreadyMoving
function onMouseMove(mouse)
&#9;if alreadyMoving then
&#9;&#9;return
&#9;end

&#9;alreadyMoving = true
&#9;if dragger ~= nil then
&#9;&#9;pcall(function() dragger:MouseMove(mouse.UnitRay) end)
&#9;else
&#9;&#9;trySelection(mouse.Target)
&#9;end
&#9;alreadyMoving = false
end


function saveSelectionColor(instance)
&#9;if instance:IsA(&quot;BasePart&quot;) then
&#9;&#9;currentSelectionColors[instance] = instance.BrickColor
&#9;&#9;if instance.BrickColor == BrickColor.Blue() then
&#9;&#9;&#9;instance.BrickColor = BrickColor.new(&quot;Deep blue&quot;)
&#9;&#9;else
&#9;&#9;&#9;instance.BrickColor = BrickColor.Blue()
&#9;&#9;end
&#9;end

&#9;local children = instance:GetChildren() 
&#9;if children then
&#9;&#9;for pos, child in pairs(children) do
&#9;&#9;&#9;saveSelectionColor(child)
&#9;&#9;end
&#9;end
end
&#9;
function setSelection(partOrModel)
&#9;if partOrModel ~= currentSelection then
&#9;&#9;clearSelection()
&#9;&#9;currentSelection = partOrModel
&#9;&#9;saveSelectionColor(currentSelection)
&#9;&#9;selectionBox.Adornee = currentSelection
&#9;&#9;return true
&#9;else
&#9;&#9;if currentSelection ~= nil then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end

&#9;return false
end

function clearSelection()
&#9;if currentSelection ~= nil then
&#9;&#9;for part, color in pairs(currentSelectionColors) do
&#9;&#9;&#9;part.BrickColor = color
&#9;&#9;end
&#9;&#9;selectionBox.Adornee = nil
&#9;end
&#9;currentSelectionColors = {}
&#9;currentSelection = nil
&#9;
&#9;if(selectionLasso) then
&#9;&#9;selectionLasso.Part = nil
&#9;end
&#9;if(selectionBox) then
&#9;&#9;selectionBox.Adornee = nil
&#9;end
end

function onEquippedLocal(mouse)
&#9;wait(0.1)
&#9;Tool.TextureId = &quot;rbxasset://icons/freemove_sel.png&quot;

&#9;local character = script.Parent.Parent
&#9;local player = game.Players:GetPlayerFromCharacter(character)
&#9;guiMain = Instance.new(&quot;ScreenGui&quot;)
&#9;guiMain.Parent = game.Players.LocalPlayer.PlayerGui

&#9;inGui = false
&#9;inPalette = false

&#9;mouse.Icon =&quot;rbxasset://textures\\GrabCursor.png&quot;

&#9;local con = mouse.Button1Down:connect(function() onMouseDown(mouse) end)
&#9;table.insert(connections,con)
&#9;con = mouse.Button1Up:connect(function() onMouseUp(mouse) end)
&#9;con = table.insert(connections,con)
&#9;con = mouse.Move:connect(function() onMouseMove(mouse) end)
&#9;table.insert(connections,con)
&#9;con = mouse.KeyDown:connect(function(string) onKeyDown(string) end)
&#9;table.insert(connections,con)

&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Name = &quot;Model Delete Selection&quot;
&#9;selectionBox.Color = BrickColor.Blue()
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = game.Players.LocalPlayer.PlayerGui

&#9;selectionLasso = Instance.new(&quot;SelectionPartLasso&quot;)
&#9;selectionLasso.Name = &quot;Model Drag Lasso&quot;
&#9;selectionLasso.Humanoid = game.Players.LocalPlayer.Character.Humanoid
&#9;selectionLasso.archivable = false
&#9;selectionLasso.Visible = true
&#9;selectionLasso.Parent = game.workspace
&#9;selectionLasso.Color = BrickColor.Blue()

&#9;alreadyMoving = false
end

function onUnequippedLocal()
&#9;for i = 1, #connections do
&#9;&#9;connections[i]:disconnect()
&#9;end
&#9;connections = {}

&#9;Tool.TextureId = origTexture
&#9;clearSelection()
&#9;selectionBox:Remove()
&#9;selectionLasso:Remove()
end


script.Active.Changed:connect(function()
&#9;if script.Active.Value then
&#9;&#9;onEquippedLocal(Tool.Mouse.Value)
&#9;else
&#9;&#9;onUnequippedLocal()
&#9;end
end)
</ProtectedString>
					</Properties>
					<Item class="BoolValue" referent="RBX168">
						<Properties>
							<string name="Name">Active</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
				</Item>
				<Item class="BoolValue" referent="RBX169">
					<Properties>
						<string name="Name">Active</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX170">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NewDragger</string>
						<ProtectedString name="Source">local Tool = script.Parent.Parent

game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://icons/freemove_sel.png&quot;)

local selectionBox
local currentSelection
local currentSelectionColors = {}
local Mouse = nil

local player = nil

local instances = {}
local maxDragDistance = 60

local connections = {}

while not Tool:FindFirstChild(&quot;ErrorBox&quot;) do Tool.ChildAdded:wait() end
local errorBox = Tool.ErrorBox

local lastTargetCFrame = nil

function canSelectObject(part)
&#9;return part and not (part.Locked) and (part.Position - script.Parent.Parent.Parent.Head.Position).Magnitude &lt; maxDragDistance
end

function findModel(part)
&#9;while part ~= nil do
&#9;&#9;if part.className == &quot;Model&quot; then
&#9;&#9;&#9;return part
&#9;&#9;end
&#9;&#9;part = part.Parent
&#9;end

&#9;return nil
end

function isPart(object)
&#9;return object and (object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;VehicleSeat&quot;))
end

function positionPartsAtCFrame3(collection, aCFrame)

&#9;local insertCFrame
&#9;if collection[1]:IsA(&quot;Model&quot;) then
&#9;&#9;-- we assume model has at least one part in it; need to find first part
&#9;&#9;i = 1
&#9;&#9;while (i &lt; (#collection[1]:GetChildren()) and not isPart(collection[1]:GetChildren()[i])) do
&#9;&#9;&#9;i = i + 1
&#9;&#9;end
&#9;&#9;insertCFrame = collection[1]:GetChildren()[i].CFrame

&#9;&#9;for i, object in pairs(collection[1]:GetChildren()) do
&#9;&#9;&#9;if isPart(object) then
&#9;&#9;&#9;&#9;local posPartInWorld = object.Position
&#9;&#9;&#9;&#9;local posPart1InWorld = insertCFrame.p
&#9;&#9;&#9;&#9;local newPosPartInWorld = posPartInWorld - posPart1InWorld + aCFrame.p
&#9;
&#9;&#9;&#9;&#9;local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = object.CFrame:components()
&#9;&#9;&#9;&#9;object.CFrame = CFrame.new(newPosPartInWorld.x, newPosPartInWorld.y, newPosPartInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;collection[1].CFrame = aCFrame
&#9;end

end

function getBoundingBox2(partOrModel)

-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
-- relative to the first part&apos;s coordinate frame.

&#9;local minVec = Vector3.new(math.huge, math.huge, math.huge)
&#9;local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

&#9;if isPart(partOrModel) then
&#9;&#9;minVec = -0.5 * partOrModel.Size
&#9;&#9;maxVec = -minVec
&#9;elseif partOrModel:IsA(&quot;Terrain&quot;) then
&#9;&#9;minVec = Vector3.new(-2, -2, -2)
&#9;&#9;maxVec = Vector3.new(2, 2, 2)
&#9;else
&#9;&#9;local part1 = partOrModel:GetChildren()[1]
&#9;&#9;for i, object in pairs(partOrModel:GetChildren()) do
&#9;&#9;&#9;if isPart(object) then
&#9;&#9;&#9;&#9;boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
&#9;&#9;&#9;&#9;boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
&#9;&#9;&#9;&#9;boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)
&#9;&#9;&#9;&#9;boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

&#9;&#9;&#9;&#9;local minX = minVec.x
&#9;&#9;&#9;&#9;local minY = minVec.y
&#9;&#9;&#9;&#9;local minZ = minVec.z
&#9;&#9;&#9;&#9;local maxX = maxVec.x
&#9;&#9;&#9;&#9;local maxY = maxVec.y
&#9;&#9;&#9;&#9;local maxZ = maxVec.z
&#9;&#9;&#9;&#9;if boxMinInPart1.x &lt; minVec.x then
&#9;&#9;&#9;&#9;&#9;minX = boxMinInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.y &lt; minVec.y then
&#9;&#9;&#9;&#9;&#9;minY = boxMinInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.z &lt; minVec.z then
&#9;&#9;&#9;&#9;&#9;minZ = boxMinInPart1.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.x &lt; minX then
&#9;&#9;&#9;&#9;&#9;minX = boxMaxInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.y &lt; minY then
&#9;&#9;&#9;&#9;&#9;minY = boxMaxInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.z &lt; minZ then
&#9;&#9;&#9;&#9;&#9;minZ = boxMaxInPart1.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if boxMinInPart1.x &gt; maxVec.x then
&#9;&#9;&#9;&#9;&#9;maxX = boxMinInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.y &gt; maxVec.y then
&#9;&#9;&#9;&#9;&#9;maxY = boxMinInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.z &gt; maxVec.z then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMinInPart1.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.x &gt; maxX then
&#9;&#9;&#9;&#9;&#9;maxX = boxMaxInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.y &gt; maxY then
&#9;&#9;&#9;&#9;&#9;maxY = boxMaxInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.z &gt; maxZ then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMaxInPart1.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;minVec = Vector3.new(minX, minY, minZ)
&#9;&#9;&#9;&#9;maxVec = Vector3.new(maxX, maxY, maxZ)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return minVec, maxVec

end


-- function to do the same as above, but in world coordinates (really only used for region3-based bounds-checking)
function getBoundingBoxInWorldCoordinates(partOrModel)
&#9;local minVec = Vector3.new(math.huge, math.huge, math.huge)
&#9;local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

&#9;if partOrModel:IsA(&quot;Part&quot;) or partOrModel:IsA(&quot;WedgePart&quot;) or partOrModel:IsA(&quot;TrussPart&quot;)then
&#9;&#9;vec1 = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
&#9;&#9;vec2 = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
&#9;&#9;minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
&#9;&#9;maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
&#9;elseif partOrModel:IsA(&quot;Terrain&quot;) then
&#9;&#9;-- we shouldn&apos;t have to deal with this case
&#9;&#9;--minVec = Vector3.new(-2, -2, -2)
&#9;&#9;--maxVec = Vector3.new(2, 2, 2)
&#9;else
&#9;&#9;local part1 = partOrModel:GetChildren()[1]
&#9;&#9;for i, object in pairs(partOrModel:GetChildren()) do
&#9;&#9;&#9;if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;TrussPart&quot;)) then
&#9;&#9;&#9;&#9;boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
&#9;&#9;&#9;&#9;boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
&#9;&#9;&#9;&#9;boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)
&#9;&#9;&#9;&#9;boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

&#9;&#9;&#9;&#9;local minX = minVec.x
&#9;&#9;&#9;&#9;local minY = minVec.y
&#9;&#9;&#9;&#9;local minZ = minVec.z
&#9;&#9;&#9;&#9;local maxX = maxVec.x
&#9;&#9;&#9;&#9;local maxY = maxVec.y
&#9;&#9;&#9;&#9;local maxZ = maxVec.z
&#9;&#9;&#9;&#9;if boxMinInWorld.x &lt; minVec.x then
&#9;&#9;&#9;&#9;&#9;minX = boxMinInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.y &lt; minVec.y then
&#9;&#9;&#9;&#9;&#9;minY = boxMinInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.z &lt; minVec.z then
&#9;&#9;&#9;&#9;&#9;minZ = boxMinInWorld.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.x &lt; minX then
&#9;&#9;&#9;&#9;&#9;minX = boxMaxInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.y &lt; minY then
&#9;&#9;&#9;&#9;&#9;minY = boxMaxInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.z &lt; minZ then
&#9;&#9;&#9;&#9;&#9;minZ = boxMaxInWorld.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if boxMinInWorld.x &gt; maxVec.x then
&#9;&#9;&#9;&#9;&#9;maxX = boxMinInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.y &gt; maxVec.y then
&#9;&#9;&#9;&#9;&#9;maxY = boxMinInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.z &gt; maxVec.z then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMinInWorld.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.x &gt; maxX then
&#9;&#9;&#9;&#9;&#9;maxX = boxMaxInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.y &gt; maxY then
&#9;&#9;&#9;&#9;&#9;maxY = boxMaxInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.z &gt; maxZ then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMaxInWorld.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;minVec = Vector3.new(minX, minY, minZ)
&#9;&#9;&#9;&#9;maxVec = Vector3.new(maxX, maxY, maxZ)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return minVec, maxVec
end


function getTargetPartBoundingBox(targetPart)

&#9;if targetPart.Parent:FindFirstChild(&quot;RobloxModel&quot;) ~= nil then
&#9;&#9;return getBoundingBox2(targetPart.Parent)
&#9;else
&#9;&#9;return getBoundingBox2(targetPart)
&#9;end

end

function getMouseTargetCFrame(targetPart)

&#9;if targetPart.Parent:FindFirstChild(&quot;RobloxModel&quot;) ~= nil then
&#9;&#9;return targetPart.Parent:GetChildren()[1].CFrame
&#9;else
&#9;&#9;return targetPart.CFrame
&#9;end

end

function getClosestAlignedWorldDirection(aVector3InWorld)

&#9;local xDir = Vector3.new(1,0,0)
&#9;local yDir = Vector3.new(0,1,0)
&#9;local zDir = Vector3.new(0,0,1)
&#9;local xDot = aVector3InWorld.x * xDir.x + aVector3InWorld.y * xDir.y + aVector3InWorld.z * xDir.z
&#9;local yDot = aVector3InWorld.x * yDir.x + aVector3InWorld.y * yDir.y + aVector3InWorld.z * yDir.z
&#9;local zDot = aVector3InWorld.x * zDir.x + aVector3InWorld.y * zDir.y + aVector3InWorld.z * zDir.z

&#9;if math.abs(xDot) &gt; math.abs(yDot) and math.abs(xDot) &gt; math.abs(zDot) then
&#9;&#9;if xDot &gt; 0 then
&#9;&#9;&#9;return 0
&#9;&#9;else
&#9;&#9;&#9;return 3
&#9;&#9;end
&#9;elseif math.abs(yDot) &gt; math.abs(xDot) and math.abs(yDot) &gt; math.abs(zDot) then
&#9;&#9;if yDot &gt; 0 then
&#9;&#9;&#9;return 1
&#9;&#9;else
&#9;&#9;&#9;return 4
&#9;&#9;end
&#9;else
&#9;&#9;if zDot &gt; 0 then
&#9;&#9;&#9;return 2
&#9;&#9;else
&#9;&#9;&#9;return 5
&#9;&#9;end
&#9;end 

end


function findConfigAtMouseTarget(collection)

-- *Critical Assumption* :
--&#9;&#9;&#9;&#9;This function assumes the target CF axes are orthogonal with the target bounding box faces
--&#9;&#9;&#9;&#9;And, it assumes the insert CF axes are orthongonal with the insert bounding box faces
--&#9;&#9;&#9;&#9;Therefore, insertion will not work with angled faces on wedges or other &quot;non-block&quot; parts, nor
--&#9;&#9;&#9;&#9;will it work for parts in a model that are not orthogonally aligned with the model&apos;s CF.

&#9;local grid = 4.0
&#9;local admissibleConfig = false
&#9;local targetConfig = CFrame.new(0,0,0)

&#9;local minBB, maxBB = getBoundingBox2(collection[1])
&#9;local diagBB = maxBB - minBB

&#9;local insertCFrame
&#9;if collection[1]:IsA(&quot;Model&quot;) then
&#9;&#9;i = 1
&#9;&#9;while (i &lt; (#collection[1]:GetChildren()) and not isPart(collection[1]:GetChildren()[i])) do
&#9;&#9;&#9;i = i + 1
&#9;&#9;end
&#9;&#9;insertCFrame = collection[1]:GetChildren()[i].CFrame
&#9;else
&#9;&#9;insertCFrame = collection[1].CFrame
&#9;end

&#9;Mouse.TargetFilter = collection[1]

&#9;local targetPart = Mouse.Target

&#9;if targetPart == nil then
&#9;&#9;return admissibleConfig, targetConfig
&#9;end

&#9;-- test mouse hit location
&#9;local minBBTarget, maxBBTarget = getTargetPartBoundingBox(targetPart)
&#9;local diagBBTarget = maxBBTarget - minBBTarget
&#9;local targetCFrame = getMouseTargetCFrame(targetPart)
&#9;local hitCFrame = Mouse.Hit
&#9;local mouseHitInWorld = hitCFrame.p

&#9;--local targetVectorInWorld = targetCFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))

&#9;if targetPart:IsA(&quot;Terrain&quot;) then
&#9;&#9;if not cluster then cluster = game.Workspace.Terrain end

&#9;&#9;-- the prefer solid is messing things up very slightly!! (because the TargetSurface stays correct when the cells are shifted very slightly prematurely)
&#9;&#9;cellID = cluster:WorldToCellPreferSolid(mouseHitInWorld)
&#9;&#9;targetCFrame = CFrame.new(cluster:CellCenterToWorld(cellID.x, cellID.y, cellID.z))
&#9;end

&#9;local targetVectorInWorld = targetCFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))
&#9;local mouseHitInTarget = targetCFrame:pointToObjectSpace(mouseHitInWorld)

&#9;local targetRefPointInTarget
&#9;local clampToSurface

&#9;if getClosestAlignedWorldDirection(targetVectorInWorld) == 0 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;clampToSurface = Vector3.new(0,1,1)
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 3 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
&#9;&#9;clampToSurface = Vector3.new(0,1,1)
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 1 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;clampToSurface = Vector3.new(1,0,1)&#9;&#9;
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 4 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
&#9;&#9;clampToSurface = Vector3.new(1,0,1)
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 2 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
&#9;&#9;clampToSurface = Vector3.new(1,1,0)
&#9;else
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
&#9;&#9;clampToSurface = Vector3.new(1,1,0)
&#9;end

&#9;targetRefPointInTarget = targetRefPointInTarget * (0.5 * diagBBTarget) + 0.5 * (maxBBTarget + minBBTarget)
&#9;insertRefPointInInsert = insertRefPointInInsert * (0.5 * diagBB) + 0.5 * (maxBB + minBB)
&#9;
&#9;-- To Do: For cases that are not aligned to the world grid, account for the minimal rotation
&#9;-- needed to bring the Insert part(s) into alignment with the Target Part
&#9;-- Apply the rotation here

&#9;local delta = mouseHitInTarget - targetRefPointInTarget
&#9;local deltaClamped = Vector3.new(grid * math.modf(delta.x/grid), grid * math.modf(delta.y/grid), grid * math.modf(delta.z/grid))
&#9;deltaClamped = deltaClamped * clampToSurface
&#9;local targetTouchInTarget = deltaClamped + targetRefPointInTarget

&#9;local TargetTouchRelToWorld = targetCFrame:pointToWorldSpace(targetTouchInTarget)
&#9;local InsertTouchInWorld = insertCFrame:vectorToWorldSpace(insertRefPointInInsert)
&#9;local posInsertOriginInWorld = TargetTouchRelToWorld - InsertTouchInWorld

&#9;local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = insertCFrame:components()
&#9;targetConfig = CFrame.new(posInsertOriginInWorld.x, posInsertOriginInWorld.y, posInsertOriginInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
&#9;admissibleConfig = true

&#9;return admissibleConfig, targetConfig

end


function startDrag(mousePart, hitPoint, collection)
&#9;lastTargetCFrame = nil
&#9;dragger = Instance.new(&quot;Dragger&quot;)
&#9;pcall(function() dragger:MouseDown(mousePart, hitPoint, collection) end)
end

function collectBaseParts(object, collection)
&#9;if object == nil then return end
&#9;--if object:IsA(&quot;BasePart&quot;) then
&#9;if isPart(object) then
&#9;&#9;collection[#collection+1] = object
&#9;end
&#9;for index,child in pairs(object:GetChildren()) do
&#9;&#9;collectBaseParts(child, collection)
&#9;end
end

function onMouseDown(mouse) 
&#9;mouse.Icon =&quot;rbxasset://textures\\GrabRotateCursor.png&quot;
&#9;local part = mouse.Target
&#9;if canSelectObject(part) then
&#9;&#9;local hitPoint = mouse.Hit:toObjectSpace(part.CFrame).p
&#9;&#9;if trySelection(part) then
&#9;&#9;&#9;instances = {}
&#9;&#9;&#9;game.JointsService:ClearJoinAfterMoveJoints()
&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveInstance(mouse.Target)
&#9;&#9;&#9;collectBaseParts(currentSelection, instances)
&#9;&#9;&#9;startDrag(part, hitPoint, instances)
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
end



-- stampability-checking functions (copied from StampScript)

function flashRedBox(targetModel)
&#9;if not player then return end
&#9;errorBox.Parent = player.PlayerGui
&#9;errorBox.Adornee = targetModel

&#9;delay(0,function()
&#9;&#9;for i = 1, 3 do
&#9;&#9;&#9;errorBox.Visible = true
&#9;&#9;&#9;wait(0.13)
&#9;&#9;&#9;errorBox.Visible = false
&#9;&#9;&#9;wait(0.13)
&#9;&#9;end
&#9;&#9;errorBox.Adornee = nil
&#9;&#9;errorBox.Parent = Tool
&#9;end)
end

-- below function should work as a Region3 query, returning true if a single cluster part is within this region
function clusterPartsInRegion(startVector, endVector)

&#9;if not cluster then return false end

&#9;local startCell = cluster:WorldToCell(startVector)
&#9;local endCell = cluster:WorldToCell(endVector)

&#9;local startX = startCell.X
&#9;local startY = startCell.Y
&#9;local startZ = startCell.Z

&#9;local endX = endCell.X
&#9;local endY = endCell.Y
&#9;local endZ = endCell.Z

&#9;if startX &lt; cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
&#9;if startY &lt; cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
&#9;if startZ &lt; cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end

&#9;if endX &gt; cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
&#9;if endY &gt; cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
&#9;if endZ &gt; cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end

&#9;--print(startX, endX)
&#9;--print(startY, endY)
&#9;--print(startZ, endZ)

&#9;for x = startX, endX do
&#9;&#9;for y = startY, endY do
&#9;&#9;&#9;for z = startZ, endZ do
&#9;&#9;&#9;&#9;--if game.Workspace.Cluster:GetCell(x, y, z) &gt; 0 then return true end
&#9;&#9;&#9;&#9;if (cluster:GetCell(x, y, z).Value) &gt; 0 then return true end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return false
end


-- helper function to determine if a character can be pushed upwards by a certain amount
-- FILL THIS OUT!!!  -- character is 5 studs tall, we&apos;ll check a 1.5 x 1.5 x 4.5 box around char, with center .5 studs below torsocenter
function spaceAboveCharacter(charTorso, newTorsoY)
&#9;local partsAboveChar = game.Workspace:FindPartsInRegion3(Region3.new(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)), charTorso.Parent, 100)
&#9;for j = 1, #partsAboveChar do
&#9;&#9;if partsAboveChar[j].CanCollide and not partsAboveChar[j]:IsDescendantOf(currentSelection) then return false end
&#9;end

&#9;if clusterPartsInRegion(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)) then return false end

&#9;return true
end



local insertBoundingBoxOverlapVector = Vector3.new(1, 1, 1)

function onMouseUp(mouse)
&#9;mouse.Icon =&quot;rbxasset://textures\\GrabCursor.png&quot;
&#9;local thingToPlace = {}
&#9;thingToPlace[1] = currentSelection

&#9;if dragger ~= nil then
&#9;&#9;local minBB, maxBB = getBoundingBoxInWorldCoordinates(currentSelection)
&#9;&#9;local configFound, targetCFrame = findConfigAtMouseTarget(thingToPlace)

&#9;&#9;if configFound then
&#9;&#9;&#9;-- don&apos;t drag into terrain
&#9;&#9;&#9;if clusterPartsInRegion(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector) then flashRedBox(currentSelection) return end
&#9;&#9;&#9;
&#9;&#9;&#9;local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector), currentSelection, 100)
&#9;&#9;&#9;for b = 1, #blockingParts do
&#9;&#9;&#9;&#9;-- put code back here if we want to prevent dragger from dragging into other stamped models (once Region3 fix goes out)
&#9;&#9;&#9;end

&#9;&#9;&#9;local alreadyPushedUp = {}
&#9;&#9;&#9;-- if no blocking model below, then see if stamping on top of a character
&#9;&#9;&#9;for b = 1, #blockingParts do
&#9;&#9;&#9;&#9;if blockingParts[b].Parent and not alreadyPushedUp[blockingParts[b].Parent] and blockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;) and blockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;):IsA(&quot;Humanoid&quot;) then
&#9;&#9;&#9;&#9;&#9;local blockingPersonTorso = blockingParts[b].Parent:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;&#9;alreadyPushedUp[blockingParts[b].Parent] = true

&#9;&#9;&#9;&#9;&#9;if blockingPersonTorso then
&#9;&#9;&#9;&#9;&#9;&#9;-- if so, let&apos;s push the person upwards so they pop on top of the stamped model/part (but only if there&apos;s space above them)
&#9;&#9;&#9;&#9;&#9;&#9;local newY = maxBB.Y + 3
&#9;&#9;&#9;&#9;&#9;&#9;if spaceAboveCharacter(blockingPersonTorso, newY) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if no space, we just error
&#9;&#9;&#9;&#9;&#9;&#9;&#9;flashRedBox(currentSelection)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Mouse.TargetFilter = nil
&#9;&#9;&#9;pcall(function() dragger:MouseUp() end)
&#9;&#9;&#9;game.JointsService:CreateJoinAfterMoveJoints()
&#9;&#9;&#9;dragger = nil
&#9;&#9;end
&#9;end
end


function trySelection(part)
&#9;if canSelectObject(part) then
&#9;&#9;local model = findModel(part)
&#9;&#9;if model then &#9;&#9;
&#9;&#9;&#9;return setSelection(model)
&#9;&#9;else
&#9;&#9;&#9;return setSelection(part)
&#9;&#9;end
&#9;else
&#9;&#9;clearSelection()
&#9;&#9;return false
&#9;end
end

function onKeyDown(key)
&#9;if dragger ~= nil then
&#9;&#9;if key == &apos;R&apos; or key == &apos;r&apos;  then
&#9;&#9;&#9;pcall(function() dragger:AxisRotate(Enum.Axis.Y) end)
&#9;&#9;elseif key == &apos;T&apos; or key == &apos;t&apos; then
&#9;&#9;&#9;pcall(function() dragger:AxisRotate(Enum.Axis.Z) end)
&#9;&#9;end
&#9;end
end

local alreadyMoving = false
function onMouseMove(mouse)
&#9;if alreadyMoving then
&#9;&#9;return
&#9;end

&#9;alreadyMoving = true
&#9;if dragger ~= nil then
&#9;&#9;local thingToDrag = {}
&#9;&#9;thingToDrag[1] = currentSelection 
&#9;
&#9;&#9;pcall(function() dragger:MouseMove(mouse.UnitRay) end)-- needed to break welds properly
&#9;&#9;configFound, targetCFrame = findConfigAtMouseTarget(thingToDrag)
&#9;&#9;if configFound then
&#9;&#9;&#9;local minBB, maxBB = getBoundingBoxInWorldCoordinates(currentSelection)
&#9;
&#9;&#9;&#9;-- need to offset by distance to be dragged
&#9;&#9;&#9;local currModelCFrame
&#9;&#9;&#9;if currentSelection:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;&#9;-- we assume model has at least one part in it; need to find first part
&#9;&#9;&#9;&#9;i = 1
&#9;&#9;&#9;&#9;while (i &lt; (#currentSelection:GetChildren()) and not isPart(currentSelection:GetChildren()[i])) do
&#9;&#9;&#9;&#9;&#9;i = i + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;currModelCFrame = currentSelection:GetChildren()[i].CFrame
&#9;&#9;&#9;else currModelCFrame = currentSelection.CFrame end
&#9;&#9;&#9;minBB = minBB + targetCFrame.p - currModelCFrame.p
&#9;&#9;&#9;maxBB = maxBB + targetCFrame.p - currModelCFrame.p

&#9;&#9;&#9;-- don&apos;t drag into terrain
&#9;&#9;&#9;if clusterPartsInRegion(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector) then 
&#9;&#9;&#9;&#9;if lastTargetCFrame then positionPartsAtCFrame3(thingToDrag, lastTargetCFrame) end
&#9;&#9;&#9;&#9;alreadyMoving = false 
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector), currentSelection, 100)
&#9;&#9;&#9;for b = 1, #blockingParts do
&#9;&#9;&#9;&#9;-- put code back here if we want to prevent dragger from dragging into other stamped models (once Region3 fix goes out)
&#9;&#9;&#9;end
&#9;&#9;&#9;positionPartsAtCFrame3(thingToDrag, targetCFrame)
&#9;&#9;&#9;lastTargetCFrame = targetCFrame
&#9;&#9;end
&#9;else
&#9;&#9;trySelection(mouse.Target)
&#9;end
&#9;alreadyMoving = false
end


function saveSelectionColor(instance)
&#9;if instance:IsA(&quot;BasePart&quot;) then
&#9;&#9;currentSelectionColors[instance] = instance.BrickColor
&#9;&#9;if instance.BrickColor == BrickColor.Blue() then
&#9;&#9;&#9;instance.BrickColor = BrickColor.new(&quot;Deep blue&quot;)
&#9;&#9;else
&#9;&#9;&#9;instance.BrickColor = BrickColor.Blue()
&#9;&#9;end
&#9;end

&#9;local children = instance:GetChildren() 
&#9;if children then
&#9;&#9;for pos, child in pairs(children) do
&#9;&#9;&#9;saveSelectionColor(child)
&#9;&#9;end
&#9;end
end
&#9;
function setSelection(partOrModel)
&#9;if partOrModel ~= currentSelection then
&#9;&#9;clearSelection()
&#9;&#9;currentSelection = partOrModel
&#9;&#9;saveSelectionColor(currentSelection)
&#9;&#9;selectionBox.Adornee = currentSelection
&#9;&#9;return true
&#9;elseif partOrModel == nil then
&#9;&#9;clearSelection()
&#9;&#9;return false
&#9;end

&#9;return partOrModel == currentSelection
end

function clearSelection()
&#9;if currentSelection ~= nil then
&#9;&#9;for part, color in pairs(currentSelectionColors) do
&#9;&#9;&#9;part.BrickColor = color
&#9;&#9;end
&#9;&#9;selectionBox.Adornee = nil
&#9;end
&#9;currentSelectionColors = {}
&#9;currentSelection = nil

&#9;if(selectionBox) then
&#9;&#9;selectionBox.Adornee = nil
&#9;end
end

function onEquippedLocal(mouse)
&#9;Mouse = mouse

&#9;local character = script.Parent.Parent.Parent
&#9;player = game.Players:GetPlayerFromCharacter(character)

&#9;mouse.Icon =&quot;rbxasset://textures\\GrabCursor.png&quot;

&#9;local con = Mouse.Button1Down:connect(function() onMouseDown(Mouse) end)
&#9;table.insert(connections,con)
&#9;con = Mouse.Button1Up:connect(function() onMouseUp(Mouse) end)
&#9;con = table.insert(connections,con)
&#9;con = Mouse.Move:connect(function() onMouseMove(Mouse) end)
&#9;table.insert(connections,con)
&#9;con = Mouse.KeyDown:connect(function(string) onKeyDown(string) end)
&#9;table.insert(connections,con)

&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Name = &quot;Model Delete Selection&quot;
&#9;selectionBox.Color = BrickColor.Blue()
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = player.PlayerGui

&#9;alreadyMoving = false
end

function onUnequippedLocal()
&#9;for i = 1, #connections do
&#9;&#9;connections[i]:disconnect()
&#9;end
&#9;connections = {}

&#9;clearSelection()
&#9;selectionBox:Remove()
end

script.Active.Changed:connect(function()
&#9;if script.Active.Value then
&#9;&#9;onEquippedLocal(Tool.Mouse.Value)
&#9;else
&#9;&#9;onUnequippedLocal()
&#9;end
end)</ProtectedString>
					</Properties>
					<Item class="BoolValue" referent="RBX171">
						<Properties>
							<string name="Name">Active</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="SelectionBox" referent="RBX172">
				<Properties>
					<Ref name="Adornee">null</Ref>
					<int name="Color">21</int>
					<string name="Name">ErrorBox</string>
					<float name="Transparency">0</float>
					<bool name="Visible">false</bool>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>